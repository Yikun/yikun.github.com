<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>Build/check report for BioC 3.18 - CHECK results for lpNet on kunpeng1</TITLE>
<LINK rel="stylesheet" href="../report.css" type="text/css">
<SCRIPT type="text/javascript" src="../report.js"></SCRIPT>
</HEAD>
<BODY onLoad="initialize();">
<TABLE class="grid_layout" style="width: 100%; background: #EEE;"><TR><TD style="text-align: left; padding: 5px; vertical-align: middle;"><I>Back to <B>Build/check report for BioC 3.18</B>:&nbsp;&nbsp;&nbsp;<A href="../">simplified</A>&nbsp;&nbsp;&nbsp;<A href="../long-report.html">long</A></I></TD><TD><TABLE class="abc_dispatcher"><TR><TD><A href="..#A">A</A></TD><TD><A href="..#B">B</A></TD><TD><A href="..#C">C</A></TD><TD><A href="..#D">D</A></TD><TD><A href="..#E">E</A></TD><TD><A href="..#F">F</A></TD><TD><A href="..#G">G</A></TD><TD><A href="..#H">H</A></TD><TD><A href="..#I">I</A></TD><TD><A href="..#J">J</A></TD><TD><A href="..#K">K</A></TD><TD><B>[<A href="..#L">L</A>]</B></TD><TD><A href="..#M">M</A></TD><TD><A href="..#N">N</A></TD><TD><A href="..#O">O</A></TD><TD><A href="..#P">P</A></TD><TD><A href="..#Q">Q</A></TD><TD><A href="..#R">R</A></TD><TD><A href="..#S">S</A></TD><TD><A href="..#T">T</A></TD><TD><A href="..#U">U</A></TD><TD><A href="..#V">V</A></TD><TD><A href="..#W">W</A></TD><TD><A href="..#X">X</A></TD><TD><A href="..#Y">Y</A></TD><TD><A href="..#Z">Z</A></TD></TR></TABLE></TD></TR></TABLE>
<P class="time_stamp">
This page was generated on 2023-05-31 05:44:37 -0000 (Wed, 31 May 2023).
</P>
<TABLE class="node_specs">
<TR><TH>Hostname</TH><TH>OS</TH><TH>Arch&nbsp;(*)</TH><TH>R&nbsp;version</TH><TH style="text-align: right;">Installed&nbsp;pkgs</TH></TR>
<TR class="kunpeng1"><TD><B><A href="../kunpeng1-NodeInfo.html"><B>kunpeng1</B></A></B></TD><TD>Linux&nbsp;(Ubuntu&nbsp;22.04.1&nbsp;LTS)</TD><TD>aarch64</TD><TD>4.3.0&nbsp;(2023-04-21)&nbsp;--&nbsp;"Already&nbsp;Tomorrow"
</TD><TD style="text-align: right;"><A href="../kunpeng1-R-instpkgs.html">4219</A></TD></TR>
<TR><TD COLSPAN="5" style="font-size: smaller;"><I>Click on any hostname to see more info about the system (e.g. compilers) &nbsp;&nbsp;&nbsp;&nbsp; (*) as reported by 'uname -p', except on Windows and Mac OS X</I></TD></TR>
</TABLE>
<BR>
<H2><SPAN class="kunpeng1">CHECK results for lpNet on kunpeng1</SPAN></H2>
<BR>
<DIV class="motd">
<TABLE><TR><TD>
To the developers/maintainers of the lpNet package:<BR>
- Allow up to 24 hours (and sometimes 48 hours) for your latest push to git@git.bioconductor.org:packages/lpNet.git to reflect on this report. See <A href="%s">Troubleshooting Build Report</A> for more information.<BR><BR>
- Use the following <A href="../Renviron.bioc">Renviron settings</A> to reproduce errors and warnings.<BR><BR>
Note: If "R CMD check" recently failed on the Linux builder over a missing dependency, add the missing dependency to "Suggests" in your DESCRIPTION file. See the <A href="../Renviron.bioc">Renviron.bioc</A> for details.
</TD></TR></TABLE>
</DIV>
<P style="text-align: center;"><A href="raw-results/">raw results</A><P>
<TABLE class="gcard_list">
<TBODY class="gcard warnings">
<TR class="header"><TD class="leftmost top_left_corner"></TD><TD>Package <B>1070</B>/2197</TD><TD style="width: 75px;">Hostname</TD><TD style="width: 225px;">OS&nbsp;/&nbsp;Arch</TD><TD class="STAGE install">INSTALL</TD><TD class="STAGE buildsrc">BUILD</TD><TD class="STAGE checksrc selected">CHECK</TD><TD class="STAGE buildbin">BUILD BIN</TD><TD style="width: 12px;"></TD><TD class="rightmost top_right_corner"></TD></TR>
<TR class="selected_row"><TD ROWSPAN="2" class="leftmost bottom_left_corner"></TD><TD ROWSPAN="1" style="vertical-align: top;"><B><A href="./">lpNet</A>&nbsp;2.33.0</B>&nbsp;&nbsp;<SPAN style="font-size: smaller; font-style: italic;">(<A href="/packages/3.18/lpNet">landing page</A>)</SPAN><BR>Lars Kaderali<BR><TABLE class="svn_info">
<TR><TD class="svn_info">Snapshot&nbsp;Date:&nbsp;<SPAN class="svn_info">2023-05-29&nbsp;10:19:22&nbsp;-0000&nbsp;(Mon,&nbsp;29&nbsp;May&nbsp;2023)</SPAN></TD></TR>
<TR><TD class="svn_info">git_url:&nbsp;<SPAN class="svn_info">https://git.bioconductor.org/packages/lpNet</SPAN></TD></TR>
<TR><TD class="svn_info">git_branch:&nbsp;<SPAN class="svn_info">devel</SPAN></TD></TR>
<TR><TD class="svn_info">git_last_commit:&nbsp;<SPAN class="svn_info">13c6b01</SPAN></TD></TR>
<TR><TD class="svn_info">git_last_commit_date:&nbsp;<SPAN class="svn_info">2023-04-25&nbsp;14:25:43&nbsp;-0000&nbsp;(Tue,&nbsp;25&nbsp;Apr&nbsp;2023)</SPAN></TD></TR>
</TABLE>
</TD><TD class="kunpeng1 selected"><B>kunpeng1</B></TD><TD class="kunpeng1"><SPAN style="font-size: smaller;">Linux&nbsp;(Ubuntu&nbsp;22.04.1&nbsp;LTS)&nbsp;/&nbsp;aarch64</SPAN></TD><TD class="status kunpeng1 install"><A href="./kunpeng1-install.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1 buildsrc"><A href="./kunpeng1-buildsrc.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1 checksrc selected"><A href="./kunpeng1-checksrc.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph WARNINGS">&nbsp;&nbsp;WARNINGS&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1"></TD><TD class="status kunpeng1"></TD><TD ROWSPAN="2" class="rightmost bottom_right_corner"></TD></TR>
<TR class="footer"><TD COLSPAN="8"></TD></TR>
</TBODY>
</TABLE>
<HR>
<H3>Summary</H3>
<DIV class="kunpeng1 hscrollable">
<TABLE>
<TR><TD><B>Package</B>: lpNet</TD></TR>
<TR><TD><B>Version</B>: 2.33.0</TD></TR>
<TR><TD><B>Command</B>: /home/biocbuild/R/R-4.3.0/bin/R CMD check --install=check:lpNet.install-out.txt --library=/home/biocbuild/R/R-4.3.0/site-library --timings lpNet_2.33.0.tar.gz</TD></TR>
<TR><TD><B>StartedAt</B>: 2023-05-30 10:53:28 -0000 (Tue, 30 May 2023)</TD></TR>
<TR><TD><B>EndedAt</B>: 2023-05-30 10:54:59 -0000 (Tue, 30 May 2023)</TD></TR>
<TR><TD><B>EllapsedTime</B>: 91.1 seconds</TD></TR>
<TR><TD><B>RetCode</B>: 0</TD></TR>
<TR><TD><B>Status</B>: <SPAN class="glyph WARNINGS">&nbsp;&nbsp;WARNINGS&nbsp;&nbsp;</SPAN></TD></TR>
<TR><TD><B>CheckDir</B>: lpNet.Rcheck</TD></TR>
<TR><TD><B>Warnings</B>: 2</TD></TR>
</TABLE>
</DIV>
<HR>
<H3>Command output</H3>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">
##############################################################################
##############################################################################
###
### Running command:
###
###   /home/biocbuild/R/R-4.3.0/bin/R CMD check --install=check:lpNet.install-out.txt --library=/home/biocbuild/R/R-4.3.0/site-library --timings lpNet_2.33.0.tar.gz
###
##############################################################################
##############################################################################


* using log directory ‘/home/biocbuild/bbs-3.18-bioc/meat/lpNet.Rcheck’
* using R version 4.3.0 (2023-04-21)
* using platform: aarch64-unknown-linux-gnu (64-bit)
* R was compiled by
    gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
    GNU Fortran (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
* running under: Ubuntu 22.04.2 LTS
* using session charset: UTF-8
* checking for file ‘lpNet/DESCRIPTION’ ... OK
* checking extension type ... Package
* this is package ‘lpNet’ version ‘2.33.0’
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘lpNet’ can be installed ... OK
* checking installed package size ... OK
* checking package directory ... OK
* checking ‘build’ directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking loading without being on the library search path ... OK
* checking dependencies in R code ... OK
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... NOTE
.calcRangeLambda_steadyState: no visible global function definition for
  ‘var’
.calcRangeLambda_timeSeries: no visible global function definition for
  ‘var’
.calculatePredictionValue_Kfold_ts: no visible global function
  definition for ‘rnorm’
.calculatePredictionValue_LOOCV_ss: no visible global function
  definition for ‘rnorm’
.calculatePredictionValue_LOOCV_ts: no visible global function
  definition for ‘rnorm’
.set_per_gene_exp_time_values: no visible global function definition
  for ‘rnorm’
.set_per_gene_exp_values: no visible global function definition for
  ‘rnorm’
.set_per_gene_time_values: no visible global function definition for
  ‘rnorm’
.set_per_gene_values: no visible global function definition for ‘rnorm’
.set_single_values: no visible global function definition for ‘rnorm’
getSampleAdja: no visible binding for global variable ‘median’
getSampleAdjaMAD: no visible binding for global variable ‘median’
getSampleAdjaMAD: no visible binding for global variable ‘mad’
summarizeRepl: no visible binding for global variable ‘median’
Undefined global functions or variables:
  mad median rnorm var
Consider adding
  importFrom(&quot;stats&quot;, &quot;mad&quot;, &quot;median&quot;, &quot;rnorm&quot;, &quot;var&quot;)
to your NAMESPACE file.
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... WARNING
Undocumented data sets:
  ‘dat.normalized’ ‘dat.unnormalized’
All user-level objects in a package should have documentation entries.
See chapter ‘Writing R documentation files’ in the ‘Writing R
Extensions’ manual.
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking contents of ‘data’ directory ... OK
* checking data for non-ASCII characters ... OK
* checking data for ASCII and uncompressed saves ... OK
* checking installed files from ‘inst/doc’ ... OK
* checking files in ‘vignettes’ ... OK
* checking examples ... OK
* checking for unstated dependencies in ‘tests’ ... OK
* checking tests ...
  Running ‘runitCalcActivation.R’
  Running ‘runitCalcPredictionKfoldCV.R’
  Running ‘runitCalcPredictionKfoldCV_timeSeries.R’
  Running ‘runitCalcPredictionLOOCV.R’
  Running ‘runitCalcPredictionLOOCV_timeSeries.R’
  Running ‘runitCalcRangeLambda.R’
  Running ‘runitDoILP.R’
  Running ‘runitDoILP_timeSeries.R’
  Running ‘runitGenerateTimeSeriesNetStates.R’
  Running ‘runitGetAdja.R’
  Running ‘runitGetBaseline.R’
  Running ‘runitGetEdgeAnnot.R’
  Running ‘runitGetObsMat.R’
  Running ‘runitGetSampleAdja.R’
  Running ‘runitGetSampleAdjaMAD.R’
  Running ‘runitKfoldCV.R’
  Running ‘runitKfoldCV_timeSeries.R’
  Running ‘runitLOOCV.R’
  Running ‘runitLOOCV_timeSeries.R’
 OK
* checking for unstated dependencies in vignettes ... NOTE
&#x27;library&#x27; or &#x27;require&#x27; call not declared from: ‘KEGGgraph’
* checking package vignettes in ‘inst/doc’ ... OK
* checking running R code from vignettes ...
  ‘vignette_lpNet.Rnw’... failed
 WARNING
Errors in running code in vignettes:
when running code in ‘vignette_lpNet.Rnw’
  ...
&gt; res5 &lt;- doILP(obs, delta, lambda = 1, b, n, K, T_ = NULL, 
+     annot = getEdgeAnnot(n), delta_type, prior = prior)

&gt; adja5 &lt;- getAdja(res5, n)

&gt; library(&quot;KEGGgraph&quot;)

  When sourcing ‘vignette_lpNet.R’:
Error: there is no package called ‘KEGGgraph’
Execution halted

* checking re-building of vignette outputs ... NOTE
Error(s) in re-building vignettes:
  ...
--- re-building ‘vignette_lpNet.Rnw’ using Sweave
Loading required package: lpSolve

Error: processing vignette &#x27;vignette_lpNet.Rnw&#x27; failed with diagnostics:
 chunk 15 (label = prior4) 
Error in library(&quot;KEGGgraph&quot;) : there is no package called ‘KEGGgraph’

--- failed re-building ‘vignette_lpNet.Rnw’

SUMMARY: processing the following file failed:
  ‘vignette_lpNet.Rnw’

Error: Vignette re-building failed.
Execution halted

* checking PDF version of manual ... OK
* DONE

Status: 2 WARNINGs, 3 NOTEs
See
  ‘/home/biocbuild/bbs-3.18-bioc/meat/lpNet.Rcheck/00check.log’
for details.


</PRE>
</DIV><HR>
<H3>Installation output</H3>
<P><SPAN class="filename">lpNet.Rcheck/00install.out</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">
##############################################################################
##############################################################################
###
### Running command:
###
###   /home/biocbuild/R/R-4.3.0/bin/R CMD INSTALL lpNet
###
##############################################################################
##############################################################################


* installing to library ‘/home/biocbuild/R/R-4.3.0/site-library’
* installing *source* package ‘lpNet’ ...
** using staged installation
** R
** data
** inst
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
** building package indices
** installing vignettes
** testing if installed package can be loaded from temporary location
** testing if installed package can be loaded from final location
** testing if installed package keeps a record of temporary installation path
* DONE (lpNet)
</PRE>
</DIV><HR>
<H3>Tests output</H3>
<P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcActivation.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.calcActivationShortExample &lt;- function() {
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(0,0,0,
+ 													1,0,0,
+ 													1,1,0,
+ 													1,1,1), nrow=n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; 
&gt; test.calcActivationShortExampleTimeSeries &lt;- function() {
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(0,0,0,
+ 													1,0,0,
+ 													1,1,0,
+ 													1,1,1), nrow=n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K, flag_gen_data=TRUE)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; 
&gt; test.calcActivation &lt;- function() {
+ 	n &lt;- 5
+ 	K &lt;- 6
+ 	
+ 	true_result &lt;- matrix(c(0,0,0,0,0,
+ 													1,0,1,1,1,
+ 													1,1,0,0,0,
+ 													1,1,1,0,0,
+ 													1,1,1,0,0,
+ 													1,1,1,0,0), nrow=n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,1,0,0,
+ 									 0,0,0,-1,0,
+ 									 0,0,0,1,0,
+ 									 0,0,0,0,1,
+ 									 0,0,0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 									 
+ 	b &lt;- c(0,1,1,1,1,
+ 				 1,0,1,1,1,
+ 				 1,1,0,1,1,
+ 				 1,1,1,0,1,
+ 				 1,1,1,1,0,
+ 				 1,1,1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; 
&gt; test.calcActivationTimeSeries &lt;- function() {
+ 	n &lt;- 5
+ 	K &lt;- 6
+ 	
+ 	true_result &lt;- matrix(c(0,0,0,0,0,
+ 													1,0,1,1,1,
+ 													1,1,0,1,1,
+ 													1,1,1,0,0,
+ 													1,1,1,1,0,
+ 													1,1,1,1,1), nrow=n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,1,0,0,
+ 									 0,0,0,-1,0,
+ 									 0,0,0,1,0,
+ 									 0,0,0,0,1,
+ 									 0,0,0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,1,1,
+ 				 1,0,1,1,1,
+ 				 1,1,0,1,1,
+ 				 1,1,1,0,1,
+ 				 1,1,1,1,0,
+ 				 1,1,1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K, flag_gen_data=TRUE)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; 
&gt; test.calcActivationLargeExample &lt;- function() {
+ 	n &lt;- 10
+ 	K &lt;- 11
+ 	
+ 	true_result &lt;- matrix(c(0,0,0,1,1,1,1,1,1,1,
+ 													1,0,0,1,1,1,1,1,1,1,
+ 													1,0,0,1,1,1,1,1,1,1,
+ 													1,1,1,0,0,0,0,0,0,0,
+ 													1,1,1,1,0,0,0,0,0,0,
+ 													1,1,1,1,1,0,0,0,0,0,
+ 													1,0,0,1,1,1,0,0,0,0,
+ 													1,0,0,1,1,1,1,0,0,0,
+ 													1,0,0,1,1,1,1,1,0,0,
+ 													1,0,0,1,1,1,1,1,1,0,
+ 													1,0,0,1,1,1,1,1,1,1), nrow=n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,0,0,0,0,0,0,0,
+ 									 0,0,1,0,0,0,0,0,0,0,
+ 									 0,0,0,0,0,0,0,0,0,0,
+ 									 0,0,0,0,1,0,0,0,0,0,
+ 									 0,0,0,0,0,1,0,0,0,0,
+ 									 0,-1,0,0,0,0,1,0,0,0,
+ 									 0,0,0,0,0,0,0,1,0,0,
+ 									 0,0,0,0,0,0,0,0,1,0,
+ 									 0,0,0,0,0,0,1,0,0,1,
+ 									 0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	
+ 	b &lt;- c(0,1,1,1,1,1,1,1,1,1,
+ 				 1,0,1,1,1,1,1,1,1,1,
+ 				 1,1,0,1,1,1,1,1,1,1,
+ 				 1,1,1,0,1,1,1,1,1,1,
+ 				 1,1,1,1,0,1,1,1,1,1,
+ 				 1,1,1,1,1,0,1,1,1,1,
+ 				 1,1,1,1,1,1,0,1,1,1,
+ 				 1,1,1,1,1,1,1,0,1,1,
+ 				 1,1,1,1,1,1,1,1,0,1,
+ 				 1,1,1,1,1,1,1,1,1,0,
+ 				 1,1,1,1,1,1,1,1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; 
&gt; test.calcActivationLargeExampleTimeSeries &lt;- function() {
+ 	n &lt;- 10
+ 	K &lt;- 11
+ 	
+ 	true_result &lt;- matrix(c(0,1,1,1,1,1,1,1,1,1,
+ 													1,0,0,1,1,1,1,1,1,1,
+ 													1,1,0,1,1,1,1,1,1,1,
+ 													1,1,1,0,0,0,0,0,0,0,
+ 													1,1,1,1,0,0,0,0,0,0,
+ 													1,1,1,1,1,0,0,0,0,0,
+ 													1,1,1,1,1,1,0,0,0,0,
+ 													1,1,1,1,1,1,1,0,0,0,
+ 													1,1,1,1,1,1,1,1,0,0,
+ 													1,1,1,1,1,1,1,1,1,0,
+ 													1,1,1,1,1,1,1,1,1,1), nrow = n, ncol=K)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,0,0,0,0,0,0,0,
+ 									0,0,1,0,0,0,0,0,0,0,
+ 									0,0,0,0,0,0,0,0,0,0,
+ 									0,0,0,0,1,0,0,0,0,0,
+ 									0,0,0,0,0,1,0,0,0,0,
+ 									0,-1,0,0,0,0,1,0,0,0,
+ 									0,0,0,0,0,0,0,1,0,0,
+ 									0,0,0,0,0,0,0,0,1,0,
+ 									0,0,0,0,0,0,1,0,0,1,
+ 									0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	
+ 	b &lt;- c(0,1,1,1,1,1,1,1,1,1,
+ 				1,0,1,1,1,1,1,1,1,1,
+ 				1,1,0,1,1,1,1,1,1,1,
+ 				1,1,1,0,1,1,1,1,1,1,
+ 				1,1,1,1,0,1,1,1,1,1,
+ 				1,1,1,1,1,0,1,1,1,1,
+ 				1,1,1,1,1,1,0,1,1,1,
+ 				1,1,1,1,1,1,1,0,1,1,
+ 				1,1,1,1,1,1,1,1,0,1,
+ 				1,1,1,1,1,1,1,1,1,0,
+ 				1,1,1,1,1,1,1,1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K, flag_gen_data=TRUE)
+ 
+ 	checkEquals(true_result, act_mat)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.213   0.016   0.213 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcPredictionKfoldCV.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function() {
+ 
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 
+ 	T_nw &lt;&lt;- matrix(c(0,1,0,
+ 										0,0,1,
+ 										0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;&lt;- c(0,1,1,
+ 					1,0,1,
+ 					1,1,0,
+ 					1,1,1)
+ 
+ 	obs_mat &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											 0.56, 0.56, 0.95, 0.95,
+ 											 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;&lt;- c(0.76, 0.76, 0)
+ 	
+ 	mu_types &lt;&lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 
+ 	mu_list &lt;&lt;- list()
+ 	mu_list[[1]] &lt;&lt;- list()
+ 	mu_list[[2]] &lt;&lt;- list()
+ 	mu_list[[3]] &lt;&lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;&lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;&lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;&lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;&lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;&lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;&lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,4] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		## calculate mean squared error of predicted and observed
+ 		predict &lt;- calcPredictionKfoldCV(obs, delta, b, n, K, adja=T_nw, baseline, rem_entries, rem_entries_vec,
+ 																		 active_mu, active_sd, inactive_mu, inactive_sd, mu_type=mu_type) 
+ 		
+ 		checkEquals(obs_mat, predict, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.205   0.037   0.223 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcPredictionKfoldCV_timeSeries.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function() {
+ 
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 	T_ &lt;&lt;- 3
+ 
+ 	T_nw &lt;&lt;- matrix(c(0,0,1,
+ 									  0,0,-1,
+ 									  0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;&lt;- c(0,1,1,
+ 					1,0,1,
+ 					1,1,0,
+ 					1,1,1)
+ 
+ 	obs_mat &lt;&lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;&lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.95, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.95, 0.56, 0.95, 0.95,
+ 														0.56, 0.95, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;&lt;- c(0.76, 0.76, 0)
+ 
+ 	mu_types &lt;&lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 
+ 	mu_list &lt;&lt;- list()
+ 	mu_list[[1]] &lt;&lt;- list()
+ 	mu_list[[2]] &lt;&lt;- list()
+ 	mu_list[[3]] &lt;&lt;- list()
+ 	mu_list[[4]] &lt;&lt;- list()
+ 	mu_list[[5]] &lt;&lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;&lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;&lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;&lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;&lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;&lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;&lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	mu_list[[4]]$active_mu &lt;&lt;- matrix(rep(0.95, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$active_sd &lt;&lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$delta &lt;&lt;- matrix(rep(0.755, n*T_), nrow=n, ncol=T_)
+ 
+ 	mu_list[[5]]$active_mu &lt;&lt;- array(rep(0.95, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$active_sd &lt;&lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_mu &lt;&lt;- array(rep(0.56, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_sd &lt;&lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$delta &lt;&lt;- array(rep(0.755, n*K*T_), c(n,K,T_))
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV01 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	baseline &lt;- c(0, 0, 0)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,4,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		## calculate mean squared error of predicted and observed
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																		 baseline=baseline, rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 		
+ 		checkEquals(predict[2,4,2], 0.56, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV02 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 									 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,4,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																		 baseline=baseline, rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 		
+ 		checkEquals(predict[2,4,2], 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV03 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[3,4,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, baseline=baseline, 
+ 																		 rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 	checkEquals(predict[3,4,3], 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV04 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,-1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 		
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,4,2] &lt;- NA
+ 	obs_modified[3,4,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, baseline=baseline, 
+ 																		 rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 		checkTrue(is.na(predict[3,4,3]))
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV05 &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,2,2] &lt;- NA
+ 	obs_modified[3,2,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																		 baseline=baseline,  rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 	checkEquals(predict[2,2,2], 0.56, tolerance=0.05)
+ 	checkEquals(predict[3,2,3], 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV06 &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,2,1] &lt;- NA
+ 	obs_modified[3,2,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																		 baseline=baseline, rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 		checkEquals(predict[2,2,1], 0.56, tolerance=0.05)
+ 		checkTrue(is.na(predict[3,2,2]))
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionKfoldCV07 &lt;- function() {
+ 
+ 	baseline &lt;- c(0.76, 0.76, 0.76)
+ 
+ 	obs_modified &lt;- obs_mat
+ 	obs_modified[2,2,1] &lt;- NA
+ 	obs_modified[3,2,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionKfoldCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, baseline=baseline, 
+ 																		 rem_entries=rem_entries, rem_entries_vec=rem_entries_vec,
+ 																		 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																		 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 																								
+ 		checkEquals(predict[2,2,1], 0.56, tolerance=0.05)
+ 		checkEquals(predict[3,2,2], 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.212   0.039   0.234 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcPredictionLOOCV.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function() {
+ 
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 	T_ &lt;&lt;- 3
+ 
+ 	T_nw &lt;&lt;- matrix(c(0,1,0,
+ 										0,0,1,
+ 										0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;&lt;- c(0,1,1,
+ 					1,0,1,
+ 					1,1,0,
+ 					1,1,1)
+ 
+ 	obs_mat &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											 0.56, 0.56, 0.95, 0.95,
+ 											 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;&lt;- c(0.76, 0.76, 0)
+ 			
+ 	mu_types &lt;&lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 
+ 	mu_list &lt;&lt;- list()
+ 	mu_list[[1]] &lt;&lt;- list()
+ 	mu_list[[2]] &lt;&lt;- list()
+ 	mu_list[[3]] &lt;&lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;&lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;&lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;&lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;&lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;&lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;&lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 2
+ 	rem_k &lt;- 4
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		## calculate mean squared error of predicted and observed
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_mat, delta=delta, b=b, n=n ,K=K, adja=T_nw, baseline=baseline, 
+ 																	 rem_gene=rem_gene, rem_k=rem_k, active_mu=active_mu, active_sd=active_sd,
+ 																	 inactive_mu=inactive_mu, inactive_sd=inactive_sd, mu_type=mu_type)
+ 		
+ 		checkEquals(obs_mat[rem_gene, rem_k], predict, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.203   0.028   0.213 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcPredictionLOOCV_timeSeries.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function() {
+ 
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 	T_ &lt;&lt;- 3
+ 
+ 	T_nw &lt;&lt;- matrix(c(0,0,1,
+ 									  0,0,-1,
+ 									  0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;&lt;- c(0,1,1,
+ 					1,0,1,
+ 					1,1,0,
+ 					1,1,1)
+ 
+ 	obs_mat &lt;&lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;&lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.95, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.95, 0.56, 0.95, 0.95,
+ 														0.56, 0.95, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;&lt;- c(0.76, 0.76, 0)
+ 
+ 	mu_types &lt;&lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 
+ 	mu_list &lt;&lt;- list()
+ 	mu_list[[1]] &lt;&lt;- list()
+ 	mu_list[[2]] &lt;&lt;- list()
+ 	mu_list[[3]] &lt;&lt;- list()
+ 	mu_list[[4]] &lt;&lt;- list()
+ 	mu_list[[5]] &lt;&lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;&lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;&lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;&lt;- 0.01
+ 	mu_list[[1]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;&lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;&lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;&lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;&lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;&lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;&lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	mu_list[[4]]$active_mu &lt;&lt;- matrix(rep(0.95, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$active_sd &lt;&lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_mu &lt;&lt;- matrix(rep(0.56, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_sd &lt;&lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$delta &lt;&lt;- matrix(rep(0.755, n*T_), nrow=n, ncol=T_)
+ 
+ 	mu_list[[5]]$active_mu &lt;&lt;- array(rep(0.95, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$active_sd &lt;&lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_mu &lt;&lt;- array(rep(0.56, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_sd &lt;&lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$delta &lt;&lt;- array(rep(0.755, n*K*T_), c(n,K,T_))
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV01 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	baseline &lt;- c(0, 0, 0)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 2
+ 	rem_k &lt;- 4
+ 	rem_t &lt;- 2
+ 	obs_modified[2,4,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		## calculate mean squared error of predicted and observed
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																	 baseline=baseline, rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 		
+ 		checkEquals(predict, 0.56, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV02 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 									 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 2
+ 	rem_k &lt;- 4
+ 	rem_t &lt;- 2
+ 	obs_modified[2,4,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																	 baseline=baseline, rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 		
+ 		checkEquals(predict, 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV03 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.95, 0.56, 0.95, 0.95,
+ 													 0.95, 0.95, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 3
+ 	rem_k &lt;- 4
+ 	rem_t &lt;- 3
+ 	obs_modified[3,4,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																	 baseline=baseline, rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 	checkEquals(predict, 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV04 &lt;- function() {
+ 	
+ 	T_nw &lt;- matrix(c(0,0,1,
+ 									 0,0,-1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 		
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 3
+ 	rem_k &lt;- 4
+ 	rem_t &lt;- 3
+ 	obs_modified[2,4,2] &lt;- NA
+ 	obs_modified[3,4,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta,  b=b, n=n, K=K, adja=T_nw, baseline=baseline, 
+ 																	 rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 		checkTrue(is.na(predict))
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV05 &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 3
+ 	rem_k &lt;- 2
+ 	rem_t &lt;- 3
+ 	obs_modified[2,2,2] &lt;- NA
+ 	obs_modified[3,2,3] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta,  b=b, n=n, K=K, adja=T_nw, baseline=baseline, 
+ 																	 rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 	checkEquals(predict, 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV06 &lt;- function() {
+ 
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 3
+ 	rem_k &lt;- 2
+ 	rem_t &lt;- 2
+ 	obs_modified[2,2,1] &lt;- NA
+ 	obs_modified[3,2,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																	 baseline=baseline, rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 
+ 		checkTrue(is.na(predict))
+ 	}
+ }
&gt; 
&gt; 
&gt; test.runitCalcPredictionLOOCV07 &lt;- function() {
+ 
+ 	baseline &lt;- c(0.76, 0.76, 0.76)
+ 
+ 	obs_modified &lt;- obs_mat
+ 	rem_gene &lt;- 3
+ 	rem_k &lt;- 2
+ 	rem_t &lt;- 2
+ 	obs_modified[2,2,1] &lt;- NA
+ 	obs_modified[3,2,2] &lt;- NA
+ 
+ 	rem_entries &lt;- which(is.na(obs_modified), arr.ind=TRUE)
+ 	rem_entries_vec &lt;- which(is.na(obs_modified))
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		predict &lt;- calcPredictionLOOCV(obs=obs_modified, delta=delta, b=b, n=n, K=K, adja=T_nw, 
+ 																	 baseline=baseline, rem_gene=rem_gene, rem_k=rem_k, rem_t=rem_t,
+ 																	 active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 																	 inactive_sd=inactive_sd, mu_type=mu_type, flag_time_series=TRUE)
+ 																								
+ 		checkEquals(predict, 0.95, tolerance=0.05)
+ 	}
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.222   0.031   0.234 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitCalcRangeLambda.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.calcRangeLambda &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09,
+ 									 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.25)
+ 
+ 	
+ 	obs_mat &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											0.56, 0.56, 0.95, 0.95,
+ 											0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta &lt;- rep(0.755, n)
+ 	delta_type &lt;- &quot;perGene&quot;
+ 	
+ 	lambda &lt;- calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; 
&gt; test.calcRangeLambdaPerGeneExp&lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 
+ 									 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 0.30, 0.32, 0.33)
+ 
+ 	
+ 	obs_mat &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											0.56, 0.56, 0.95, 0.95,
+ 											0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta = matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									 0.755, 0.755, 0.96, 0.755,
+ 									 0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 	delta_type &lt;- &quot;perGeneExp&quot;
+ 	
+ 	lambda &lt;- calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; 
&gt; test.calcRangeLambdaTimeSeries &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 
+ 									 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 
+ 									 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 
+ 									 0.50, 0.52, 0.54, 0.56, 0.58, 0.60, 0.62, 0.64, 0.66, 0.68, 
+ 									 0.70, 0.72, 0.74, 0.76, 0.78, 0.80, 0.82, 0.84, 0.86, 0.88, 
+ 									 0.90, 0.92, 0.94, 0.96, 0.98, 1.00, 1.05, 1.09)
+ 	
+ 	obs_mat &lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta &lt;- rep(0.755, n)
+ 	delta_type &lt;- &quot;perGene&quot;
+ 	
+ 	lambda &lt;- calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; test.calcRangeLambdaTimeSeriesPerGeneExp &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 
+ 									 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 
+ 									 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 
+ 									 0.50, 0.52, 0.54, 0.56, 0.58, 0.60, 0.62, 0.64, 0.66, 0.68, 
+ 									 0.70, 0.72, 0.74, 0.76, 0.78, 0.80, 0.82, 0.84, 0.86, 0.88, 
+ 									 0.90, 0.92, 0.94, 0.96, 0.98, 1.00, 1.05, 1.10, 1.15, 1.20,
+ 									 1.25, 1.28)
+ 	
+ 	obs_mat &lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta = matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									 0.755, 0.755, 0.96, 0.755,
+ 									 0.755, 0.755, 0.96, 0.96), nrow=n, ncol=K, byrow=TRUE)
+ 	delta_type &lt;- &quot;perGeneExp&quot;
+ 	
+ 	lambda &lt;-calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; 
&gt; test.calcRangeLambdaTimeSeriesPerGeneTime &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 
+ 									 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 
+ 									 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 
+ 									 0.50, 0.52, 0.54, 0.56, 0.58, 0.60, 0.62, 0.64, 0.66, 0.68, 
+ 									 0.70, 0.72, 0.74, 0.76, 0.78, 0.80, 0.82, 0.84, 0.86, 0.88, 
+ 									 0.90, 0.92, 0.94, 0.96, 0.98, 1.00, 1.05, 1.10, 1.15, 1.20,
+ 									 1.25)
+ 	
+ 	obs_mat = array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									 0.755, 0.755, 0.96, 0.755,
+ 									 0.755, 0.755, 0.96, 0.755), nrow=n, ncol=T_, byrow=TRUE)
+ 	delta_type &lt;- &quot;perGeneTime&quot;
+ 	
+ 	lambda &lt;- calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; 
&gt; test.calcRangeLambdaTimeSeriesperGeneExpTime &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	true_result &lt;- c(0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 
+ 									 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22, 0.24, 0.26, 0.28, 
+ 									 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 
+ 									 0.50, 0.52, 0.54, 0.56, 0.58, 0.60, 0.62, 0.64, 0.66, 0.68, 
+ 									 0.70, 0.72, 0.74, 0.76, 0.78, 0.80, 0.82, 0.84, 0.86, 0.88, 
+ 									 0.90, 0.92, 0.94, 0.96, 0.98, 1.00, 1.05, 1.10, 1.15, 1.19)
+ 	
+ 	obs_mat &lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta &lt;- array(NA, c(n,K,T_))
+ 	
+ 	delta[,,1] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											  0.755, 0.755, 0.96, 0.755,
+ 											  0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,2] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											  0.755, 0.755, 0.96, 0.755,
+ 											  0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,3] &lt;- matrix(c(0.755, 0.755, 0.755, 0.755, 
+ 											  0.755, 0.755, 0.755, 0.755,
+ 											  0.755, 0.755, 0.755, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,4] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											  0.755, 0.755, 0.96, 0.755,
+ 											  0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 									 
+ 	delta_type &lt;- &quot;perGeneExpTime&quot;
+ 	
+ 	lambda &lt;- calcRangeLambda(obs=obs_mat, delta=delta, delta_type=delta_type, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result, lambda)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.205   0.031   0.220 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitDoILP.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function(){
+ 	
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 	
+ 	T_nw &lt;&lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;&lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 	
+ 	obs_mat &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											0.56, 0.56, 0.95, 0.95,
+ 											0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 											
+ 	lambda &lt;&lt;- 1/10
+ 	annot &lt;&lt;- getEdgeAnnot(n)
+ }
&gt; 
&gt; 
&gt; test.doILPShortExamplePerGene &lt;- function() {
+ 
+ 	true_result_objval &lt;- 13.52785
+ 	true_result_solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 														0.0000000, 0.0000000, 1.9358974,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 1.1411606,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.7550000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.4450526, 0.4450526,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 0.0000000)
+ 	
+ 	delta = rep(0.755, n)
+ 	delta_type &lt;- &quot;perGene&quot;
+ 	
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_=NULL, annot, delta_type, prior=NULL, sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE)
+ 
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; 
&gt; test.doILPShortExamplePerGeneExp &lt;- function() {
+ 
+ 	true_result_objval &lt;- 19.68196
+ 	true_result_solution &lt;- c(0.0000000, 0.0000000, 0.0000000,
+ 													  0.0000000, 0.0000000, 1.9358974,
+ 													  1.9358974, 1.9358974, 0.0000000,
+ 													  0.0000000, 1.1411606, 1.1411606,
+ 													  1.9358974, 0.0000000, 0.0000000,
+ 													  0.0000000, 0.0000000, 0.0000000,
+ 													  0.7550000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.4450526, 0.4450526,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 0.0000000,
+ 														0.0000000, 0.0000000, 0.0000000)
+ 
+ 	delta = matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									 0.755, 0.755, 0.96, 0.755,
+ 									 0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	delta_type &lt;- &quot;perGeneExp&quot;
+ 	
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_=NULL, annot, delta_type, prior=NULL, sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE)
+ 
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.196   0.031   0.212 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitDoILP_timeSeries.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; .setUp &lt;- function() {
+ 
+ 	n &lt;&lt;- 3
+ 	K &lt;&lt;- 4
+ 	T_ &lt;&lt;- 4
+ 	
+ 	T_nw &lt;&lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;&lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 	
+ 	obs_mat &lt;&lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;&lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	obs_mat[,,4] &lt;&lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 														0.56, 0.56, 0.95, 0.95,
+ 														0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 														
+ 	lambda &lt;&lt;- 1/10
+ 	annot &lt;&lt;- getEdgeAnnot(n)
+ }
&gt; 
&gt; 
&gt; test.doILPTimeSeriesShortExamplePerGene &lt;- function() {
+ 	
+ 	true_result_objval &lt;- 2.344474
+ 	true_result_solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.7947368, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.7550000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000,
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000)
+ 	
+ 	delta &lt;- rep(0.755, n)
+ 
+ 	delta_type &lt;- &quot;perGene&quot;
+ 
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_, annot, delta_type, prior=NULL, 
+ 							 sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; 
&gt; test.doILPTimeSeriesShortExamplePerGenePerExp &lt;- function() {
+ 
+ 
+ 	true_result_objval &lt;- 24.99447
+ 	true_result_solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.7947368, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.7550000, 0.0000000, 0.0000000,
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.7550000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.7550000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000, 
+ 													  0.7550000, 0.0000000, 0.0000000, 
+ 													  0.0000000, 0.0000000, 0.0000000)
+ 
+ 	delta &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									  0.755, 0.755, 0.96, 0.755,
+ 									  0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 									 
+ 	delta_type &lt;- &quot;perGeneExp&quot;
+ 	
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_, annot, delta_type, prior=NULL, 
+ 							sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE, flag_time_series=TRUE)
+ 		
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; 
&gt; test.doILPTimeSeriesShortExamplePerGenePerTime &lt;- function() {
+ 
+ 
+ 	true_result_objval &lt;- 109.5545
+ 	true_result_solution &lt;- c(0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.7947368, 0.7947368, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.7550000, 0.7550000, 
+ 														0.0000000, 0.7550000, 0.7550000, 
+ 														0.0000000, 0.0000000, 0.7550000, 
+ 														0.0000000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.7550000, 
+ 														0.0000000, 0.7550000, 0.7550000, 
+ 														0.7550000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.7550000, 
+ 														0.0000000, 0.0000000, 0.7550000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000)
+ 	
+ 	delta &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 									  0.755, 0.755, 0.96, 0.755,
+ 									  0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 									 
+ 	delta_type &lt;- &quot;perGeneTime&quot;
+ 	
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_, annot, delta_type, prior=NULL, 
+ 							 sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE, flag_time_series=TRUE)
+ 	
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; test.doILPTimeSeriesShortExamplePerGenePerExpPerTime &lt;- function() {
+ 
+ 	true_result_objval &lt;- 62.70474
+ 	true_result_solution &lt;- c(0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.7947368, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.0000000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000, 
+ 														0.7550000, 0.7550000, 0.0000000, 
+ 														0.0000000, 0.0000000, 0.0000000)
+ 
+ 	delta &lt;- array(NA, c(n,K,T_))
+ 	
+ 	delta[,,1] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											   0.755, 0.755, 0.96, 0.755,
+ 											   0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,2] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											   0.755, 0.755, 0.96, 0.755,
+ 											   0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,3] &lt;- matrix(c(0.755, 0.755, 0.755, 0.755, 
+ 											   0.755, 0.755, 0.755, 0.755,
+ 											   0.755, 0.755, 0.755, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 											  
+ 	delta[,,4] &lt;- matrix(c(0.755, 0.755, 0.96, 0.755, 
+ 											   0.755, 0.755, 0.96, 0.755,
+ 											   0.755, 0.755, 0.96, 0.755), nrow=n, ncol=K, byrow=TRUE)
+ 									 
+ 	delta_type &lt;- &quot;perGeneExpTime&quot;
+ 	
+ 	res &lt;- doILP(obs_mat, delta, lambda, b, n, K, T_, annot, delta_type, prior=NULL, 
+ 							 sourceNode=NULL, sinkNode=NULL, all.int=FALSE, all.pos=FALSE, flag_time_series=TRUE)
+ 													
+ 	checkEquals(true_result_objval, res$objval, tolerance=0.00001)
+ 	checkEquals(true_result_solution, res$solution, tolerance=0.00001)
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.197   0.041   0.220 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGenerateTimeSeriesNetStates.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.generateTimeSeriesGeneStates &lt;- function() {
+ 	
+ 	n &lt;- 10
+ 	K &lt;- 11
+ 	T_ &lt;- 6
+ 
+ 	true_result &lt;- array(NA, c(n,K,T_))
+ 	
+ 	true_result[ , , 1] &lt;- matrix(c(0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=K, byrow=TRUE)
+ 																	
+ 	true_result[ , , 2] &lt;- matrix(c(0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	1,1,1,0,1,1,1,1,1,1,1,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	1,1,1,1,1,1,1,0,1,1,1,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=K, byrow=TRUE)
+ 																	
+ 	true_result[ , , 3] &lt;- matrix(c(0,1,1,0,1,1,1,1,1,1,1,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	1,1,1,0,1,1,1,1,1,1,1,
+ 																	1,1,1,0,0,1,1,1,1,1,1,
+ 																	1,1,1,1,1,0,1,0,1,1,1,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	1,1,1,1,1,1,1,0,1,1,1,
+ 																	0,0,0,0,0,0,0,0,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=K, byrow=TRUE)
+ 																	
+ 	true_result[ , , 4] &lt;- matrix(c(0,1,1,0,1,1,1,1,1,1,1,
+ 																	1,0,1,1,1,1,1,1,1,1,1,
+ 																	1,1,0,1,1,1,1,1,1,1,1,
+ 																	1,1,1,0,1,1,1,1,1,1,1,
+ 																	1,1,1,0,0,1,1,1,1,1,1,
+ 																	1,1,1,1,1,0,1,0,1,1,1,
+ 																	0,0,0,1,1,0,0,0,0,0,0,
+ 																	1,1,1,1,1,1,1,0,1,1,1,
+ 																	0,0,0,0,0,1,0,1,0,0,0,
+ 																	0,0,0,0,0,0,0,0,0,0,0), nrow=n, ncol=K, byrow=TRUE)
+ 																	
+ 	true_result[ , , 5] &lt;- matrix(c(0,1,1,0,1,1,1,1,1,1,1,
+ 																	1,0,1,1,1,1,1,1,1,1,1,
+ 																	1,1,0,1,1,1,1,1,1,1,1,
+ 																	1,1,1,0,1,1,1,1,1,1,1,
+ 																	1,1,1,1,0,1,1,1,1,1,1,
+ 																	1,1,1,1,1,0,1,1,1,1,1,
+ 																	0,0,0,1,1,0,0,0,0,0,0,
+ 																	1,1,1,1,1,1,1,0,1,1,1,
+ 																	0,0,0,0,0,1,0,1,0,0,0,
+ 																	1,0,1,1,1,1,1,1,1,0,1), nrow=n, ncol=K, byrow=TRUE)
+ 	
+ 	true_result[ , , 6] &lt;- matrix(c(0,1,1,0,1,1,1,1,1,1,1,
+ 																	1,0,1,1,1,1,1,1,1,1,1,
+ 																	1,1,0,1,1,1,1,1,1,1,1,
+ 																	1,1,1,0,1,1,1,1,1,1,1,
+ 																	1,1,1,1,0,1,1,1,1,1,1,
+ 																	1,1,0,1,1,0,1,0,1,1,1,
+ 																	0,0,0,0,1,0,0,0,0,0,0,
+ 																	1,1,1,1,1,1,1,0,1,1,1,
+ 																	0,0,0,0,0,1,0,0,0,0,0,
+ 																	1,0,1,1,1,1,1,1,1,0,1), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	T_nw &lt;- matrix(c(0,0,1,0,0,0,0,0,0,0,
+ 									 0,0,0,0,0,0,0,0,0,1,
+ 									 0,1,0,0,1,1,0,0,0,0,
+ 									 1,0,0,0,1,0,0,0,0,0,
+ 									 0,1,0,0,0,0,-1,0,1,0,
+ 									 0,1,1,0,0,0,1,0,-1,0,
+ 									 0,1,0,0,1,0,0,0,0,0,
+ 									 0,0,0,0,0,1,0,0,0,0,
+ 									 0,0,0,0,0,0,0,0,0,0,
+ 									 0,0,0,0,1,-1,0,0,0,0), nrow=n, ncol=n, byrow=T)
+ 
+ 	b &lt;- c(0,1,1,1,1,1,1,1,1,1,
+ 				 1,0,1,1,1,1,1,1,1,1,
+ 				 1,1,0,1,1,1,1,1,1,1,
+ 				 1,1,1,0,1,1,1,1,1,1,
+ 				 1,1,1,1,0,1,1,1,1,1,
+ 				 1,1,1,1,1,0,1,1,1,1,
+ 				 1,1,1,1,1,1,0,1,1,1,
+ 				 1,1,1,1,1,1,1,0,1,1,
+ 				 1,1,1,1,1,1,1,1,0,1,
+ 				 1,1,1,1,1,1,1,1,1,0,
+ 				 1,1,1,1,1,1,1,1,1,1)
+ 
+ 	
+ 	gene_states &lt;- generateTimeSeriesNetStates(nw_und=T_nw, b=b, n=n, K=K, T_user=NULL)
+ 
+ 	checkEquals(true_result, gene_states$node_state_vec)
+ }
&gt; 
&gt; 
&gt; test.generateTimeSeriesGeneStatesT10 &lt;- function() {
+ 	
+ 	n &lt;- 10
+ 	K &lt;- 11
+ 	T_ &lt;- 6
+ 
+ 	T_nw &lt;- matrix(c(0,0,1,0,0,0,0,0,0,0,
+ 									 0,0,0,0,0,0,0,0,0,1,
+ 									 0,1,0,0,1,1,0,0,0,0,
+ 									 1,0,0,0,1,0,0,0,0,0,
+ 									 0,1,0,0,0,0,-1,0,1,0,
+ 									 0,1,1,0,0,0,1,0,-1,0,
+ 									 0,1,0,0,1,0,0,0,0,0,
+ 									 0,0,0,0,0,1,0,0,0,0,
+ 									 0,0,0,0,0,0,0,0,0,0,
+ 									 0,0,0,0,1,-1,0,0,0,0), nrow=n, ncol=n, byrow=T)
+ 
+ 	b &lt;- c(0,1,1,1,1,1,1,1,1,1,
+ 				 1,0,1,1,1,1,1,1,1,1,
+ 				 1,1,0,1,1,1,1,1,1,1,
+ 				 1,1,1,0,1,1,1,1,1,1,
+ 				 1,1,1,1,0,1,1,1,1,1,
+ 				 1,1,1,1,1,0,1,1,1,1,
+ 				 1,1,1,1,1,1,0,1,1,1,
+ 				 1,1,1,1,1,1,1,0,1,1,
+ 				 1,1,1,1,1,1,1,1,0,1,
+ 				 1,1,1,1,1,1,1,1,1,0,
+ 				 1,1,1,1,1,1,1,1,1,1)
+ 
+ 	
+ 	gene_states &lt;- generateTimeSeriesNetStates(nw_und=T_nw, b=b, n=n, K=K, T_user=10)
+ 	
+ 	checkEquals(10, gene_states$T_)
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.225   0.021   0.229 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetAdja.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getAdja &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, -1.1411606, 
+ 													0, 0.0000000, 1.9358974, 
+ 													0, 0.0000000, 0.000000), nrow=n, ncol=n, byrow=TRUE)
+ 	
+ 	res &lt;- list()
+ 	
+ 	res$solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 										0.0000000, 0.0000000, 1.9358974, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 1.1411606, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.7550000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.4450526, 0.4450526, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000)
+ 	
+ 	res$objective &lt;- c(0, 1, 1, 1, 0, 1, 1, 1, 0, 0,
+ 										 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
+ 										 1, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10)
+ 
+ 	names(res$objective) &lt;- c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, 
+ 														&quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, 
+ 														&quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;, 
+ 														&quot;w-_1_1&quot;, &quot;w-_1_2&quot;, &quot;w-_1_3&quot;, 
+ 														&quot;w-_2_1&quot;, &quot;w-_2_2&quot;, &quot;w-_2_3&quot;, 
+ 														&quot;w-_3_1&quot;, &quot;w-_3_2&quot;, &quot;w-_3_3&quot;, 
+ 														&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;,
+ 														&quot;s_1&quot;, &quot;s_2&quot;, &quot;s_3&quot;, &quot;s_4&quot;, 
+ 														&quot;s_5&quot;, &quot;s_6&quot;, &quot;s_7&quot;, &quot;s_8&quot;,
+ 														&quot;s_9&quot;, &quot;s_10&quot;, &quot;s_11&quot;, &quot;s_12&quot;)
+ 
+ 	adja = getAdja(res, n)
+ 	
+ 	checkEquals(true_result, adja)
+ 	
+ }
&gt; 
&gt; 
&gt; test.getAdjaTimeSeries&lt;- function() {
+ 
+ 	n &lt;- 3
+ 	
+ 	true_result = matrix(c(0, 0.7947368, 0.0000000,
+ 												 0, 0.0000000, 0.7947368,
+ 												 0, 0.0000000, 0.0000000), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	res = list()
+ 	res$solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.7947368, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.7550000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000,
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000)
+ 										
+ 	res$objective &lt;- c(0, 1, 1, 1, 0, 1, 1, 1, 0, 0,
+ 										 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
+ 										 1, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10, 10, 10, 10, 
+ 										 10, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10)
+ 
+ 	names(res$objective) &lt;- c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, 
+ 														&quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, 
+ 														&quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;, 
+ 														&quot;w-_1_1&quot;, &quot;w-_1_2&quot;, &quot;w-_1_3&quot;, 
+ 														&quot;w-_2_1&quot;, &quot;w-_2_2&quot;, &quot;w-_2_3&quot;, 
+ 														&quot;w-_3_1&quot;, &quot;w-_3_2&quot;, &quot;w-_3_3&quot;, 
+ 														&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;,
+ 														&quot;s_1&quot;, &quot;s_2&quot;, &quot;s_3&quot;, &quot;s_4&quot;, 
+ 														&quot;s_5&quot;, &quot;s_6&quot;, &quot;s_7&quot;, &quot;s_8&quot;,
+ 														&quot;s_9&quot;, &quot;s_10&quot;, &quot;s_11&quot;, &quot;s_12&quot;,
+ 														&quot;s_13&quot;, &quot;s_14&quot;, &quot;s_15&quot;, &quot;s_16&quot;,
+ 														&quot;s_17&quot;, &quot;s_18&quot;, &quot;s_19&quot;, &quot;s_20&quot;,
+ 														&quot;s_21&quot;, &quot;s_22&quot;, &quot;s_23&quot;, &quot;s_24&quot;,
+ 														&quot;s_25&quot;, &quot;s_26&quot;, &quot;s_27&quot;, &quot;s_28&quot;,
+ 														&quot;s_29&quot;, &quot;s_30&quot;, &quot;s_31&quot;, &quot;s_32&quot;,
+ 														&quot;s_33&quot;, &quot;s_34&quot;, &quot;s_35&quot;, &quot;s_36&quot;)
+ 														 
+ 	adja = getAdja(res, n)
+ 	
+ 	checkEquals(true_result, adja)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.209   0.034   0.226 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetBaseline.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getBaseline &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result = c(0.7550000, 0.0000000, 0.0000000)
+ 	
+ 	res &lt;- list()
+ 	
+ 	res$solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 										0.0000000, 0.0000000, 1.9358974, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 1.1411606, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.7550000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.4450526, 0.4450526, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000)
+ 	
+ 	res$objective &lt;- c(0, 1, 1, 1, 0, 1, 1, 1, 0, 0,
+ 										 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
+ 										 1, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10)
+ 
+ 	names(res$objective) &lt;- c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, 
+ 														&quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, 
+ 														&quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;, 
+ 														&quot;w-_1_1&quot;, &quot;w-_1_2&quot;, &quot;w-_1_3&quot;, 
+ 														&quot;w-_2_1&quot;, &quot;w-_2_2&quot;, &quot;w-_2_3&quot;, 
+ 														&quot;w-_3_1&quot;, &quot;w-_3_2&quot;, &quot;w-_3_3&quot;, 
+ 														&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;,
+ 														&quot;s_1&quot;, &quot;s_2&quot;, &quot;s_3&quot;, &quot;s_4&quot;, 
+ 														&quot;s_5&quot;, &quot;s_6&quot;, &quot;s_7&quot;, &quot;s_8&quot;,
+ 														&quot;s_9&quot;, &quot;s_10&quot;, &quot;s_11&quot;, &quot;s_12&quot;)
+ 
+ 	adja = getBaseline(res, n)
+ 	
+ 	checkEquals(true_result, adja)
+ 	
+ }
&gt; 
&gt; 
&gt; test.getBaselineTimeSeries&lt;- function() {
+ 
+ 	n &lt;- 3
+ 	
+ 	true_result = c(0.7550000, 0.0000000, 0.0000000)
+ 
+ 	res = list()
+ 	res$solution &lt;- c(0.0000000, 0.7947368, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.7947368, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.7550000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000,
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000, 
+ 										0.0000000, 0.0000000, 0.0000000)
+ 										
+ 	res$objective &lt;- c(0, 1, 1, 1, 0, 1, 1, 1, 0, 0,
+ 										 1, 1, 1, 0, 1, 1, 1, 0, 1, 1,
+ 										 1, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10, 10, 10, 10, 
+ 										 10, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10, 10, 10, 10,
+ 										 10, 10, 10, 10, 10)
+ 
+ 	names(res$objective) &lt;- c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, 
+ 														&quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, 
+ 														&quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;, 
+ 														&quot;w-_1_1&quot;, &quot;w-_1_2&quot;, &quot;w-_1_3&quot;, 
+ 														&quot;w-_2_1&quot;, &quot;w-_2_2&quot;, &quot;w-_2_3&quot;, 
+ 														&quot;w-_3_1&quot;, &quot;w-_3_2&quot;, &quot;w-_3_3&quot;, 
+ 														&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;,
+ 														&quot;s_1&quot;, &quot;s_2&quot;, &quot;s_3&quot;, &quot;s_4&quot;, 
+ 														&quot;s_5&quot;, &quot;s_6&quot;, &quot;s_7&quot;, &quot;s_8&quot;,
+ 														&quot;s_9&quot;, &quot;s_10&quot;, &quot;s_11&quot;, &quot;s_12&quot;,
+ 														&quot;s_13&quot;, &quot;s_14&quot;, &quot;s_15&quot;, &quot;s_16&quot;,
+ 														&quot;s_17&quot;, &quot;s_18&quot;, &quot;s_19&quot;, &quot;s_20&quot;,
+ 														&quot;s_21&quot;, &quot;s_22&quot;, &quot;s_23&quot;, &quot;s_24&quot;,
+ 														&quot;s_25&quot;, &quot;s_26&quot;, &quot;s_27&quot;, &quot;s_28&quot;,
+ 														&quot;s_29&quot;, &quot;s_30&quot;, &quot;s_31&quot;, &quot;s_32&quot;,
+ 														&quot;s_33&quot;, &quot;s_34&quot;, &quot;s_35&quot;, &quot;s_36&quot;)
+ 														 
+ 
+ 	adja = getBaseline(res, n)
+ 	
+ 	checkEquals(true_result, adja)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.199   0.043   0.224 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetEdgeAnnot.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getEdgeAnnot &lt;- function() {
+ 	
+ 	true_result = c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, &quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, &quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;,
+ 									&quot;w-_1_1&quot;, &quot;w-_1_2&quot;, &quot;w-_1_3&quot;, &quot;w-_2_1&quot;, &quot;w-_2_2&quot;, &quot;w-_2_3&quot;, &quot;w-_3_1&quot;, &quot;w-_3_2&quot;, &quot;w-_3_3&quot;,
+ 									&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;)
+ 	
+ 	n &lt;- 3
+ 	edge_annot &lt;- getEdgeAnnot(n, allpos=FALSE)
+ 
+ 	checkEquals(true_result, edge_annot)
+ }
&gt; 
&gt; 
&gt; test.getEdgeAnnotAllPos &lt;- function() {
+ 	
+ 	true_result = c(&quot;w+_1_1&quot;, &quot;w+_1_2&quot;, &quot;w+_1_3&quot;, &quot;w+_2_1&quot;, &quot;w+_2_2&quot;, &quot;w+_2_3&quot;, &quot;w+_3_1&quot;, &quot;w+_3_2&quot;, &quot;w+_3_3&quot;,
+ 									&quot;w_1_^_0&quot;, &quot;w_2_^_0&quot;, &quot;w_3_^_0&quot;)
+ 	
+ 	n &lt;- 3
+ 	edge_annot &lt;- getEdgeAnnot(n, allpos=TRUE)
+ 
+ 	checkEquals(true_result, edge_annot)
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.183   0.046   0.210 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetObsMat.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getObsMatMuTypeSingle &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													0.56, 0.56, 0.95, 0.95,
+ 													0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=T)
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 	
+ 	active_mu &lt;- 0.95
+ 	active_sd &lt;- 0.01
+ 	inactive_mu &lt;- 0.56
+ 	inactive_sd &lt;- 0.01
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat, net_states=NULL, active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;single&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(active_sd + inactive_sd))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGene &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													0.4, 0.4, 1.1, 1.1,
+ 													0.2, 0.2, 0.2, 1.3), nrow=n, ncol=K, byrow=T)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 	
+ 	
+ 	active_mu &lt;- c(0.95, 1.1, 1.3)
+ 	active_sd &lt;- rep(0.01, n)
+ 	inactive_mu &lt;- c(0.56, 0.4, 0.2)
+ 	inactive_sd &lt;- rep(0.01, n)
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat, net_states=NULL, active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGene&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGeneExp &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	
+ 	true_result &lt;- matrix(c(1.1, 10.3, 10.5, 10.7,
+ 													2.1, 2.3, 20.5, 20.7,
+ 													3.1, 3.3, 3.5, 30.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	act_mat &lt;- calcActivation(T_nw, b, n, K)
+ 	
+ 	active_mu &lt;- matrix(c(10.1, 20.1, 30.1,
+ 												10.3, 20.3, 30.3,
+ 												10.5, 20.5, 30.5,
+ 												10.7, 20.7, 30.7), nrow=n, ncol=K)
+ 												
+ 	active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	
+ 	inactive_mu &lt;- matrix(c(1.1, 2.1, 3.1,
+ 													1.3, 2.3, 3.3,
+ 													1.5, 2.5, 3.5,
+ 													1.7, 2.7, 3.7), nrow=n, ncol=K)
+ 													
+ 	inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat, net_states=NULL, active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGeneExp&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypeSingle_nodeStates &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+   T_ &lt;- 4
+ 	
+ 	true_result &lt;- array(NA, c(n, K, T_))
+     
+ 	true_result[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 															 0.56, 0.56, 0.56, 0.56,
+ 															 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															 0.56, 0.56, 0.56, 0.56,
+ 															 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=T)
+ 
+ 	true_result[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															 0.56, 0.56, 0.95, 0.95,
+ 															 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=T)
+ 
+ 	true_result[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															 0.56, 0.56, 0.95, 0.95,
+ 															 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=T)
+ 	
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+     net_states &lt;- array(NA, c(n,K,T_))
+     
+     net_states[,,1] &lt;- matrix(c(0,0,0,0,
+                                 0,0,0,0,
+                                 0,0,0,0), nrow=n, ncol=K, byrow=T)
+     
+ 	net_states[,,2] &lt;- matrix(c(0,1,1,1,
+                                 0,0,0,0,
+                                 0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+     net_states[,,3] &lt;- matrix(c(0,1,1,1,
+                                 0,0,1,1,
+                                 0,0,0,0), nrow=n, ncol=K, byrow=T)
+     
+     net_states[,,4] &lt;- matrix(c(0,1,1,1,
+                                 0,0,1,1,
+                                 0,0,0,1), nrow=n, ncol=K, byrow=T)
+                                 
+ 	active_mu &lt;- 0.95
+ 	active_sd &lt;- 0.01
+ 	inactive_mu &lt;- 0.56
+ 	inactive_sd &lt;- 0.01
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat=NULL, net_states, active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;single&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(active_sd + inactive_sd))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGene_nodeStates &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 	
+ 	true_result &lt;- array(NA, c(n,K,T_))
+ 	
+ 	true_result[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 															0.4, 0.4, 0.4, 0.4,
+ 															0.2, 0.2, 0.2, 0.2), nrow=n, ncol=K, byrow=T)
+ 	
+ 	true_result[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															0.4, 0.4, 0.4, 0.4,
+ 															0.2, 0.2, 0.2, 0.2), nrow=n, ncol=K, byrow=T)
+ 	
+ 	true_result[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															0.4, 0.4, 1.1, 1.1,
+ 															0.2, 0.2, 0.2, 0.2), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 															0.4, 0.4, 1.1, 1.1,
+ 															0.2, 0.2, 0.2, 1.3), nrow=n, ncol=K, byrow=T)
+ 	
+     
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+                  
+ 	net_states &lt;- array(NA, c(n,K,T_))
+ 	
+ 	net_states[,,1] &lt;- matrix(c(0,0,0,0,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+     
+ 	net_states[,,2] &lt;- matrix(c(0,1,1,1,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,3] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,4] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,1), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_mu &lt;- c(0.95, 1.1, 1.3)
+ 	active_sd &lt;- rep(0.01, n)
+ 	inactive_mu &lt;- c(0.56, 0.4, 0.2)
+ 	inactive_sd &lt;- rep(0.01, n)
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat=NULL, net_states, active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGene&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGeneExp_nodeStates &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 	
+ 	true_result &lt;- array(NA, c(n,K,T_))
+     
+ 	true_result[,,1] &lt;- matrix(c(1.1, 1.3, 1.5, 1.7,
+ 															2.1, 2.3, 2.5, 2.7,
+ 															3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,2] &lt;- matrix(c(1.1, 10.3, 10.5, 10.7,
+ 															2.1, 2.3, 2.5, 2.7,
+ 															3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,3] &lt;- matrix(c(1.1, 10.3, 10.5, 10.7,
+ 															2.1, 2.3, 20.5, 20.7,
+ 															3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,4] &lt;- matrix(c(1.1, 10.3, 10.5, 10.7,
+ 															2.1, 2.3, 20.5, 20.7,
+ 															3.1, 3.3, 3.5, 30.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 									 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	net_states &lt;- array(NA, c(n,K,T_))
+     
+ 	net_states[,,1] &lt;- matrix(c(0,0,0,0,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+     
+ 	net_states[,,2] &lt;- matrix(c(0,1,1,1,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,3] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,4] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,1), nrow=n, ncol=K, byrow=T)
+ 	
+ 	
+ 	active_mu &lt;- matrix(c(10.1, 10.3, 10.5, 10.7,
+                          20.1, 20.3, 20.5, 20.7,
+                          30.1, 30.3, 30.5, 30.7), nrow=n, ncol=K, byrow=T)
+                          
+ 	active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	
+ 	inactive_mu &lt;- matrix(c(1.1, 1.3, 1.5, 1.7,
+ 													 2.1, 2.3, 2.5, 2.7,
+ 													 3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat=NULL, net_states,  active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGeneExp&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGeneTime_nodeStates &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 	
+ 	true_result &lt;- array(NA, c(n,K,T_))
+     
+ 	true_result[,,1] &lt;- matrix(c(1.1, 1.1, 1.1, 1.1,
+ 															2.1, 2.1, 2.1, 2.1,
+ 															3.1, 3.1, 3.1, 3.1), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,2] &lt;- matrix(c(1.3, 10.3, 10.3, 10.3,
+ 															2.1, 2.3, 2.3, 2.3,
+ 															3.3, 3.3, 3.3, 3.3), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,3] &lt;- matrix(c(1.5, 10.5, 10.5, 10.5,
+ 															2.5, 2.5, 20.5, 20.5,
+ 															3.5, 3.5, 3.5, 3.5), nrow=n, ncol=K, byrow=T)
+ 															
+ 	true_result[,,4] &lt;- matrix(c(1.7, 10.7, 10.7, 10.7,
+ 															2.7, 2.7, 20.7, 20.7,
+ 															3.7, 3.7, 3.7, 30.7), nrow=n, ncol=K, byrow=T)
+ 																
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 									 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	net_states &lt;- array(NA, c(n,K,T_))
+     
+ 	net_states[,,1] &lt;- matrix(c(0,0,0,0,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+     
+ 	net_states[,,2] &lt;- matrix(c(0,1,1,1,
+                                 0,0,0,0,
+                                 0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,3] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,4] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,1), nrow=n, ncol=K, byrow=T)
+ 	
+ 	
+ 	active_mu &lt;- matrix(c(10.1, 10.3, 10.5, 10.7,
+ 												20.1, 20.3, 20.5, 20.7,
+ 												30.1, 30.3, 30.5, 30.7), nrow=n, ncol=T_, byrow=T)
+ 
+ 	active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=T_)
+ 	
+ 	inactive_mu &lt;- matrix(c(1.1, 1.3, 1.5, 1.7,
+ 													2.1, 2.3, 2.5, 2.7,
+ 													3.1, 3.3, 3.5, 3.7), nrow=n, ncol=T_, byrow=T)
+ 
+ 	inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=T_)
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat=NULL, net_states,  active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGeneTime&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; 
&gt; test.getObsMatMuTypePerGeneExpTime_nodeStates &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 	
+ 	true_result &lt;- array(NA, c(n,K,T_))
+     
+ 	true_result[,,1] &lt;- matrix(c(1.1, 1.3, 1.5, 1.7,
+ 															 1.1, 1.3, 1.5, 1.7,
+ 															 1.1, 1.3, 1.5, 1.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	true_result[,,2] &lt;- matrix(c(2.1, 20.3, 20.5, 20.7,                                 
+ 															2.1, 2.3, 2.5, 2.7,
+ 															2.1, 2.3, 2.5, 2.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	true_result[,,3] &lt;- matrix(c(3.1, 30.3, 30.5, 30.7,                                 
+ 															3.1, 3.3, 30.5, 30.7,
+ 															3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	true_result[,,4] &lt;- matrix(c(4.1, 40.3, 40.5, 40.7,                                 
+ 															4.1, 4.3, 40.5, 40.7,
+ 															4.1, 4.3, 4.5, 40.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	net_states &lt;- array(NA, c(n,K,T_))
+ 	
+ 	net_states[,,1] &lt;- matrix(c(0,0,0,0,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,2] &lt;- matrix(c(0,1,1,1,
+ 															0,0,0,0,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 
+ 	net_states[,,3] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,0), nrow=n, ncol=K, byrow=T)
+ 	
+ 	net_states[,,4] &lt;- matrix(c(0,1,1,1,
+ 															0,0,1,1,
+ 															0,0,0,1), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_mu &lt;- array(NA, c(n,K,T_))
+ 	
+ 	active_mu[,,1] &lt;- matrix(c(10.1, 10.3, 10.5, 10.7,
+ 															 10.1, 10.3, 10.5, 10.7,
+ 															 10.1, 10.3, 10.5, 10.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_mu[,,2] &lt;- matrix(c(20.1, 20.3, 20.5, 20.7,                                 
+ 															20.1, 20.3, 20.5, 20.7,
+ 															20.1, 20.3, 20.5, 20.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_mu[,,3] &lt;- matrix(c(30.1, 30.3, 30.5, 30.7,                                 
+ 															30.1, 30.3, 30.5, 30.7,
+ 															30.1, 30.3, 30.5, 30.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_mu[,,4] &lt;- matrix(c(40.1, 40.3, 40.5, 40.7,                                 
+ 															40.1, 40.3, 40.5, 40.7,
+ 															40.1, 40.3, 40.5, 40.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	active_sd &lt;-  array(0.01, c(n,K,T_))
+ 
+ 	inactive_mu &lt;- array(NA, c(n,K,T_))
+ 	inactive_mu[,,1] &lt;- matrix(c(1.1, 1.3, 1.5, 1.7,
+ 															 1.1, 1.3, 1.5, 1.7,
+ 															 1.1, 1.3, 1.5, 1.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	inactive_mu[,,2] &lt;- matrix(c(2.1, 2.3, 2.5, 2.7,
+ 															 2.1, 2.3, 2.5, 2.7,
+ 															 2.1, 2.3, 2.5, 2.7), nrow=n, ncol=K, byrow=T)
+ 	
+ 	inactive_mu[,,3] &lt;- matrix(c(3.1, 3.3, 3.5, 3.7,
+ 															 3.1, 3.3, 3.5, 3.7,
+ 															 3.1, 3.3, 3.5, 3.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	inactive_mu[,,4] &lt;- matrix(c(4.1, 4.3, 4.5, 4.7,
+ 															 4.1, 4.3, 4.5, 4.7,
+ 															 4.1, 4.3, 4.5, 4.7), nrow=n, ncol=K, byrow=T)
+ 
+ 	inactive_sd &lt;- array(0.01, c(n,K,T_))
+ 	
+ 	obs_mat &lt;- getObsMat(act_mat=NULL, net_states,  active_mu, active_sd, inactive_mu, inactive_sd, mu_type=&quot;perGeneExpTime&quot;)
+ 	checkEquals(true_result, obs_mat, tolerance=(max(active_sd) + max(inactive_sd)))
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.231   0.027   0.241 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetSampleAdja.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getSampleAdja &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	annot &lt;- getEdgeAnnot(n)
+ 	annot_node = seq(1,n)
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, -0.3973684, 
+ 													0, 0.0000000, 0.7947368, 
+ 													0, 0.0000000, 0.0000000), nrow=n, ncol=n, byrow=TRUE)
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;- annot_node
+ 	
+ 	edges_all &lt;- matrix(c(0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												0.0000000, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.0000000, -1.1411606, 0, 1.9358974, 0, 1.3482143,
+ 												0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												0.7947368, 0.0000000, 0, 0.7947368, 0, 0.0000000,
+ 												0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												-0.5534774, -1.1411606, 0, 1.9358974, 0, 1.3482143,
+ 												0.7947368, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.7947368, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.3262604, -0.7947368, 0, 0.7947368, 0, 0.7947368,
+ 												1.9358974, 0.0000000, 0, -1.3482143, 0, -1.9358974,
+ 												1.9358974, 0.0000000, 0, 0.0000000, 0, -1.9358974), nrow=n*K, ncol=n*(n-1), byrow=TRUE)
+ 
+ 	colnames(edges_all) &lt;- c(&quot;1-&gt;2&quot;, &quot;1-&gt;3&quot;, &quot;2-&gt;1&quot;, &quot;2-&gt;3&quot;, &quot;3-&gt;1&quot;, &quot;3-&gt;2&quot;)
+ 
+ 	sampleAdja = getSampleAdja(edges_all, n, annot_node, method=median, septype=&quot;-&gt;&quot;) 
+ 
+ 	checkEquals(true_result, sampleAdja, tolerance=0.00001)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.214   0.035   0.230 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitGetSampleAdjaMAD.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.getSampleAdjaMAD &lt;- function() {
+ 	
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	annot &lt;- getEdgeAnnot(n)
+ 	annot_node = seq(1,n)
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, 0.0000000, 
+ 													0, 0.0000000, 0.0000000, 
+ 													0, 0.0000000, 0.0000000), nrow=n, ncol=n, byrow=TRUE)
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;- annot_node
+ 	
+ 	edges_all &lt;- matrix(c(0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												0.0000000, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.0000000, -1.1411606, 0, 1.9358974, 0, 1.3482143,
+ 												0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												0.7947368, 0.0000000, 0, 0.7947368, 0, 0.0000000,
+ 												0.7947368, 0.7947368, 0, 0.0000000, 0, 0.0000000,
+ 												-0.5534774, -1.1411606, 0, 1.9358974, 0, 1.3482143,
+ 												0.7947368, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.7947368, -1.1411606, 0, 1.9358974, 0, 0.0000000,
+ 												0.3262604, -0.7947368, 0, 0.7947368, 0, 0.7947368,
+ 												1.9358974, 0.0000000, 0, -1.3482143, 0, -1.9358974,
+ 												1.9358974, 0.0000000, 0, 0.0000000, 0, -1.9358974), nrow=n*K, ncol=n*(n-1), byrow=TRUE)
+ 	
+ 	colnames(edges_all) &lt;- c(&quot;1-&gt;2&quot;, &quot;1-&gt;3&quot;, &quot;2-&gt;1&quot;, &quot;2-&gt;3&quot;, &quot;3-&gt;1&quot;, &quot;3-&gt;2&quot;)
+ 	
+ 	sampleAdjaMAD = getSampleAdjaMAD(edges_all, n, annot_node, method=median, method2=mad, septype=&quot;-&gt;&quot;)
+ 
+ 	checkEquals(true_result, sampleAdjaMAD, tolerance=0.00001)
+ }
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.209   0.029   0.220 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitKfoldCV.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.runitKfoldCV &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	obs_mat &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											0.56, 0.56, 0.95, 0.95,
+ 											0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;- c(0.76,0.76,0)
+ 		
+ 	mu_types &lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 	delta_types &lt;- c(&quot;perGene&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 
+ 	mu_list &lt;- list()
+ 	mu_list[[1]] &lt;- list()
+ 	mu_list[[2]] &lt;- list()
+ 	mu_list[[3]] &lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;- 0.01
+ 	mu_list[[1]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	kfold &lt;- 10
+ 	lambda &lt;- 1/10
+ 	annot &lt;- getEdgeAnnot(n)
+ 	annot_node &lt;- seq(1,n)
+ 
+ 	true_result &lt;- list()
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, -0.5, 
+ 													0, 0.0000000, 1.0, 
+ 													0, 0.0000000, 0.000000), nrow=n, ncol=n, byrow=TRUE)
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;- seq(1,n)
+ 	
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		delta_type &lt;- delta_types[i]
+ 		
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		res &lt;- kfoldCV(kfold=kfold, times=1, delta=delta, lambda=lambda, obs=obs_mat, b=b, n=n, K=K, T_=NULL, annot=annot,
+ 									 annot_node=annot_node, active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu, 
+ 									 inactive_sd=inactive_sd, mu_type=mu_type, delta_type=delta_type, prior=NULL, sourceNode=NULL, 
+ 									 sinkNode=NULL, allint=FALSE, allpos=FALSE)
+ 
+ 		adja &lt;- getSampleAdja(res$edges_all, n, annot_node, method=median, septype=&quot;-&gt;&quot;)
+ 
+ 		checkEquals(true_result, adja, tolerance=0.6)
+ 	}
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.213   0.018   0.214 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitKfoldCV_timeSeries.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.runitKfoldCV_timeSeries &lt;- function() {
+ 	
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	obs_mat &lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.56, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 													
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.56, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;- c(0.76,0.76,0)
+ 		
+ 	mu_types &lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 	delta_types &lt;- c(&quot;perGene&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 
+ 	mu_list &lt;- list()
+ 	mu_list[[1]] &lt;- list()
+ 	mu_list[[2]] &lt;- list()
+ 	mu_list[[3]] &lt;- list()
+ 	mu_list[[4]] &lt;- list()
+ 	mu_list[[5]] &lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;- 0.01
+ 	mu_list[[1]]$delta &lt;- rep(0.755, n)
+ 
+ 
+ 	mu_list[[2]]$active_mu &lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	mu_list[[4]]$active_mu &lt;- matrix(rep(0.95, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$active_sd &lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_mu &lt;- matrix(rep(0.56, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_sd &lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$delta &lt;- matrix(rep(0.755, n*T_), nrow=n, ncol=T_)
+ 
+ 	mu_list[[5]]$active_mu &lt;- array(rep(0.95, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$active_sd &lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_mu &lt;- array(rep(0.56, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_sd &lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$delta &lt;- array(rep(0.755, n*K*T_), c(n,K,T_))
+ 
+ 	kfold &lt;- 10
+ 	lambda &lt;- 1/10
+ 	annot &lt;-  getEdgeAnnot(n)
+ 	annot_node &lt;- seq(1,n)
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, 0.0000000, 
+ 													0, 0.0000000, 0.7947368, 
+ 													0, 0.0000000, 0.0000000), nrow=n, ncol=n, byrow=TRUE)
+ 													
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;-  seq(1,n)
+ 
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		delta_type &lt;- delta_types[i]
+ 		
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 
+ 		res &lt;- kfoldCV(kfold=kfold, times=1, obs=obs_mat, delta=delta, lambda=lambda, b=b, n=n, K=K, T_=T_, annot=annot,
+ 									 annot_node=annot_node, active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 									 inactive_sd=inactive_sd, mu_type=mu_type, delta_type=delta_type, prior=NULL, sourceNode=NULL, 
+ 									 sinkNode=NULL, allint=FALSE, allpos=FALSE, flag_time_series=TRUE)
+ 
+ 		adja &lt;- getSampleAdjaMAD(res$edges_all, n, annot_node, method=median, method2=mad, septype=&quot;-&gt;&quot;)
+ 		checkEquals(true_result, adja, tolerance=0.00001)
+ 	}
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.208   0.039   0.232 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitLOOCV.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.runitLOOCV &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	obs_mat &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 											0.56, 0.56, 0.95, 0.95,
+ 											0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;- c(0.76,0.76,0)
+ 		
+ 	mu_types &lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 	delta_types &lt;- c(&quot;perGene&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;)
+ 
+ 	mu_list &lt;- list()
+ 	mu_list[[1]] &lt;- list()
+ 	mu_list[[2]] &lt;- list()
+ 	mu_list[[3]] &lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;- 0.01
+ 	mu_list[[1]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[2]]$active_mu &lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	kfold &lt;- 10
+ 	lambda &lt;- 1/10
+ 	annot &lt;-  getEdgeAnnot(n)
+ 	annot_node &lt;- seq(1,n)
+ 
+ 	true_result &lt;- list()
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, -0.3973684, 
+ 													0, 0.0000000, 0.7947368, 
+ 													0, 0.0000000, 0.000000), nrow=n, ncol=n, byrow=TRUE)
+ 													
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;- seq(1,n)
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		delta_type &lt;- delta_types[i]
+ 		
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		res &lt;- loocv(kfold=NULL, times=1, obs=obs_mat, delta=delta, lambda=lambda, b=b, n=n, K=K, T_=NULL, annot=annot,
+ 								 annot_node=annot_node, active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 								 inactive_sd=inactive_sd, mu_type=mu_type, delta_type=delta_type, prior=NULL, sourceNode=NULL,
+ 								 sinkNode=NULL, allint=FALSE, allpos=FALSE)
+ 
+ 		adja &lt;- getSampleAdja(res$edges_all, n, annot_node, method=median, septype=&quot;-&gt;&quot;)
+ 
+ 		checkEquals(true_result, adja, tolerance=0.00001)
+ 	}
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.213   0.019   0.215 
</PRE>
</DIV><P><SPAN class="filename">lpNet.Rcheck/tests/runitLOOCV_timeSeries.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R version 4.3.0 (2023-04-21) -- &quot;Already Tomorrow&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; test.runitLOOCV_timeSeries &lt;- function() {
+ 
+ 	n &lt;- 3
+ 	K &lt;- 4
+ 	T_ &lt;- 4
+ 
+ 	T_nw &lt;- matrix(c(0,1,0,
+ 									 0,0,1,
+ 									 0,0,0), nrow=n, ncol=n, byrow=TRUE)
+ 
+ 	b &lt;- c(0,1,1,
+ 				 1,0,1,
+ 				 1,1,0,
+ 				 1,1,1)
+ 
+ 	obs_mat &lt;- array(NA, c(n,K,T_))
+ 
+ 	obs_mat[,,1] &lt;- matrix(c(0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,2] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													0.56, 0.56, 0.56, 0.56,
+ 													0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	obs_mat[,,3] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.56, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.56), nrow=n, ncol=K, byrow=TRUE)
+ 													
+ 	obs_mat[,,4] &lt;- matrix(c(0.56, 0.95, 0.95, 0.95,
+ 													 0.56, 0.56, 0.95, 0.95,
+ 													 0.56, 0.56, 0.56, 0.95), nrow=n, ncol=K, byrow=TRUE)
+ 
+ 	baseline &lt;- c(0.76, 0.76, 0)
+ 		
+ 	mu_types &lt;- c(&quot;single&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 	delta_types &lt;- c(&quot;perGene&quot;, &quot;perGene&quot;, &quot;perGeneExp&quot;, &quot;perGeneTime&quot;, &quot;perGeneExpTime&quot;)
+ 
+ 	mu_list &lt;- list()
+ 	mu_list[[1]] &lt;- list()
+ 	mu_list[[2]] &lt;- list()
+ 	mu_list[[3]] &lt;- list()
+ 	mu_list[[4]] &lt;- list()
+ 	mu_list[[5]] &lt;- list()
+ 
+ 	mu_list[[1]]$active_mu &lt;- 0.95
+ 	mu_list[[1]]$active_sd &lt;- 0.01
+ 	mu_list[[1]]$inactive_mu &lt;- 0.56
+ 	mu_list[[1]]$inactive_sd &lt;- 0.01
+ 	mu_list[[1]]$delta &lt;- rep(0.755, n)
+ 
+ 
+ 	mu_list[[2]]$active_mu &lt;- rep(0.95, n)
+ 	mu_list[[2]]$active_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$inactive_mu &lt;- rep(0.56, n)
+ 	mu_list[[2]]$inactive_sd &lt;- rep(0.01, n)
+ 	mu_list[[2]]$delta &lt;- rep(0.755, n)
+ 
+ 	mu_list[[3]]$active_mu &lt;- matrix(rep(0.95, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$active_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_mu &lt;- matrix(rep(0.56, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$inactive_sd &lt;- matrix(rep(0.01, n*K), nrow=n, ncol=K)
+ 	mu_list[[3]]$delta &lt;- matrix(rep(0.755, n*K), nrow=n, ncol=K)
+ 
+ 	mu_list[[4]]$active_mu &lt;- matrix(rep(0.95, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$active_sd &lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_mu &lt;- matrix(rep(0.56, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$inactive_sd &lt;- matrix(rep(0.01, n*T_), nrow=n, ncol=T_)
+ 	mu_list[[4]]$delta &lt;- matrix(rep(0.755, n*T_), nrow=n, ncol=T_)
+ 
+ 	mu_list[[5]]$active_mu &lt;- array(rep(0.95, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$active_sd &lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_mu &lt;- array(rep(0.56, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$inactive_sd &lt;- array(rep(0.01, n*K*T_), c(n,K,T_))
+ 	mu_list[[5]]$delta &lt;- array(rep(0.755, n*K*T_), c(n,K,T_))
+ 
+ 	kfold &lt;- 10
+ 	lambda &lt;- 1/10
+ 	annot &lt;-  getEdgeAnnot(n)
+ 	annot_node &lt;- seq(1,n)
+ 	
+ 	true_result &lt;- matrix(c(0, 0.7947368, 0.0000000, 
+ 													0, 0.0000000, 0.7947368, 
+ 													0, 0.0000000, 0.0000000), nrow=n, ncol=n, byrow=TRUE)
+ 													
+ 	colnames(true_result) &lt;- rownames(true_result) &lt;- seq(1,n)
+ 	
+ 	for (i in 1:length(mu_types)) {
+ 		mu_type &lt;- mu_types[i]
+ 		delta_type &lt;- delta_types[i]
+ 		
+ 		active_mu &lt;- mu_list[[i]]$active_mu
+ 		active_sd &lt;- mu_list[[i]]$active_sd
+ 		inactive_mu &lt;- mu_list[[i]]$inactive_mu
+ 		inactive_sd &lt;- mu_list[[i]]$inactive_sd
+ 		delta &lt;- mu_list[[i]]$delta
+ 		
+ 		res &lt;- loocv(kfold=NULL, times=1, obs=obs_mat, delta=delta, lambda=lambda, b=b, n=n, K=K, T_=T_, annot=annot, 
+ 								 annot_node=annot_node, active_mu=active_mu, active_sd=active_sd, inactive_mu=inactive_mu,
+ 								 inactive_sd=inactive_sd, mu_type=mu_type, delta_type=delta_type, prior=NULL, sourceNode=NULL, 
+ 								 sinkNode=NULL, allint=FALSE, allpos=FALSE, flag_time_series=TRUE)
+ 
+ 		adja &lt;- getSampleAdja(res$edges_all, n, annot_node, method=median, septype=&quot;-&gt;&quot;)
+ 
+ 		checkEquals(true_result, adja, tolerance=0.00001)
+ 	}
+ }
&gt; 
&gt; 
&gt; proc.time()
   user  system elapsed 
  0.226   0.031   0.238 
</PRE>
</DIV><HR>
<H3>Example timings</H3>
<P><SPAN class="filename">lpNet.Rcheck/lpNet-Ex.timings</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<TABLE>
<TR><TD>name</TD><TD style="text-align: right;">user</TD><TD style="text-align: right;">system</TD><TD style="text-align: right;">elapsed
</TD><TR>
<TR><TD>CV</TD><TD style="text-align: right;">0.449</TD><TD style="text-align: right;">0.009</TD><TD style="text-align: right;">0.458</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>calcActivation</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>calcPrediction</TD><TD style="text-align: right;">0.002</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.002</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>calcRangeLambda</TD><TD style="text-align: right;">0.001</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.001</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>doILP</TD><TD style="text-align: right;">0.001</TD><TD style="text-align: right;">0.002</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>generateTimeSeriesNetStates</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>getAdja</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">0.001</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>getBaseline</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>getEdgeAnnot</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>getObsMat</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.004</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>getSampleAdja</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">0.000</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>summarizeRepl</TD><TD style="text-align: right;">0.020</TD><TD style="text-align: right;">0.003</TD><TD style="text-align: right;">0.023</TD><TD style="text-align: right;">
</TD><TR>
</TABLE>
</DIV></BODY>
</HTML>
