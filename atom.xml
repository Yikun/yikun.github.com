<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yikun</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yikun.github.io/"/>
  <updated>2021-08-02T03:29:56.264Z</updated>
  <id>http://yikun.github.io/</id>
  
  <author>
    <name>Yikun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何在上游贡献代码（Github篇）？</title>
    <link href="http://yikun.github.io/2021/04/27/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8A%E6%B8%B8%E8%B4%A1%E7%8C%AE%E4%BB%A3%E7%A0%81%EF%BC%88Github%E7%AF%87%EF%BC%89%EF%BC%9F/"/>
    <id>http://yikun.github.io/2021/04/27/如何在上游贡献代码（Github篇）？/</id>
    <published>2021-04-27T03:37:01.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>写给那些刚接触github和开源贡献的你们。</p><a id="more"></a><h3 id="Github贡献上游代码的基本流程："><a href="#Github贡献上游代码的基本流程：" class="headerlink" title="Github贡献上游代码的基本流程："></a>Github贡献上游代码的基本流程：</h3><h4 id="1-Fork上游分支到你自己的仓库"><a href="#1-Fork上游分支到你自己的仓库" class="headerlink" title="1. Fork上游分支到你自己的仓库"></a>1. Fork上游分支到你自己的仓库</h4><p><img src="https://user-images.githubusercontent.com/1736354/116181400-229d8100-a74d-11eb-9636-d1b68381ee0c.png" alt="image"></p><h4 id="2-克隆代码到本地"><a href="#2-克隆代码到本地" class="headerlink" title="2. 克隆代码到本地"></a>2. 克隆代码到本地</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Yikun/spark.git</span><br></pre></td></tr></table></figure><h4 id="3-新增上游的远程分支"><a href="#3-新增上游的远程分支" class="headerlink" title="3. 新增上游的远程分支"></a>3. 新增上游的远程分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream https://github.com/apache/spark.git</span><br></pre></td></tr></table></figure><p>将apache/spark设置为远端分支，可以通过<code>git branch -vva</code>查看分支情况。</p><h4 id="4-创建开发分支"><a href="#4-创建开发分支" class="headerlink" title="4. 创建开发分支"></a>4. 创建开发分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b SPARK-123456 upstream/master</span><br></pre></td></tr></table></figure><p>在Apache社区，一般以JIRA的issue号作为分支名的标识，例如<code>SPARK-123456</code>代表Spark项目的JIRA为123456的问题。<br>为了方便开发，我们可以基于上游分支<code>upstream/master</code>创建<code>SPARK-123456</code>本地分支。<br>可以通过<code>git branch -vva</code>查看本地分支与远程分支的对应情况。</p><h4 id="5-同步上游代码。"><a href="#5-同步上游代码。" class="headerlink" title="5. 同步上游代码。"></a>5. 同步上游代码。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>因为我们在第3、4步，已经建立了本地分支<code>SPARK-123456</code>和上游分支<code>upstream/master</code>的上下游关系，因此，这里我们只需要利用<code>git pull --rebase</code>即可完成上游分支<code>upstream/master</code>到本地分支<code>SPARK-123456</code>的代码同步。</p><h4 id="6-提交代码到自己的仓库的SPARK-123456"><a href="#6-提交代码到自己的仓库的SPARK-123456" class="headerlink" title="6. 提交代码到自己的仓库的SPARK-123456"></a>6. 提交代码到自己的仓库的SPARK-123456</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin SPARK-123456</span><br></pre></td></tr></table></figure><p>将基于<code>upstream/master</code>(apache/spark)上游远程分支的本地分支<code>SPARK-123456</code>提交到自己仓库(Yikun/spark)的<code>SPARK-123456</code>分支</p><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><h4 id="利用git-alias组合常用命令"><a href="#利用git-alias组合常用命令" class="headerlink" title="利用git alias组合常用命令"></a>利用<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D" target="_blank" rel="noopener">git alias</a>组合常用命令</h4><p>使用<code>vim ~/.gitconfig</code>修改<code>[alias]</code>section.</p><h4 id="1-快速下载PR-git-pr"><a href="#1-快速下载PR-git-pr" class="headerlink" title="1. 快速下载PR git pr"></a>1. 快速下载PR <code>git pr</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pr</span> <span class="string">=</span> <span class="string">"!f() &#123; git fetch -fu $&#123;2:-$(git remote |grep ^upstream || echo origin)&#125; refs/pull/$1/head:pr/$1 &amp;&amp; git checkout pr/$1; &#125;; f"</span></span><br></pre></td></tr></table></figure><p><code>git pr 12</code>: 快速将Pull Request ID为12的代码下载到本地</p><h4 id="2-快速同步上游-git-sync-upstream"><a href="#2-快速同步上游-git-sync-upstream" class="headerlink" title="2. 快速同步上游 git sync-upstream"></a>2. 快速同步上游 <code>git sync-upstream</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">sync-upstream</span> <span class="string">=</span> <span class="string">!"git</span> <span class="string">fetch</span> <span class="string">upstream;git</span> <span class="string">checkout</span> <span class="string">master;git</span> <span class="string">merge</span> <span class="string">upstream/master;git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">master"</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git sync-upstream</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git fetch upstream</span></span><br><span class="line">remote: Enumerating objects: 384, done.</span><br><span class="line">remote: Counting objects: 100% (329/329), done.</span><br><span class="line">remote: Compressing objects: 100% (97/97), done.</span><br><span class="line">remote: Total 384 (delta 187), reused 279 (delta 164), pack-reused 55</span><br><span class="line">Receiving objects: 100% (384/384), 128.90 KiB | 1.42 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (187/187), completed with 110 local objects.</span><br><span class="line">From https://github.com/apache/spark</span><br><span class="line">   c0a3c0cbbe..eb08b9010a  master     -&gt; upstream/master</span><br><span class="line"><span class="meta">#</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch 'master'</span><br><span class="line">Your branch is up to date with 'origin/master'.</span><br><span class="line"><span class="meta">#</span><span class="bash"> git merge upstream/master</span></span><br><span class="line">Updating c0a3c0cbbe..eb08b9010a</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line"><span class="meta">#</span><span class="bash"> git push origin master</span></span><br><span class="line">To github.com:Yikun/spark.git</span><br><span class="line">   c0a3c0cbbe..eb08b9010a  master -&gt; master</span><br></pre></td></tr></table></figure><p><code>git sync-upstream</code>: 同步上游分支的master到自己仓库的master</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写给那些刚接触github和开源贡献的你们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenSource" scheme="http://yikun.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>大文件在Github和Gitee上传的建议</title>
    <link href="http://yikun.github.io/2020/11/24/%E5%A4%A7%E6%96%87%E4%BB%B6%E5%9C%A8Github%E5%92%8CGitee%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
    <id>http://yikun.github.io/2020/11/24/大文件在Github和Gitee上传的建议/</id>
    <published>2020-11-24T03:51:17.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细解释了在github及gitee上对大文件处理的限制以及解决方案。</p><h3 id="Github和Gitee文件大小限制"><a href="#Github和Gitee文件大小限制" class="headerlink" title="Github和Gitee文件大小限制"></a>Github和Gitee文件大小限制</h3><table><thead><tr><th>托管类型</th><th>单文件限制</th><th>单仓库限制</th><th>LFS单文件限制</th><th>LFS单账户限制</th></tr></thead><tbody><tr><td>Github</td><td>100MB</td><td><a href="https://docs.github.com/en/github/managing-large-files/what-is-my-disk-quota#file-and-repository-size-limitations" target="_blank" rel="noopener">建议小于1GB，强烈建议小于5GB</a></td><td><a href="https://docs.github.com/en/github/managing-large-files/about-git-large-file-storage" target="_blank" rel="noopener">2GB</a></td><td><a href="https://docs.github.com/en/github/managing-large-files/about-storage-and-bandwidth-usage" target="_blank" rel="noopener">1GB</a></td></tr><tr><td>Gitee</td><td>50MB</td><td>500MB</td><td><a href="https://gitee.com/help/articles/4283" target="_blank" rel="noopener">仅对企业付费用户开放</a></td><td><a href="https://gitee.com/help/articles/4283" target="_blank" rel="noopener">仅对企业付费用户开放</a></td></tr></tbody></table><p>简单说，如果gitee通过非LFS方式，上传了100MB以上的文件，那么github无法镜像。gitee通过LFS方式，上传了100MB以上的文件，最大不能超过2GB，且总和不能超过1GB。否则会出现<code>this exceeds GitHub&#39;s file size limit of 100.00 MB</code>错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@yikun-x86:~/yikun/bigfile# git push origin main</span><br><span class="line">Enumerating objects: 8, done.</span><br><span class="line">Counting objects: 100% (8/8), done.</span><br><span class="line">Delta compression using up to 4 threads</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 120.25 MiB | 191.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1/1), done.</span><br><span class="line">remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.</span><br><span class="line">remote: error: Trace: 58b4554c41925fcfb5dba5ec99aebb5ef9fab8d092461cb8ed321578a4fa178e</span><br><span class="line">remote: error: See http://git.io/iEPt8g for more information.</span><br><span class="line">remote: error: File boost_1_72_0.tar.gz is 120.72 MB; this exceeds GitHub&apos;s file size limit of 100.00 MB</span><br><span class="line">To github.com:Yikun/bigfile.git</span><br><span class="line"> ! [remote rejected] main -&gt; main (pre-receive hook declined)</span><br><span class="line">error: failed to push some refs to &apos;git@github.com:Yikun/bigfile.git&apos;</span><br></pre></td></tr></table></figure><h2 id="1-如何处理大文件（超过100MB的文件）"><a href="#1-如何处理大文件（超过100MB的文件）" class="headerlink" title="1. 如何处理大文件（超过100MB的文件）"></a>1. 如何处理大文件（超过100MB的文件）</h2><p>任何方案，都需要处理<strong>最近一次</strong>commit（通过删除或者LFS改造）和<strong>历史所有</strong>commits的提交（通过bfg）</p><h3 id="第一步：处理当前大文件（最近一次commit）"><a href="#第一步：处理当前大文件（最近一次commit）" class="headerlink" title="第一步：处理当前大文件（最近一次commit）"></a>第一步：处理当前大文件（<strong>最近一次</strong>commit）</h3><p><img src="https://user-images.githubusercontent.com/1736354/113379819-22f46780-93ad-11eb-82cd-837be2710609.png" alt="image"></p><ol><li><p><strong>找到大文件</strong>。通过<code>git big-files</code>和<code>git blob-find</code>找到所有出现问题的分支。</p></li><li><p><strong>处理大文件</strong>：<br><strong>[推荐] 方案一（删除大文件，并保留历史提交）</strong>：<br>通过自动化下载和脚本的方式，此步完成后，所有的大文件在lastest commit都被清除。<br><strong>方案二（利用LFS改造大文件，并保留历史提交）</strong>：<br>lfs方式改造大文件。在每个分支通过<code>git lfs</code>方式进行改造，此步完成后，所有的大文件在lastest commit都改造为lfs方式。</p></li></ol><h3 id="第二步：处理历史大文件（历史所有commits）"><a href="#第二步：处理历史大文件（历史所有commits）" class="headerlink" title="第二步：处理历史大文件（历史所有commits）"></a>第二步：处理历史大文件（<strong>历史所有</strong>commits）</h3><p><img src="https://user-images.githubusercontent.com/1736354/113379809-1bcd5980-93ad-11eb-836e-6b5599fd0f0f.png" alt="image"></p><p><strong>清除历史大文件</strong>。利用bfg工具，清除所有历史大文件提交记录。（注意：此步会重新提交每个commits，大文件的commit会被替换为xxx.remove的flag文件）</p><a id="more"></a><h2 id="2-详细解释"><a href="#2-详细解释" class="headerlink" title="2. 详细解释"></a>2. 详细解释</h2><h3 id="2-1-如何找到所有大文件的历史提交及大文件对应的分支？"><a href="#2-1-如何找到所有大文件的历史提交及大文件对应的分支？" class="headerlink" title="2.1 如何找到所有大文件的历史提交及大文件对应的分支？"></a>2.1 如何找到所有大文件的历史提交及大文件对应的分支？</h3><p>把下面的配置copy到~/.gitconfig的底部：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[alias]</span></span><br><span class="line">    <span class="string">big-files</span> <span class="string">=</span> <span class="string">!"git</span> <span class="string">rev-list</span> <span class="string">--objects</span> <span class="string">--all</span> <span class="string">\</span></span><br><span class="line">                 <span class="string">|</span> <span class="string">git</span> <span class="string">cat-file</span> <span class="string">--batch-check='%(objecttype)</span> <span class="string">%(objectname)</span> <span class="string">%(objectsize)</span> <span class="string">%(rest)'</span> <span class="string">\</span></span><br><span class="line">                 <span class="string">|</span> <span class="string">sed</span> <span class="string">-n</span> <span class="string">'s/^blob //p'</span> <span class="string">\</span></span><br><span class="line">                 <span class="string">|</span> <span class="string">sort</span> <span class="string">-nk2</span> <span class="string">\</span></span><br><span class="line">                 <span class="string">|</span> <span class="string">cut</span> <span class="string">-c</span> <span class="number">1</span><span class="number">-12</span><span class="string">,41-</span> <span class="string">\</span></span><br><span class="line">                 <span class="string">|</span> <span class="string">$(command</span> <span class="string">-v</span> <span class="string">gnumfmt</span> <span class="string">||</span> <span class="string">echo</span> <span class="string">numfmt)</span> <span class="string">--field=2</span> <span class="string">--to=iec-i</span> <span class="string">--suffix=B</span> <span class="string">--padding=7</span> <span class="string">--round=nearest"</span></span><br><span class="line">    <span class="string">blob-find</span> <span class="string">=</span> <span class="string">"!f() &#123; \</span></span><br><span class="line"><span class="string">        obj_name="</span><span class="string">$1";</span> <span class="string">\</span></span><br><span class="line">        <span class="string">shift;</span> <span class="string">\</span></span><br><span class="line">        <span class="string">git</span> <span class="string">log</span> <span class="string">--pretty=format:'%T</span> <span class="string">%h</span> <span class="string">%s'</span> <span class="string">\</span></span><br><span class="line">        <span class="string">|</span> <span class="string">while</span> <span class="string">read</span> <span class="string">tree</span> <span class="string">commit</span> <span class="string">subject</span> <span class="string">;</span> <span class="string">\</span></span><br><span class="line">        <span class="string">do</span> <span class="string">\</span></span><br><span class="line">            <span class="string">if</span> <span class="string">git</span> <span class="string">ls-tree</span> <span class="string">-r</span> <span class="string">$tree</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-q</span> <span class="string">"$obj_name"</span> <span class="string">;</span> <span class="string">\</span></span><br><span class="line">            <span class="string">then</span> <span class="string">\</span></span><br><span class="line">                <span class="string">echo</span> <span class="string">$commit</span> <span class="string">"$subject"</span><span class="string">;</span> <span class="string">\</span></span><br><span class="line">                <span class="string">git</span> <span class="string">--no-pager</span> <span class="string">branch</span> <span class="string">-a</span> <span class="string">--contains</span> <span class="string">$commit</span> <span class="string">;</span> <span class="string">\</span></span><br><span class="line">            <span class="string">fi;</span> <span class="string">\</span></span><br><span class="line">        <span class="string">done;</span> <span class="string">\</span></span><br><span class="line">        <span class="string">&#125;;</span> <span class="string">f"</span></span><br></pre></td></tr></table></figure></p><ol><li><code>git big-files</code>: 找出所有的大文件blob。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  samples git:(dev) ✗ git big-files | tail -3</span><br><span class="line">41d83dcfd6bb   32MiB mark_detection_video_cpp/for_atlas300_1.3x.0.0/script/maskdetection.om</span><br><span class="line">514c780be5c6   49MiB mark_detection_video_cpp/for_atlas300_1.3x.0.0/script/peppapigdetection.om.bak</span><br><span class="line">96cf9e58c3e4  119MiB c++/level2_simple_inference/2_object_detection/YOLOV3_coco_detection_VENC/model/yolov3.om</span><br></pre></td></tr></table></figure></li></ol><p>可以看到最大的文件的blob hash是<code>96cf9e58c3e4</code>，大小是<code>119MiB</code>，路径为<code>c++/level2_simple_inference/2_object_detection/YOLOV3_coco_detection_VENC/model/yolov3.om</code></p><ol start="2"><li><code>git blob-find</code>: 找到blob所在提交和分支。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  samples git:(dev) ✗ git blob-find 96cf9e58c3e4</span><br><span class="line">4290b1a commit YOLOV3_coco_detection_multi_thread_VENC</span><br><span class="line">* dev</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">59d12cb commit YOLOV3_coco_detection_VENC</span><br><span class="line">* dev</span><br><span class="line">  remotes/origin/dev</span><br></pre></td></tr></table></figure></li></ol><p>可以看到<code>96cf9e58c3e4</code>这个blob，在dev分支的4290b1a、59d12cb这两个commits有提交或者修改。</p><h3 id="2-2-删除大文件。通过lfs方式改造大文件-或者-删除大文件"><a href="#2-2-删除大文件。通过lfs方式改造大文件-或者-删除大文件" class="headerlink" title="2.2 删除大文件。通过lfs方式改造大文件 或者 删除大文件"></a>2.2 删除大文件。通过lfs方式改造大文件 或者 删除大文件</h3><p><strong>方案一：删除大文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file</span><br><span class="line">git add file</span><br><span class="line">git commit</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></p><p><strong>方案二：通过lfs方式改造大文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装git lfs</span><br><span class="line">git lfs install</span><br><span class="line"></span><br><span class="line"># 跟踪大文件</span><br><span class="line">git lfs track &quot;*.psd&quot;</span><br><span class="line">git add .gitattributes</span><br><span class="line"></span><br><span class="line"># 提交大文件</span><br><span class="line">git add file.psd</span><br><span class="line">git commit -m &quot;Add design file&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">https://git-lfs.github.com/</a></p><h3 id="2-3-如何清除所有分支历史的大文件"><a href="#2-3-如何清除所有分支历史的大文件" class="headerlink" title="2.3 如何清除所有分支历史的大文件"></a>2.3 如何清除所有分支历史的大文件</h3><p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/removing-sensitive-data-from-a-repository#using-the-bfg" target="_blank" rel="noopener">https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/removing-sensitive-data-from-a-repository#using-the-bfg</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 注意：这里通过mirror方式clone，最后一步push会影响所有分支。</span><br><span class="line">git clone --mirror git://example.com/some-big-repo.git</span><br><span class="line"></span><br><span class="line">java -jar bfg.jar --strip-blobs-bigger-than 100M some-big-repo.git</span><br><span class="line"></span><br><span class="line">$ cd some-big-repo.git</span><br><span class="line">$ git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive</span><br><span class="line"></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文详细解释了在github及gitee上对大文件处理的限制以及解决方案。&lt;/p&gt;
&lt;h3 id=&quot;Github和Gitee文件大小限制&quot;&gt;&lt;a href=&quot;#Github和Gitee文件大小限制&quot; class=&quot;headerlink&quot; title=&quot;Github和Gitee文件大小限制&quot;&gt;&lt;/a&gt;Github和Gitee文件大小限制&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;托管类型&lt;/th&gt;
&lt;th&gt;单文件限制&lt;/th&gt;
&lt;th&gt;单仓库限制&lt;/th&gt;
&lt;th&gt;LFS单文件限制&lt;/th&gt;
&lt;th&gt;LFS单账户限制&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Github&lt;/td&gt;
&lt;td&gt;100MB&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.github.com/en/github/managing-large-files/what-is-my-disk-quota#file-and-repository-size-limitations&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议小于1GB，强烈建议小于5GB&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.github.com/en/github/managing-large-files/about-git-large-file-storage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2GB&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.github.com/en/github/managing-large-files/about-storage-and-bandwidth-usage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1GB&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gitee&lt;/td&gt;
&lt;td&gt;50MB&lt;/td&gt;
&lt;td&gt;500MB&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://gitee.com/help/articles/4283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仅对企业付费用户开放&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://gitee.com/help/articles/4283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仅对企业付费用户开放&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;简单说，如果gitee通过非LFS方式，上传了100MB以上的文件，那么github无法镜像。gitee通过LFS方式，上传了100MB以上的文件，最大不能超过2GB，且总和不能超过1GB。否则会出现&lt;code&gt;this exceeds GitHub&amp;#39;s file size limit of 100.00 MB&lt;/code&gt;错误：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@yikun-x86:~/yikun/bigfile# git push origin main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enumerating objects: 8, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Counting objects: 100% (8/8), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Delta compression using up to 4 threads&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Compressing objects: 100% (5/5), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writing objects: 100% (6/6), 120.25 MiB | 191.00 KiB/s, done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Total 6 (delta 1), reused 0 (delta 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: Resolving deltas: 100% (1/1), done.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: Trace: 58b4554c41925fcfb5dba5ec99aebb5ef9fab8d092461cb8ed321578a4fa178e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: See http://git.io/iEPt8g for more information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote: error: File boost_1_72_0.tar.gz is 120.72 MB; this exceeds GitHub&amp;apos;s file size limit of 100.00 MB&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;To github.com:Yikun/bigfile.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ! [remote rejected] main -&amp;gt; main (pre-receive hook declined)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error: failed to push some refs to &amp;apos;git@github.com:Yikun/bigfile.git&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;1-如何处理大文件（超过100MB的文件）&quot;&gt;&lt;a href=&quot;#1-如何处理大文件（超过100MB的文件）&quot; class=&quot;headerlink&quot; title=&quot;1. 如何处理大文件（超过100MB的文件）&quot;&gt;&lt;/a&gt;1. 如何处理大文件（超过100MB的文件）&lt;/h2&gt;&lt;p&gt;任何方案，都需要处理&lt;strong&gt;最近一次&lt;/strong&gt;commit（通过删除或者LFS改造）和&lt;strong&gt;历史所有&lt;/strong&gt;commits的提交（通过bfg）&lt;/p&gt;
&lt;h3 id=&quot;第一步：处理当前大文件（最近一次commit）&quot;&gt;&lt;a href=&quot;#第一步：处理当前大文件（最近一次commit）&quot; class=&quot;headerlink&quot; title=&quot;第一步：处理当前大文件（最近一次commit）&quot;&gt;&lt;/a&gt;第一步：处理当前大文件（&lt;strong&gt;最近一次&lt;/strong&gt;commit）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1736354/113379819-22f46780-93ad-11eb-82cd-837be2710609.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;找到大文件&lt;/strong&gt;。通过&lt;code&gt;git big-files&lt;/code&gt;和&lt;code&gt;git blob-find&lt;/code&gt;找到所有出现问题的分支。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;处理大文件&lt;/strong&gt;：&lt;br&gt;&lt;strong&gt;[推荐] 方案一（删除大文件，并保留历史提交）&lt;/strong&gt;：&lt;br&gt;通过自动化下载和脚本的方式，此步完成后，所有的大文件在lastest commit都被清除。&lt;br&gt;&lt;strong&gt;方案二（利用LFS改造大文件，并保留历史提交）&lt;/strong&gt;：&lt;br&gt;lfs方式改造大文件。在每个分支通过&lt;code&gt;git lfs&lt;/code&gt;方式进行改造，此步完成后，所有的大文件在lastest commit都改造为lfs方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第二步：处理历史大文件（历史所有commits）&quot;&gt;&lt;a href=&quot;#第二步：处理历史大文件（历史所有commits）&quot; class=&quot;headerlink&quot; title=&quot;第二步：处理历史大文件（历史所有commits）&quot;&gt;&lt;/a&gt;第二步：处理历史大文件（&lt;strong&gt;历史所有&lt;/strong&gt;commits）&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1736354/113379809-1bcd5980-93ad-11eb-836e-6b5599fd0f0f.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清除历史大文件&lt;/strong&gt;。利用bfg工具，清除所有历史大文件提交记录。（注意：此步会重新提交每个commits，大文件的commit会被替换为xxx.remove的flag文件）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
      <category term="OpenSource" scheme="http://yikun.github.io/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>从数据压缩切入看MapReduce的全流程</title>
    <link href="http://yikun.github.io/2020/08/20/%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%88%87%E5%85%A5%E7%9C%8BMapReduce%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2020/08/20/从数据压缩切入看MapReduce的全流程/</id>
    <published>2020-08-20T13:14:16.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近要在Hadoop中做一些和压缩库相关的优化，也借此机会把Hadoop的MapReduce的全流程代码进行了梳理，本篇文章将端到端的梳理一下MapReduce的全流程，并重点关注其中和数据压缩/解压相关的流程。</p><h3 id="1-起点"><a href="#1-起点" class="headerlink" title="1. 起点"></a>1. 起点</h3><p>为了使整个代码的阅读变得有趣，我们先提几个问题作为后续追寻蛛丝马迹的“导火索”：</p><ol><li><strong>算法支持情况。</strong> Hadoop中，目前支持哪几种数据压缩算法？每个压缩算法有什么特点？性能如何？</li><li><strong>压缩框架实现。</strong> Hadoop中的压缩算法的框架是怎样的？如何增加一个压缩算法？</li><li><strong>压缩与解压的时机。</strong> 在MapReduce的过程中，哪个过程会进行数据压缩和解压？耗时比例大概多少？会带来怎样的利弊？</li><li><strong>压缩性能测试。</strong> 如何进行压缩性能测试？</li></ol><h3 id="2-MapReduce的基本流程"><a href="#2-MapReduce的基本流程" class="headerlink" title="2. MapReduce的基本流程"></a>2. MapReduce的基本流程</h3><p><img src="https://user-images.githubusercontent.com/1736354/95565068-3c49d600-0a52-11eb-9584-bcf1dd6afc47.png" alt="image"></p><p>从上图我们可以看到MapReduce的核心流程如上所示，从用户的Input文件到最终的Output文件，主要经历以下几个阶段：</p><ol><li><p>Map阶段。<br><strong>Split</strong>：会将用户的输入文件，进行一些“分割“，在client端进行，逻辑上进行分割，只记录偏移信息。<br><strong>Map</strong>：Split文件信息会在Map阶段进行处理， 调用用户自己定义的Map函数。<br>环形缓冲区：Map的输出不会直接存在文件里，而是存在环形缓冲区中，攒够了以后再进行落盘。<br><strong>Spill</strong>：从缓冲区落盘的过程叫做spill，也最终会生成多个Spill文件。<br><strong>Map.out</strong>：Spill文件最终会被合并为最终的Map输出。</p></li><li><p>Shuffle阶段。<br>Shuffle阶段会将Map的输出下载到对应的Reduce的机器上。</p></li><li><p>Reduce阶段。<br><strong>Merge</strong>：Reduce阶段最开始的时候，会将Map文件进行Merge，形成一个大文件，作为Reduce的输入。<br><strong>Reduce</strong>：Reduce会执行用户自己定义的reduce函数，完成最终的输出。</p></li></ol><p>更多详细的内容可以参考<a href="https://0x0fff.com/hadoop-mapreduce-comprehensive-description/" target="_blank" rel="noopener">《Hadoop MapReduce Comprehensive Description》</a> [1] 这篇文章。</p><h3 id="3-Hadoop中压缩算法的支持情况"><a href="#3-Hadoop中压缩算法的支持情况" class="headerlink" title="3. Hadoop中压缩算法的支持情况"></a>3. Hadoop中压缩算法的支持情况</h3><p>目前Hadoop支持的压缩算法共有2大类，一种是可分割的压缩算法，一种是不可分割的压缩算法。而支持的压缩算法的类型有：</p><ul><li>Lz4, 压缩速率很快，压缩比一般</li><li>Snappy, 由Google开源的压缩算法，压缩速率和压缩率均衡</li><li>ZSTD，由Facebook开源的压缩算法，压缩速率和压缩率均衡</li><li>Gzip/Zlib，GNU开源，压缩率不错，速度较慢</li><li>Passthrough，直通，仅保存压缩的文件名后缀，实际文件不压缩</li><li>Bzip2，压缩速率较慢，支持流式压缩，可分割</li></ul><p>[1] Hadoop MapReduce Comprehensive Description: <a href="https://0x0fff.com/hadoop-mapreduce-comprehensive-description/" target="_blank" rel="noopener">https://0x0fff.com/hadoop-mapreduce-comprehensive-description/</a></p><h3 id="4-后续"><a href="#4-后续" class="headerlink" title="4.后续"></a>4.后续</h3><p>在2020年9月26日，在Apache Hadoop Meetup上，我也分享了更多的技术细节，以及我们实际的性能测试结果：</p><ul><li>视频：赋能Arm大数据开源生态，华为的探索之路：<a href="https://www.bilibili.com/video/av287309386/" target="_blank" rel="noopener">https://www.bilibili.com/video/av287309386/</a></li><li>总结：Meetup 回顾 | 初探Hadoop on Arm: <a href="https://mp.weixin.qq.com/s/JgbHEqENHuJPZTPtwLZqqQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JgbHEqENHuJPZTPtwLZqqQ</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要在Hadoop中做一些和压缩库相关的优化，也借此机会把Hadoop的MapReduce的全流程代码进行了梳理，本篇文章将端到端的梳理一下MapReduce的全流程，并重点关注其中和数据压缩/解压相关的流程。&lt;/p&gt;
&lt;h3 id=&quot;1-起点&quot;&gt;&lt;a href=&quot;#1-
      
    
    </summary>
    
    
      <category term="大数据" scheme="http://yikun.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>搭建Hadoop Yarn环境 (ARM)</title>
    <link href="http://yikun.github.io/2020/08/15/%E6%90%AD%E5%BB%BAHadoop-Yarn%E7%8E%AF%E5%A2%83-ARM/"/>
    <id>http://yikun.github.io/2020/08/15/搭建Hadoop-Yarn环境-ARM/</id>
    <published>2020-08-15T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>ARM上搭建Hadoop Yarn的指导。</p><a id="more"></a><ol><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yum update -y</span><br><span class="line">yum install -y \</span><br><span class="line">    autoconf \</span><br><span class="line">    automake \</span><br><span class="line">    libtool \</span><br><span class="line">    cmake \</span><br><span class="line">    pkg-config \</span><br><span class="line">    curl \</span><br><span class="line">    sudo \</span><br><span class="line">    git \</span><br><span class="line">    hostname \</span><br><span class="line">    bind-utils \</span><br><span class="line">    openssh-server \</span><br><span class="line">    snappy \</span><br><span class="line">    snappy-devel \</span><br><span class="line">    bzip2 \</span><br><span class="line">    libzip-devel \</span><br><span class="line">    java-1.8.0-openjdk \</span><br><span class="line">    java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure></li><li><p>新增Hadoop用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd hadoop</span><br><span class="line">useradd -m -d /home/hadoop -s /bin/bash hadoop -g hadoop</span><br><span class="line">echo &quot;hadoop ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br></pre></td></tr></table></figure></li><li><p>下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://downloads.apache.org/hadoop/common/hadoop-3.3.0/hadoop-3.3.0-aarch64.tar.gz | tar zx</span><br></pre></td></tr></table></figure></li><li><p>环境变量准备</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.265.b01-6.oe1.aarch64</span><br><span class="line">export HADOOP_HOME=/home/hadoop/hadoop-3.3.0</span><br></pre></td></tr></table></figure></li><li><p>配置添加<br>cd $HADOOP_HOME/etc/hadoop/<br>core-site.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><p>hdfs-site.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.name.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/dfs/name&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.data.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/home/hadoop/dfs/data&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>mapred-site.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--Deploy Hadoop on K8s, we need to specify a certain port range and expose by k8s Service--&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.app.mapreduce.am.job.client.port-range&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;60000-60010&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.app.mapreduce.am.webapp.port-range&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;60011-60020&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.application.classpath&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/*:$HADOOP_MAPRED_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;mapreduce.map.output.compress&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">      &lt;name&gt;mapreduce.map.output.compress.codec&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;org.apache.hadoop.io.compress.ZStandardCodec&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>yarn-site.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.address&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;0.0.0.0:40555&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><ol start="6"><li>启动服务<br>先格式化hdfs<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure></li></ol><p>启动所有服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ARM上搭建Hadoop Yarn的指导。&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="http://yikun.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="ARM" scheme="http://yikun.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>让压缩库ZSTD在ARM上更顺滑</title>
    <link href="http://yikun.github.io/2020/05/20/%E8%AE%A9%E5%8E%8B%E7%BC%A9%E5%BA%93ZSTD%E5%9C%A8ARM%E4%B8%8A%E6%9B%B4%E9%A1%BA%E6%BB%91/"/>
    <id>http://yikun.github.io/2020/05/20/让压缩库ZSTD在ARM上更顺滑/</id>
    <published>2020-05-20T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>Facebook的ZSTD压缩库从1.0版本发布的那天起，就引起了业界的关注，对比业界常用的压缩库lz4、zilib、xz，ZSTD更注重速度和压缩比的均衡，对比zlib来看，更是在保证压缩比的情况下，较zlib压缩性能提升6倍左右，解压性能提升2倍左右。</p><p>我们团队也在2020年年初时，对ZSTD压缩库进行了性能优化，最终优化已推入到Facebook的上游社区中，本文将详细的介绍我们进行的优化。</p><a id="more"></a><h2 id="1-利用neon指令集对数据复制优化。"><a href="#1-利用neon指令集对数据复制优化。" class="headerlink" title="1. 利用neon指令集对数据复制优化。"></a>1. 利用neon指令集对数据复制优化。</h2><p>完整的Patch链接：<a href="https://github.com/facebook/zstd/pull/2041" target="_blank" rel="noopener">facebook/zstd#2041</a></p><h3 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h3><p>aarch64提供了一系列的neon指令，本次优化则利用了VLD和VST指令，借助neon寄存器进行读写加速，<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489c/CJAJIIGG.html" target="_blank" rel="noopener">ARM的官方文档</a>是这样描述这两个指令的：</p><blockquote><p>VLDn and VSTn (single n-element structure to one lane)</p><ul><li>Vector Load single n-element structure to one lane. It loads one n-element structure from memory into one or more NEON registers. Elements of the register that are not loaded are unaltered.</li><li>Vector Store single n-element structure to one lane. It stores one n-element structure into memory from one or more NEON registers.</li></ul></blockquote><p>来自ARM的官方文档<a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/coding-for-neon---part-1-load-and-stores" target="_blank" rel="noopener">Coding for Neon - Part 1: Load and Stores</a>中，写的非常详细，引用一张图来描述neon寄存器和memory加载和存储的方式，核心思想就是：<strong>利用neon寄存器作为暂存的中转站，加速数据处理</strong>：<br><img src="https://user-images.githubusercontent.com/1736354/82516998-bc78a900-9b4e-11ea-8183-1200678566e8.png" alt="image"></p><p>我们以u8的复制为例，总结下本次我们在ZSTD具体的优化实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZSTD_copy8</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __aarch64__</span></span><br><span class="line">    vst1_u8((<span class="keyword">uint8_t</span>*)dst, vld1_u8((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)src));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">memcpy</span>(dst, src, <span class="number">8</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>核心步骤包含两步：</p><ol><li>将src利用vld1加载到neon寄存器。</li><li>使用vst1将neon寄存器的值store到dst的memory中。</li></ol><p>这样便利用neon完成了对u8的memcpy的优化，对于此类优化，有兴趣的可以阅读<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka13544.html" target="_blank" rel="noopener">What is the fastest way to copy memory on a Cortex-A8?</a>，了解在Cortext-A8的架构下，如何快速的进行memory copy。</p><h3 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h3><p>完成neon优化后，我们对压缩和解压缩都进行了测试，最终，在压缩场景获得了大概1+%的提升：</p><table><thead><tr><th>Average gains(level 1~19)</th><th>gcc9.2.0</th><th>clang9.0.0</th></tr></thead><tbody><tr><td>Compression</td><td>1.67%</td><td>1.23%</td></tr><tr><td>Decompression</td><td>0.02%</td><td>0.36%</td></tr></tbody></table><h2 id="2-使用prefetch机制加速数据读取。"><a href="#2-使用prefetch机制加速数据读取。" class="headerlink" title="2. 使用prefetch机制加速数据读取。"></a>2. 使用prefetch机制加速数据读取。</h2><p>完整的Patch链接：<a href="https://github.com/facebook/zstd/pull/2040" target="_blank" rel="noopener">facebook/zstd#2040</a></p><h3 id="优化思路：-1"><a href="#优化思路：-1" class="headerlink" title="优化思路："></a>优化思路：</h3><p>Prefetch的中文是预取，原理是通过将数据预取到cache中，加速数据的访问。一个比较常见的场景就是在循环中，我们可以通过显示的调用，充分的预取未来将会访问的数据或指令便能快速从Cache中加载到处理器内部进行运算或者执行。</p><p>在Jeff Dean的一次经典的talk–<a href="http://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="noopener">Software Engineering Advice from<br>Building Large-Scale Distributed Systems</a>中，提到了cache和memory的速度差异，大致如下图所示：<br><img src="https://user-images.githubusercontent.com/1736354/82518863-dddb9400-9b52-11ea-937c-55766b53f3a1.png" alt="image"></p><p>可以看到，从cache中拿数据，将比直接从memory拿数据性能提升几十甚至上百倍，因此，我们也在本次的优化中，为aarch64加入的<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0802b/PRFM_imm.html" target="_blank" rel="noopener">预取指令</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFETCH_L1(ptr)  __asm__ __volatile__(<span class="meta-string">"prfm pldl1keep, %0"</span> ::<span class="meta-string">"Q"</span>(*(ptr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFETCH_L2(ptr)  __asm__ __volatile__(<span class="meta-string">"prfm pldl2keep, %0"</span> ::<span class="meta-string">"Q"</span>(*(ptr)))</span></span><br></pre></td></tr></table></figure><p>同时，将预取加速加入到了ZSTD_compressBlock_fast_generic和ZSTD_compressBlock_doubleFast_generic的主循环中，在数据访问前，预先先将数据加载到cache中，从而加速后续访问对数据读取。</p><h3 id="性能测试：-1"><a href="#性能测试：-1" class="headerlink" title="性能测试："></a>性能测试：</h3><p>我们仅对压缩进行了优化，因此，也仅对压缩进行了测试，测试结果可以看出，速度在aarch64架构下获得了1.5-3+%的提升：</p><table><thead><tr><th>Average gains(level 1~19)</th><th>gcc9.2.0</th><th>clang9.0.0</th></tr></thead><tbody><tr><td>level 1~2</td><td>3.10%</td><td>3.69%</td></tr><tr><td>level 3~4</td><td>2.49%</td><td>1.51%</td></tr></tbody></table><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>在Facebook的ZSTD中，我们使用了neon指令集对memcpy的过程进行了加速，同时，也利用了prefetch机制，加速了循环时数据的访问。</p><p>希望本篇文章，能够对大家带来一些性能优化的启发。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Facebook的ZSTD压缩库从1.0版本发布的那天起，就引起了业界的关注，对比业界常用的压缩库lz4、zilib、xz，ZSTD更注重速度和压缩比的均衡，对比zlib来看，更是在保证压缩比的情况下，较zlib压缩性能提升6倍左右，解压性能提升2倍左右。&lt;/p&gt;
&lt;p&gt;我们团队也在2020年年初时，对ZSTD压缩库进行了性能优化，最终优化已推入到Facebook的上游社区中，本文将详细的介绍我们进行的优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenSource" scheme="http://yikun.github.io/tags/OpenSource/"/>
    
      <category term="ARM" scheme="http://yikun.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>让Github Action在你自己的机器上跑起来</title>
    <link href="http://yikun.github.io/2020/04/17/%E8%AE%A9Github-Action%E5%9C%A8%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%B7%91%E8%B5%B7%E6%9D%A5/"/>
    <id>http://yikun.github.io/2020/04/17/让Github-Action在你自己的机器上跑起来/</id>
    <published>2020-04-17T09:03:23.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>Github在2019年8月，宣布推出了一项新的功能——<a href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/" target="_blank" rel="noopener">Github Action</a>，让成千上万的开源项目可以利用Github提供的计算资源完成构建、测试、部署等CI/CD，并且提供<a href="https://github.blog/2019-11-05-self-hosted-runners-for-github-actions-is-now-in-beta/" target="_blank" rel="noopener">Self Hosted Runners</a>功能，让开发者们可以将自己的机器接入到Github中来。</p><p>最近，我们利用这一功能，将搭载着<a href="https://openeuler.org/zh/" target="_blank" rel="noopener">openEuler 20.03 (LTS) 操作系统</a>，跑在<a href="http://www.hisilicon.com/en/Products/ProductList/Kunpeng" target="_blank" rel="noopener">Kunpeng 920 处理器</a>的ARM环境接入进来，在近期华为与阿里合作的<a href="https://github.com/kunpengcompute/kunpeng-mpam" target="_blank" rel="noopener">MPAM</a>项目，也将充分的利用这些资源利用Github Action的能力完成构建与测试。</p><p>本篇文章将接入方法分享给大家，希望能够帮助更多同学们把<strong>自己的ARM环境</strong>也在Github上用起来。</p><a id="more"></a><h2 id="1-接入资源"><a href="#1-接入资源" class="headerlink" title="1. 接入资源"></a>1. 接入资源</h2><p><img src="https://user-images.githubusercontent.com/1736354/79320175-f21ce780-7f3b-11ea-8802-d0be06455e70.png" alt="image"><br>资源的接入流程比较简单：</p><ol><li>依次点击项目的<code>Settings</code>–<code>Actions</code>进入资源接入页面，点击<code>Add Runner</code>。</li><li><p>根据弹出的提示，下载和运行脚本<br><img src="https://user-images.githubusercontent.com/1736354/79411221-e8938e00-7fd4-11ea-8e8e-7a1b576c2fa2.png" alt="image"></p></li><li><p>完成后我们可以看到接入的资源：<br><img src="https://user-images.githubusercontent.com/1736354/79411190-d4e82780-7fd4-11ea-952c-06f43dbfa5e2.png" alt="image"></p></li></ol><h2 id="2-使用资源"><a href="#2-使用资源" class="headerlink" title="2. 使用资源"></a>2. 使用资源</h2><p><img src="https://user-images.githubusercontent.com/1736354/79320076-c4d03980-7f3b-11ea-8822-7e724fd8743a.png" alt="image"><br>我们为接入的项目增加一个Action：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Run</span> <span class="string">some</span> <span class="string">script</span> <span class="string">in</span> <span class="string">Kunpeng</span> <span class="string">env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> <span class="string">[</span> <span class="string">master</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">self-hosted</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">`uname</span> <span class="string">-a`</span> <span class="string">in</span> <span class="string">Kunpeng</span> <span class="string">env</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">uname</span> <span class="string">-a</span></span><br><span class="line">        <span class="string">cat</span> <span class="string">/etc/os-release</span></span><br><span class="line">        <span class="string">lscpu</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-E</span> <span class="string">"Architecture|Model name|CPU\(s\):"</span></span><br></pre></td></tr></table></figure></p><p>这样，这个workflow是展示所接入的环境上内核、操作系统、处理器信息，我们可以从结果看到job的结果：<br><img src="https://user-images.githubusercontent.com/1736354/79411452-71122e80-7fd5-11ea-83db-e4f001c5f796.png" alt="image"></p><p>点击<code>Details</code>可以进入详情页面：</p><p><img src="https://user-images.githubusercontent.com/1736354/79414159-7aeb6000-7fdc-11ea-86d5-60dce06abe43.png" alt="image"></p><p>可以看到，我们在资源上执行的指令，已经运行成功，可以看到这台资源的系统为<code>openEuler 20.03 (LTS)</code>，CPU为aarch64 128核的<code>Kunpeng 920</code>。</p><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3.结语"></a>3.结语</h2><p>本文介绍了我们是如何将搭载着鲲鹏920处理器、openEuler操作系统的计算资源接入到Github Action的。可以看到Github Action的自定义资源接入，在ARM64下还是很顺滑的。</p><p>希望这篇文章能够帮助到大家，大家也可以尝试着将你们自己ARM资源接入进来，有问题可以留言一起讨论，玩的开心！：）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Github在2019年8月，宣布推出了一项新的功能——&lt;a href=&quot;https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github Action&lt;/a&gt;，让成千上万的开源项目可以利用Github提供的计算资源完成构建、测试、部署等CI/CD，并且提供&lt;a href=&quot;https://github.blog/2019-11-05-self-hosted-runners-for-github-actions-is-now-in-beta/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Self Hosted Runners&lt;/a&gt;功能，让开发者们可以将自己的机器接入到Github中来。&lt;/p&gt;
&lt;p&gt;最近，我们利用这一功能，将搭载着&lt;a href=&quot;https://openeuler.org/zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;openEuler 20.03 (LTS) 操作系统&lt;/a&gt;，跑在&lt;a href=&quot;http://www.hisilicon.com/en/Products/ProductList/Kunpeng&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kunpeng 920 处理器&lt;/a&gt;的ARM环境接入进来，在近期华为与阿里合作的&lt;a href=&quot;https://github.com/kunpengcompute/kunpeng-mpam&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MPAM&lt;/a&gt;项目，也将充分的利用这些资源利用Github Action的能力完成构建与测试。&lt;/p&gt;
&lt;p&gt;本篇文章将接入方法分享给大家，希望能够帮助更多同学们把&lt;strong&gt;自己的ARM环境&lt;/strong&gt;也在Github上用起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>从Java Math底层实现看Arm与x86的差异</title>
    <link href="http://yikun.github.io/2020/04/10/%E4%BB%8EJava-Math%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%9C%8BArm%E4%B8%8Ex86%E7%9A%84%E5%B7%AE%E5%BC%82/"/>
    <id>http://yikun.github.io/2020/04/10/从Java-Math底层实现看Arm与x86的差异/</id>
    <published>2020-04-10T00:58:09.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起初"><a href="#1-起初" class="headerlink" title="1. 起初"></a>1. 起初</h2><p>最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Math.log(3): "</span> + Math.log(<span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"StrictMath.log(3): "</span> + StrictMath.log(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们发现，在x86下，Math的结果为<code>1.0986122886681098</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> on x86</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Math.log(3): 1.0986122886681098</span><br><span class="line">StrictMath.log(3): 1.0986122886681096</span><br></pre></td></tr></table></figure></p><p>而aarch64的结果为<code>1.0986122886681096</code>。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> on aarch64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Math.log(3): 1.0986122886681096</span><br><span class="line">StrictMath.log(3): 1.0986122886681096</span><br></pre></td></tr></table></figure></p><p>而在Java 8的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html" target="_blank" rel="noopener">官方文档</a>中，对此有明确说明：</p><blockquote><p>Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required.</p></blockquote><p>因此，结论是：<strong>Math的结果有可能是不精确的，如果结果对精度有苛求，那么请使用StrictMath</strong>。</p><p>在此，我们留下2个疑问：</p><ol><li>为什么说Math的实现不是<code>the bit-for-bit same results</code>？</li><li>Math是怎么实现在各个架构下<code>better-performing implementations</code>的？</li></ol><h2 id="2-深度探索一下Math的实现"><a href="#2-深度探索一下Math的实现" class="headerlink" title="2. 深度探索一下Math的实现"></a>2. 深度探索一下Math的实现</h2><p>为了能够更清晰的看到StrictMath的实现，我们深入的看了下JDK的实现。</p><h3 id="2-1-Math和StrictMath的基本实现"><a href="#2-1-Math和StrictMath的基本实现" class="headerlink" title="2.1 Math和StrictMath的基本实现"></a>2.1 Math和StrictMath的基本实现</h3><p>我们从Math.log和StrictMath.log的实现为例，进行深入学习：</p><ol><li><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/classes/java/lang/Math.java#l293" target="_blank" rel="noopener">Math.log的代码</a>表面上很简单，就是直接调用StrictMath.log。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">log</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StrictMath.log(a); <span class="comment">// default impl. delegates to StrictMath</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/classes/java/lang/StrictMath.java#l231" target="_blank" rel="noopener">StrictMath的代码</a>，会调用<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/StrictMath.c#l76" target="_blank" rel="noopener">StrictMath.c</a>中的方法，最终会调用fdlibm的<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/fdlibm/src/e_log.c" target="_blank" rel="noopener">e_log.c</a>的实现。</p></li></ol><p>总体的实现和下图类似：<br><img src="https://user-images.githubusercontent.com/1736354/78893132-569ff880-7a9d-11ea-85dc-4652c9bf85f8.png" alt="image"></p><p>对于StrictMath来说，没有什么黑科技，最终的实现就是e_log.c的ieee754标准实现，是通过C语言实现的，所以在各个平台的表现是一样的，整个流程如图中蓝色部分。感兴趣的同学可以看<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/8f8015daf928/src/share/native/java/lang/fdlibm/src/e_log.c" target="_blank" rel="noopener">e_log.c</a>的源码实现即可。</p><h3 id="2-2-Math的黑科技"><a href="#2-2-Math的黑科技" class="headerlink" title="2.2 Math的黑科技"></a>2.2 Math的黑科技</h3><p>回到我们最初的起点，再加上一个问题：</p><ol><li>为什么说Math的实现不是<code>the bit-for-bit same results</code>？</li><li>Math是怎么实现在各个架构下<code>better-performing implementations</code>的？</li><li>既然Math的实现，也是直接调用StrictMath，为什么结果确不一样呢？</li></ol><p>原来，JVM为了让各个arch的CPU能够充分的发挥自己CPU的优势，会根据架构不同，会通过Hotspot intrinsics替换掉Math函数的实现，我们可以从代码<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/dae2d83e0ec2/src/share/vm/classfile/vmSymbols.hpp#l598" target="_blank" rel="noopener">vmSymbols.hpp</a>看到，Math的很多实现都被替换掉了。log的替换类似于：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_intrinsic(_dlog, java_lang_Math, log_name, double_double_signature, F_S)</span><br></pre></td></tr></table></figure></p><p>最终，Math的调用为下图红色部分：</p><p><img src="https://user-images.githubusercontent.com/1736354/78893234-8f3fd200-7a9d-11ea-903a-311c8c3cc836.png" alt="image"></p><p>log的实现:</p><ul><li><p>在x86下，最终其实调用的是<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/dae2d83e0ec2/src/cpu/x86/vm/assembler_x86.cpp#l4140" target="_blank" rel="noopener">assembler_x86.cpp</a>中的<code>flog</code>实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assembler::flog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fldln2();</span><br><span class="line">  fxch();</span><br><span class="line">  fyl2x();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而在aarch64下，我们可以从<a href="http://hg.openjdk.java.net/jdk/jdk/file/e53ec3b362f4/src/hotspot/cpu/" target="_blank" rel="noopener">src/hotspot/cpu/</a>目录下看到，aarch64并未实现优化版本。因此，实际aarch64调用的就是标准的StrictMath。</p></li></ul><p>正因如此，x86汇编的计算结果的差异导致了x86和aarch64结果在Math.log差异。</p><p>当然，aarch64也在JDK 11中，对部分的Math接口做了加速实现，有兴趣可以看看<a href="https://bugs.openjdk.java.net/browse/JDK-8189104" target="_blank" rel="noopener">JEP 315: Improve Aarch64 Intrinsics</a>的实现。</p><h2 id="3-toRadians的小插曲"><a href="#3-toRadians的小插曲" class="headerlink" title="3. toRadians的小插曲"></a>3. toRadians的小插曲</h2><p>在ARM优化过程中，有的是因为Math库和StrictMath不同的实现造成结果不同，所以我们如果对精度要求非常高，直接切到StrictMath即可。</p><p>但有的函数，由于在Java大版本升级的过程中，出现了一些实现的差异，先看一个简单的Java程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Math.toRadians(0.33): "</span> + Math.toRadians(<span class="number">0.33</span>));</span><br><span class="line">System.out.println(<span class="string">"StrictMath.toRadians(0.33): "</span> + StrictMath.toRadians(<span class="number">0.33</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们分别看看在Java11和Java8的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/jvm/java-11-openjdk-amd64/bin/java Hello</span><br><span class="line">Math.toRadians(0.33): 0.005759586531581287</span><br><span class="line">StrictMath.toRadians(0.33): 0.005759586531581287</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java Hello</span><br><span class="line">Math.toRadians(0.33): 0.005759586531581288</span><br><span class="line">StrictMath.toRadians(0.33): 0.005759586531581288</span><br></pre></td></tr></table></figure><p>最后一位很奇怪的差了1，我们继续深入进去看到toRadians的实现：</p><ul><li><p><a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/Math.java#l236" target="_blank" rel="noopener">Java8的实现</a>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toDegrees</span><span class="params">(<span class="keyword">double</span> angrad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> angrad * <span class="number">180.0</span> / PI;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/Math.java#l253" target="_blank" rel="noopener">Java11的实现</a>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> DEGREES_TO_RADIANS = <span class="number">0.017453292519943295</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">toRadians</span><span class="params">(<span class="keyword">double</span> angdeg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> angdeg * DEGREES_TO_RADIANS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>原来在Java11的实现中，为了优化性能，将<code>* 180.0 / PI</code>提前算好了，这样每次只用乘以乘数即可，从而化简了计算。这也最终导致了，Java8和Java11在精度上有一些差别。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>Math在各个arch下的实现不同，精度也不同，如果对精度要求很高，可以使用StrictMath。</li><li>Java不同版本的优化，也有可能导致Math库的精度不同</li><li>Math库在实现时，利用intrinsics机制，把各个arch下Math的实现换掉了，从而充分的发挥各个CPU自身的优势。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-起初&quot;&gt;&lt;a href=&quot;#1-起初&quot; class=&quot;headerlink&quot; title=&quot;1. 起初&quot;&gt;&lt;/a&gt;1. 起初&lt;/h2&gt;&lt;p&gt;最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Hello&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Math.log(3): &quot;&lt;/span&gt; + Math.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;StrictMath.log(3): &quot;&lt;/span&gt; + StrictMath.log(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Github Action入门指南</title>
    <link href="http://yikun.github.io/2020/02/28/Github-Action%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yikun.github.io/2020/02/28/Github-Action入门指南/</id>
    <published>2020-02-28T06:43:46.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录一下Github Action的从入门到还没放弃的历程。 ：）</p><a id="more"></a><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World"></a>1. Hello World</h2><p>我们可以通过repo的action的指引，快速的完成Github action的测试：<br><img src="https://user-images.githubusercontent.com/1736354/75516372-47a63f00-5a37-11ea-83c5-5520d1586e1b.png" alt="image"><br>点击detail后，我们便可以完成Hello world的测试：<br><img src="https://user-images.githubusercontent.com/1736354/75516468-876d2680-5a37-11ea-80a6-68fc564f96be.png" alt="image"></p><p>可以看到，整个过程非常简单，只需要提交一个位于.github/hello-wrold.yml的文件：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"><span class="comment"># 在push的时候触发这个workflow</span></span><br><span class="line"><span class="attr">on:</span> <span class="string">[push]</span></span><br><span class="line"><span class="comment"># workflow的job内容</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 跑job的系统</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="comment"># 定义需要跑的脚本</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="comment"># 使用checkout action</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="comment"># Hello World</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">a</span> <span class="string">one-line</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">echo</span> <span class="string">Hello,</span> <span class="string">world!</span></span><br><span class="line">    <span class="comment"># 打印多行</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">a</span> <span class="string">multi-line</span> <span class="string">script</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">Add</span> <span class="string">other</span> <span class="string">actions</span> <span class="string">to</span> <span class="string">build,</span></span><br><span class="line">        <span class="string">echo</span> <span class="string">test,</span> <span class="string">and</span> <span class="string">deploy</span> <span class="string">your</span> <span class="string">project.</span></span><br></pre></td></tr></table></figure></p><p>我们可以点击detail进入Workflow的<a href="https://github.com/Yikun/github-action-tutorial/pull/1/checks?check_run_id=474158198" target="_blank" rel="noopener">结果页面</a></p><p><img src="https://user-images.githubusercontent.com/1736354/75517106-e0898a00-5a38-11ea-8635-e1e2067ecc36.png" alt="image"></p><h2 id="2-初识Action"><a href="#2-初识Action" class="headerlink" title="2. 初识Action"></a>2. 初识Action</h2><p>官方的文档介绍的非常详细了，这里推荐一些文章，官方在action的<a href="https://help.github.com/en/actions" target="_blank" rel="noopener">文档主页</a>中推荐了3个文章，这里简单介绍下：</p><ul><li><p><a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions" target="_blank" rel="noopener">About GitHub Actions</a><br>这篇文章主要从从使用者的角度对action进行了简单的介绍，通过这篇文章可以了解到使用Github action的一些注意事项（例如使用限制、通知机制等都在这里有提及）。</p></li><li><p><a href="https://help.github.com/en/actions/configuring-and-managing-workflows/configuring-a-workflow" target="_blank" rel="noopener">Configuring a workflow</a><br>这篇文章可以认为是对workflow的一个详解，并且对workflow中的关键概念进行了解释，把这篇文章读透，基本上Github Action的基础功能就了然于胸了。</p></li><li><p><a href="https://help.github.com/en/actions/building-actions/about-actions" target="_blank" rel="noopener">About actions</a><br>这篇文章可以认为是写给action的开发者的一个入门文档，在你需要写一个action之前，建议通读这篇文章。</p></li></ul><h2 id="3-高级功能"><a href="#3-高级功能" class="headerlink" title="3. 高级功能"></a>3. 高级功能</h2><p>在这节会陆续更新下，我使用到的有用的功能：</p><ol><li>缓存<br><a href="https://github.com/actions/cache" target="_blank" rel="noopener">https://github.com/actions/cache</a> cache插件提供了缓存上一次指定目录的文件的功能，例如缓存依赖包。</li><li>接入自定义机器<br><a href="https://help.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners" target="_blank" rel="noopener">https://help.github.com/en/actions/hosting-your-own-runners/about-self-hosted-runners</a> 当你需要使用自定义机器时（例如对接特殊硬件等需求），可以使用self hosted runners功能。</li><li>使用加密功能<br><a href="https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets" target="_blank" rel="noopener">https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets</a> 当你需要使用一些加密的字符或者秘钥之类时，可以配合Github的secrets进行使用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里记录一下Github Action的从入门到还没放弃的历程。 ：）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>巧用Github Action同步代码到Gitee</title>
    <link href="http://yikun.github.io/2020/01/17/%E5%B7%A7%E7%94%A8Github-Action%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0Gitee/"/>
    <id>http://yikun.github.io/2020/01/17/巧用Github-Action同步代码到Gitee/</id>
    <published>2020-01-17T09:26:56.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>在开源贡献的代码托管的过程中，我们有时候有需要将Github的代码同步到其他远端仓库的需求。具体的，对于我们目前参与的项目来说核心诉求是：<strong>以Github社区作为主仓，并且定期自动同步到Gitee作为镜像仓库</strong>。</p><h3 id="2-调研"><a href="#2-调研" class="headerlink" title="2. 调研"></a>2. 调研</h3><ul><li><p>结论1: 由于会被Github屏蔽，Gitee的自动同步功能暂时无法支持。<br>这个问题在Gitee的官方反馈中，<a href="https://gitee.com/oschina/git-osc/issues/IKH12" target="_blank" rel="noopener">建议github导入的项目能设置定时同步</a>提及过，官方的明确答复是不支持。最近又再次和官方渠道求证，由于会被Github屏蔽的关系，这个功能不会被支持。本着有轮子用轮子，没轮子造轮子的原则，我们只能选择<strong>自己实现</strong>。</p></li><li><p>结论2: 靠手动同步存在时效问题，可能会造成部分commit的丢失。<br>Gitee本身是提供了手动同步功能的，也算比较好用，但是想想看，如果一个组织下面，发展到有几百上千个项目后，这种机制显然无法解决问题了。因此，我们需要<strong>某种计算资源去自动的完成同步</strong>。</p></li><li><p>结论3: 目前我们开源的好几个项目（例如Mindspore, OpenGauss, Kunpeng）都有类似的需求。<br>作为一个合格的程序员，为了守住DRY(don’t repeat yourself，不造重复的轮子)的原则，所以，我们需要实现一个<strong>工具</strong>，同步简单的配置就可以完成多个项目的同步。</p></li></ul><p>最终结论：我们需要<strong>自己实现</strong>一个<strong>工具</strong>，通过<strong>某种计算资源自动的</strong>去完成<strong>周期同步</strong>功能。</p><a id="more"></a><h3 id="3-选型"><a href="#3-选型" class="headerlink" title="3. 选型"></a>3. 选型</h3><p>其实调研结论有了后，我们面对的选型就那么几种：</p><ul><li>使用crontab调用脚本周期性同步。这个计算资源得我们自己维护，太重了。排除！</li><li>使用Travis、OpenLab等CI资源。这些也可以支持，但是和Github的集成性比较差。</li><li>Github Action。无缝的和Github集成，处于对新生技术的新鲜感，还是想试一把的，就选他了！关于Github Action的详细内容可以直接在官网看到：<a href="https://github.com/features/actions" target="_blank" rel="noopener">https://github.com/features/actions</a></li></ul><p>PS：严格来讲，Github Action其实是第二种选择的子集，其实就是单纯的想体验一把，并且把我们的业务需求实现了。</p><h3 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h3><h4 id="4-1-Github-Action的实现"><a href="#4-1-Github-Action的实现" class="headerlink" title="4.1 Github Action的实现"></a>4.1 Github Action的实现</h4><p>Github Action提供了<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/about-actions#types-of-actions" target="_blank" rel="noopener">2种方式</a>去实现Action：</p><ul><li><p>Docker container. 这种方式相当于在Github提供的计算资源起个container，在container里面把功能实现。具体的原理大致如下：<br><img src="https://user-images.githubusercontent.com/1736354/72601545-9482fa00-3950-11ea-849a-6788b7a7df2f.png" alt="image"></p></li><li><p>JavaScript. 这种方式相当于在Github提供的计算资源上，直接用JS脚本去实现功能。</p></li></ul><p>作为以后端开发为主的我们，没太多纠结就选择了第一种类型。关于怎么构建一个Github的Action可以参考Github的官方文档<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/building-actions" target="_blank" rel="noopener">Building actions</a>。官方文档真的写的非常详细了，并且也通了了hello-world级别的入门教程。</p><h4 id="4-1-同步的核心代码实现"><a href="#4-1-同步的核心代码实现" class="headerlink" title="4.1 同步的核心代码实现"></a>4.1 同步的核心代码实现</h4><p>而最终的关键实现就是，我们需要定义这个容器运行的脚本，原理很简单：<br><img src="https://user-images.githubusercontent.com/1736354/72602279-fa23b600-3951-11ea-986e-d48446465a40.png" alt="image"><br>大致就是以上4步：</p><ol><li>通过Github API读取Repo列表。</li><li>下载或者更新Github repo的代码</li><li>设置远端分支</li><li>将最新同步的commit、branch、tag推送到Gitee。</li></ol><p>关心细节的同学，具体可以参考代码：<a href="https://github.com/Yikun/gitee-mirror-action/blob/master/entrypoint.sh" target="_blank" rel="noopener">https://github.com/Yikun/gitee-mirror-action/blob/master/entrypoint.sh</a></p><h3 id="5-怎么用呢？"><a href="#5-怎么用呢？" class="headerlink" title="5. 怎么用呢？"></a>5. 怎么用呢？</h3><p> 举了个简单的例子，我们想将Github/kunpengcompute同步到Gitee/kunpengcompute上面，需要做的非常简单，只需要2步：</p><ol><li>将Gitee的私钥和Token，上传到项目的setting的Secrets中。<br><img src="https://user-images.githubusercontent.com/1736354/72600755-33a6f200-394f-11ea-832d-331c222a0b4e.png" alt="image"></li></ol><p>可以参考<a href="https://help.github.com/en/actions/automating-your-workflow-with-github-actions/creating-and-using-encrypted-secrets#creating-encrypted-secrets" target="_blank" rel="noopener">官方指引</a></p><ol start="2"><li>新建一个Github workflow，在这个workflow里面使用Gitee Mirror Action。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Gitee</span> <span class="string">repos</span> <span class="string">mirror</span> <span class="string">periodic</span> <span class="string">job</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="comment"># 如果需要PR触发把push前的#去掉</span></span><br><span class="line"><span class="comment"># push:</span></span><br><span class="line">  <span class="attr">schedule:</span></span><br><span class="line">    <span class="comment"># 每天北京时间9点跑</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">cron:</span>  <span class="string">'0 1 * * *'</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Mirror</span> <span class="string">the</span> <span class="string">Github</span> <span class="string">organization</span> <span class="string">repos</span> <span class="string">to</span> <span class="string">Gitee.</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">Yikun/gitee-mirror-action@v0.01</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="comment"># 必选，需要同步的Github用户（源）</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">github/Yikun</span></span><br><span class="line">        <span class="comment"># 必选，需要同步到的Gitee的用户（目的）</span></span><br><span class="line">        <span class="attr">dst:</span> <span class="string">gitee/yikunkero</span></span><br><span class="line">        <span class="comment"># 必选，Gitee公钥对应的私钥，https://gitee.com/profile/sshkeys</span></span><br><span class="line">        <span class="attr">dst_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="comment"># 必选，Gitee对应的用于创建仓库的token，https://gitee.com/profile/personal_access_tokens</span></span><br><span class="line">        <span class="attr">dst_token:</span>  <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="comment"># 如果是组织，指定组织即可，默认为用户user</span></span><br><span class="line">        <span class="comment"># account_type: org</span></span><br><span class="line">        <span class="comment"># 还有黑、白名单，静态名单机制，可以用于更新某些指定库</span></span><br><span class="line">        <span class="comment"># static_list: repo_name</span></span><br><span class="line">        <span class="comment"># black_list: 'repo_name,repo_name2'</span></span><br><span class="line">        <span class="comment"># white_list: 'repo_name,repo_name2'</span></span><br></pre></td></tr></table></figure></li></ol><p>可以参考<a href="https://github.com/kunpengcompute/Kunpeng/blob/master/.github/workflows/gitee-repos-mirror.yml" target="_blank" rel="noopener">鲲鹏库的实现</a>。</p><p><img src="https://user-images.githubusercontent.com/1736354/72601756-fa6f8180-3950-11ea-9be2-c6c37210fc3b.png" alt="image"></p><p>上图，大概是每个阶段的原理和最终的效果。现在，这个使用Gitee Mirror Action的workflow已经运行起来了，可以在<a href="https://github.com/kunpengcompute/Kunpeng/actions" target="_blank" rel="noopener">链接</a>看到。</p><h3 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h3><p>好啦，这篇硬核软文就写到这里，有同步需求的同学，放心使用。更多用法，可以参考Hub-mirror-action的主页Readme。</p><p><strong>Github Action 官方链接</strong>：<a href="https://github.com/marketplace/actions/hub-mirror-action" target="_blank" rel="noopener">https://github.com/marketplace/actions/hub-mirror-action</a><br><strong>代码仓库</strong>：<a href="https://github.com/Yikun/hub-mirror-action" target="_blank" rel="noopener">https://github.com/Yikun/hub-mirror-action</a></p><p>有任何问题或者疑问，希望可以和大家一起改进这个Action，有问题可以直接提Issue或者PR，不用客气。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h3&gt;&lt;p&gt;在开源贡献的代码托管的过程中，我们有时候有需要将Github的代码同步到其他远端仓库的需求。具体的，对于我们目前参与的项目来说核心诉求是：&lt;strong&gt;以Github社区作为主仓，并且定期自动同步到Gitee作为镜像仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-调研&quot;&gt;&lt;a href=&quot;#2-调研&quot; class=&quot;headerlink&quot; title=&quot;2. 调研&quot;&gt;&lt;/a&gt;2. 调研&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结论1: 由于会被Github屏蔽，Gitee的自动同步功能暂时无法支持。&lt;br&gt;这个问题在Gitee的官方反馈中，&lt;a href=&quot;https://gitee.com/oschina/git-osc/issues/IKH12&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建议github导入的项目能设置定时同步&lt;/a&gt;提及过，官方的明确答复是不支持。最近又再次和官方渠道求证，由于会被Github屏蔽的关系，这个功能不会被支持。本着有轮子用轮子，没轮子造轮子的原则，我们只能选择&lt;strong&gt;自己实现&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结论2: 靠手动同步存在时效问题，可能会造成部分commit的丢失。&lt;br&gt;Gitee本身是提供了手动同步功能的，也算比较好用，但是想想看，如果一个组织下面，发展到有几百上千个项目后，这种机制显然无法解决问题了。因此，我们需要&lt;strong&gt;某种计算资源去自动的完成同步&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;结论3: 目前我们开源的好几个项目（例如Mindspore, OpenGauss, Kunpeng）都有类似的需求。&lt;br&gt;作为一个合格的程序员，为了守住DRY(don’t repeat yourself，不造重复的轮子)的原则，所以，我们需要实现一个&lt;strong&gt;工具&lt;/strong&gt;，同步简单的配置就可以完成多个项目的同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终结论：我们需要&lt;strong&gt;自己实现&lt;/strong&gt;一个&lt;strong&gt;工具&lt;/strong&gt;，通过&lt;strong&gt;某种计算资源自动的&lt;/strong&gt;去完成&lt;strong&gt;周期同步&lt;/strong&gt;功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>源于鲲鹏，回归社区：GNU Glibc的ARM优化小记</title>
    <link href="http://yikun.github.io/2019/12/30/%E6%BA%90%E4%BA%8E%E9%B2%B2%E9%B9%8F%EF%BC%8C%E5%9B%9E%E5%BD%92%E7%A4%BE%E5%8C%BA%EF%BC%9AGNU-Glibc%E7%9A%84ARM%E4%BC%98%E5%8C%96%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yikun.github.io/2019/12/30/源于鲲鹏，回归社区：GNU-Glibc的ARM优化小记/</id>
    <published>2019-12-30T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>从2019年10月初开始，我们团队开始着手Glibc在aarch64(64)架构下的优化工作，并且在2019年年底，将我们的全部优化贡献给上游开源社区。本文分享我们在Glibc的版本完成的优化以及性能测试结果，同时我们也尝试着将优化的思路进行总结，希望对其他项目的优化提供一些思路。</p><a id="more"></a><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-什么是Glibc"><a href="#1-1-什么是Glibc" class="headerlink" title="1.1 什么是Glibc?"></a>1.1 什么是Glibc?</h3><p>我们先看看官方的解释：</p><blockquote><p>The GNU C Library project provides the core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel.</p></blockquote><p>Glibc的全名是The GNU C Library，它为GNU系统、GNU/Linux系统以及提供了核心的底层库。比如，我们平常使用的<code>memset</code>，<code>strlen</code>等等这些非常常用的接口都由这个库提供。</p><h3 id="1-2-为什么要优化？"><a href="#1-2-为什么要优化？" class="headerlink" title="1.2 为什么要优化？"></a>1.2 为什么要优化？</h3><p>在计算领域的水平场景，例如大数据、数据库、Web等领域都直接或者间接地依赖着Glibc，举个简单的例子，在数据库的代码中，我们经常使用memcpy接口，对变量进行复制，调用频次也异常的高。如果在数据复制的过程中，性能能够有所提升，那么对上层软件的性能提升也是显而易见的。</p><h3 id="1-3-做了什么优化？"><a href="#1-3-做了什么优化？" class="headerlink" title="1.3 做了什么优化？"></a>1.3 做了什么优化？</h3><p>根据我们的分析，字符、内存和锁操作是最基础也是最重要的基本接口，因此，我们选择了对这三种类型的接口优先进行优化。在实现优化中，我们利用了Glibc的<a href="https://sourceware.org/glibc/wiki/GNU_IFUNC" target="_blank" rel="noopener">indirect function</a>这一机制，即会根据CPU、CPU arch去自动选择匹配的函数。这一机制让我们的实现，更加灵活，也对现有系统影响最小。</p><p>下图为我们这次优化主要接口：</p><p><img src="https://user-images.githubusercontent.com/1736354/82533405-c5c93c00-9b75-11ea-8c71-f37f557febee.png" alt="image"></p><p>在上游社区的推进过程中，我们始终坚持<strong>Upstream First</strong>的原则，希望能够将鲲鹏优化的收益共享给整个生态，真正做到<strong>源于鲲鹏，回归社区</strong>。</p><p>所以，可以看到我们的优化大部分（橙色部分）都贡献到了上游社区的AArch64的generic实现中，从而使得整个生态都能够受益，而小部分（绿色部分）针对于Kunpeng CPU的特殊优化则保持了单独实现。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2. 优化"></a>2. 优化</h2><p>我们知道在一般的开发中，小字节数据操作的使用频率，是远远的大于大字节数据操作的使用频率，而对于大数据和数据库的场景，则有可能会出现很多大字节数据操作的使用。因此，其实我们的一个优化原则是：<strong>在保证中小字节没有负优化的前提下，提升大字节数据操作的性能</strong>。</p><p>本节我们将一一解析在我们贡献的过程中，每个接口优化的关键点，并且尽可能的写的通俗易懂，希望能通过这些干货，给大家在其他的优化中带来启发。</p><h3 id="2-1-memcmp，每次做更多，总时间更少"><a href="#2-1-memcmp，每次做更多，总时间更少" class="headerlink" title="2.1 memcmp，每次做更多，总时间更少"></a>2.1 memcmp，每次做更多，总时间更少</h3><p>Patch链接：<a href="http://patchwork.ozlabs.org/patch/1182191/" target="_blank" rel="noopener">aarch64: Optimized implementation of memcmp</a></p><h4 id="2-1-1-优化思路"><a href="#2-1-1-优化思路" class="headerlink" title="2.1.1 优化思路"></a>2.1.1 优化思路</h4><p>对于memcmp的优化，我们的核心思路是通过<strong>循环展开</strong>让每个周期内做的事情更多，从而减少循环本身的开销。下图可以直观的看出，循环展开带来的性能提升：<br><img src="https://user-images.githubusercontent.com/1736354/82417438-212ff700-9aae-11ea-941b-ee98d33a9df6.png" alt="image"><br>具体如下：</p><ol><li>扩展循环间隔长度<br>memcmp的aarch64原实现是以16bit的长度作为循环的周期长度，在无形中增加了很多次循环的消耗，尤其是在进行大字节数据比较中，有较大的性能损失。因此，我们这次优化的核心思路是：<strong>将16bit的循环扩展的64bit的循环</strong>，简单的说就是现在一次循环会比较64bit的数据。</li><li>寻址方式优化<br>除此之外，我们还改变了LDP的寻址方式，从原来的后变址寻址（Post Index Addressing）变成了偏移寻址（Base Plus index）。</li></ol><h4 id="2-1-2-性能测试"><a href="#2-1-2-性能测试" class="headerlink" title="2.1.2 性能测试"></a>2.1.2 性能测试</h4><p><img src="https://user-images.githubusercontent.com/1736354/79631884-7f577a80-818e-11ea-8dba-b5d4d92718e1.png" alt="image"></p><p>可以从我们实际的测试结果看到整体在中大字节的性能有不错的提升，尤其是在128字节以上的场景，性能提升更是达到了18%。</p><h3 id="2-2-memcpy，他山之石，可以为玉"><a href="#2-2-memcpy，他山之石，可以为玉" class="headerlink" title="2.2 memcpy，他山之石，可以为玉"></a>2.2 memcpy，他山之石，可以为玉</h3><p>Patch链接：<a href="http://patchwork.ozlabs.org/patch/1215732/" target="_blank" rel="noopener">add default memcpy version for kunpeng920</a><br>memcpy优化，因为社区的falkor版本在大、小字节的性能表现，已经很完善，因此最终，我们直接使用了Flakor版本作为优化版本。</p><p>Falkor版本的将字符分为3种场景：</p><ol><li>对于small(&lt; 32)的场景，优先处理，避免过多判断，影响性能。</li><li>对于medium(33-128)的场景，做展开，避免多次循环带来的性能损失。</li><li>对于large(&gt;128)的场景，4字节对齐处理，并做循环展开每次循环处理64字节。</li></ol><p>有兴趣的可以看看源码的实现<a href="http://patchwork.ozlabs.org/project/glibc/patch/1502134812-31816-1-git-send-email-siddhesh@sourceware.org/" target="_blank" rel="noopener">链接</a>，整体性能提升13-18%。</p><h3 id="2-3-memrchr，站在巨人的肩上"><a href="#2-3-memrchr，站在巨人的肩上" class="headerlink" title="2.3 memrchr，站在巨人的肩上"></a>2.3 memrchr，站在巨人的肩上</h3><p>Patch链接：<a href="http://patchwork.ozlabs.org/patch/1178706/" target="_blank" rel="noopener">aarch64: Optimized implementation of memrchr</a></p><h4 id="2-3-1-优化思路"><a href="#2-3-1-优化思路" class="headerlink" title="2.3.1 优化思路"></a>2.3.1 优化思路</h4><p>memrchr整体的优化思路是，参考memchr设计的魔鬼数字算法，通过汇编实现逻辑适配，实现对特定字符逆向查找的功能，替代原有的C语言实现方案达到优化，具体实现见上链接。</p><h4 id="2-3-2-性能测试"><a href="#2-3-2-性能测试" class="headerlink" title="2.3.2 性能测试"></a>2.3.2 性能测试</h4><p><img src="https://user-images.githubusercontent.com/1736354/82403228-ed92a400-9a90-11ea-9a35-9ec4899cc9ea.png" alt="image"><br>最终，我们获得了58%的性能提升，最终在大字节的场景，比generic版本提升了4倍左右。</p><h3 id="2-4-memset，定向优化，更懂硬件"><a href="#2-4-memset，定向优化，更懂硬件" class="headerlink" title="2.4 memset，定向优化，更懂硬件"></a>2.4 memset，定向优化，更懂硬件</h3><p>Patch链接：<a href="http://patchwork.ozlabs.org/patch/1188834/" target="_blank" rel="noopener">aarch64: Optimized memset for Kunpeng processor. </a></p><h4 id="2-4-1-优化思路"><a href="#2-4-1-优化思路" class="headerlink" title="2.4.1 优化思路"></a>2.4.1 优化思路</h4><p>我们进行了通过循环展开和特殊的定制优化来更好的适配硬件分支预测的特性，从而达到优化的效果。</p><p>特别说明的是，对于memset来说，置零场景是非常常用的场景，我们发现原有的实现使用DZ_ZVA指令并未在置零场景有显著效果，反而增加了许多条件分支，因此我们使用set_long代替了置零，由于set_long本身有更少的分支及更少的预测，所以性能与原实现比也有所提升。</p><h4 id="2-4-2-性能测试"><a href="#2-4-2-性能测试" class="headerlink" title="2.4.2 性能测试"></a>2.4.2 性能测试</h4><p><img src="https://user-images.githubusercontent.com/1736354/82403298-19158e80-9a91-11ea-8b50-9542edcc15ca.png" alt="image"></p><h3 id="2-5-strcpy，加速的武器，vector-loads"><a href="#2-5-strcpy，加速的武器，vector-loads" class="headerlink" title="2.5 strcpy，加速的武器，vector loads"></a>2.5 strcpy，加速的武器，vector loads</h3><p>Patch链接：<a href="http://patchwork.ozlabs.org/patch/1181183/" target="_blank" rel="noopener">aarch64: Optimized implementation of strcpy</a><br>strlen使用了neon寄存器，通过vector operations对函数进行了优化，对比原有的汇编实现，在64字节以上的场景，获得了5%-18%的提升：</p><p><img src="https://user-images.githubusercontent.com/1736354/82403315-2763aa80-9a91-11ea-82f4-441c90b52962.png" alt="image"></p><h3 id="2-6-strlen-strnlen-循环展开，判断更少，性能更优"><a href="#2-6-strlen-strnlen-循环展开，判断更少，性能更优" class="headerlink" title="2.6 strlen/strnlen 循环展开，判断更少，性能更优"></a>2.6 strlen/strnlen 循环展开，判断更少，性能更优</h3><p>strlen Patch链接：<a href="https://patches-gcc.linaro.org/patch/25209/" target="_blank" rel="noopener">aarch64: Optimized strlen for strlen_asimd</a><br>strnlen Patch链接：<a href="http://patchwork.ozlabs.org/patch/1181184/" target="_blank" rel="noopener">aarch64: Optimized implementation of strnlen</a></p><p>strlen和strnlen同样使用了vector operations和循环展开，对主循环仅行了改造</p><p>strlen有7%-18%的提升:<br><img src="https://user-images.githubusercontent.com/1736354/82403331-321e3f80-9a91-11ea-9703-ab92470b2178.png" alt="image"></p><p>strnlen有11%-24%的提升:<br><img src="https://user-images.githubusercontent.com/1736354/82403342-39dde400-9a91-11ea-9fc8-5f68df97887b.png" alt="image"></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>经过上面的介绍，相信大家已经了解了我们是怎么去优化这些函数的版本的，虽说大部分的优化都是比较晦涩的汇编语言，但是其实实际原理还是非常易懂的。</p><p>最后，我们再总结下我们应该从哪些方面考虑，去完成优化：</p><ul><li>使用Neon汇编指令提高指令速度</li><li>使用Prefetch机制充分利用cache</li><li>避免非对齐的内存访问</li><li>指令重排，减少数据依赖</li><li>循环展开，减少高频判断</li><li>结合硬件特性，用软件补齐硬件缺陷</li></ul><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>本书所提及的所有代码，均已贡献到Glibc上游社区，并且随着<a href="https://sourceware.org/legacy-ml/libc-announce/2020/msg00001.html" target="_blank" rel="noopener">Glibc 2.31</a>已经在社区完成发布，有需要的可以直接从社区上游获取使用，有任何问题也可以在本文留言。</p><p>另外，Glibc优化，也全部<a href="https://gitee.com/src-openeuler/glibc/pulls/17" target="_blank" rel="noopener">合入到</a>集成在当前版本的openeuler中，有兴趣的，也可以直接使用openEuler最新版本进行体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从2019年10月初开始，我们团队开始着手Glibc在aarch64(64)架构下的优化工作，并且在2019年年底，将我们的全部优化贡献给上游开源社区。本文分享我们在Glibc的版本完成的优化以及性能测试结果，同时我们也尝试着将优化的思路进行总结，希望对其他项目的优化提供一些思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ARM" scheme="http://yikun.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>OpenLab快速使用指南</title>
    <link href="http://yikun.github.io/2019/04/12/OpenLab%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yikun.github.io/2019/04/12/OpenLab快速使用指南/</id>
    <published>2019-04-12T07:06:40.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>希望本篇文章帮助你快速地了解如何快速地上手OpenLab。</p><h3 id="1-Hello-OpenLab"><a href="#1-Hello-OpenLab" class="headerlink" title="1. Hello OpenLab"></a>1. Hello OpenLab</h3><p>OpenLab提供的核心能力之一，就是可以为项目提供计算资源（目前以虚拟机为主），用户可以通过配置来完成任务的定义，那么，先以”Hello OpenLab”为例介绍如何使用OpenLab的资源。</p><a id="more"></a><h4 id="Step-0-申请资源"><a href="#Step-0-申请资源" class="headerlink" title="Step 0 申请资源"></a>Step 0 申请资源</h4><h4 id="Step-1-配置Job"><a href="#Step-1-配置Job" class="headerlink" title="Step 1 配置Job"></a>Step 1 配置Job</h4><p>首先，我们要通过配置文件，来告诉OpenLab，哪个项目需要跑什么脚本，具体如下：</p><ol><li><strong>配置项目</strong>，例如<code>https://github.com/Yikun/arm-openlab-test</code>的项目名称为<code>Yikun/arm-openlab-test</code></li><li><strong>配置任务</strong>，任务里定义了这个任务需要跑在哪个节点(nodeset)，需要跑哪个脚本。</li><li><strong>脚本</strong>，配置脚本中需要执行哪些命令。<h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4>配置文件(.zuul.yaml)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- project:</span><br><span class="line">    name: Yikun/hello-openlab</span><br><span class="line">    check:</span><br><span class="line">      jobs:</span><br><span class="line">        - hello-openlab-test</span><br><span class="line"></span><br><span class="line">- job:</span><br><span class="line">    name: hello-openlab-test</span><br><span class="line">    parent: init-test</span><br><span class="line">    description: |</span><br><span class="line">      Hello OpenLab in OpenLab ARM cluster.</span><br><span class="line">    run: .zuul/playbooks/arm-openlab-test/run.yaml</span><br><span class="line">    nodeset: ubuntu-xenial-arm64</span><br></pre></td></tr></table></figure></li></ol><p>脚本文件(.zuul/playbooks/arm-openlab-test/run.yaml)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Hello OpenLab</span><br><span class="line">      shell:</span><br><span class="line">        cmd: |</span><br><span class="line">          set -xe</span><br><span class="line">          echo &quot;Hello OpenLab&quot;</span><br><span class="line">        executable: /bin/bash</span><br></pre></td></tr></table></figure></p><h3 id="2-roles——减少重复工作的利器"><a href="#2-roles——减少重复工作的利器" class="headerlink" title="2. roles——减少重复工作的利器"></a>2. roles——减少重复工作的利器</h3><p>为了让用户减少重复工作，OpenLab也提供了一些<a href="https://github.com/theopenlab/openlab-zuul-jobs/tree/master/roles" target="_blank" rel="noopener">常用的脚本</a>完成基本的安装。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- hosts: all</span><br><span class="line">  roles:</span><br><span class="line">    - role: config-golang</span><br><span class="line">      arch: arm64</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Hello OpenLab</span><br><span class="line">      shell:</span><br><span class="line">        cmd: |</span><br><span class="line">          set -xe</span><br><span class="line">          echo &quot;Hello OpenLab&quot;</span><br><span class="line">        executable: /bin/bash</span><br></pre></td></tr></table></figure><p>用户只需要指定<code>config-golang</code>，即可完成环境上golang的arm64版本的安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roles:</span><br><span class="line">  - role: config-golang</span><br><span class="line">    arch: arm64</span><br></pre></td></tr></table></figure></p><p>当然，如果发现了更好的role，也可以直接贡献到OpenLab。</p><h3 id="3-实例参考"><a href="#3-实例参考" class="headerlink" title="3. 实例参考"></a>3. 实例参考</h3><p>实例参考：<a href="https://github.com/Yikun/hello-openlab/pull/2" target="_blank" rel="noopener">https://github.com/Yikun/hello-openlab/pull/2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;希望本篇文章帮助你快速地了解如何快速地上手OpenLab。&lt;/p&gt;
&lt;h3 id=&quot;1-Hello-OpenLab&quot;&gt;&lt;a href=&quot;#1-Hello-OpenLab&quot; class=&quot;headerlink&quot; title=&quot;1. Hello OpenLab&quot;&gt;&lt;/a&gt;1. Hello OpenLab&lt;/h3&gt;&lt;p&gt;OpenLab提供的核心能力之一，就是可以为项目提供计算资源（目前以虚拟机为主），用户可以通过配置来完成任务的定义，那么，先以”Hello OpenLab”为例介绍如何使用OpenLab的资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[Placement深度探索] 共享、嵌套、分组模型深度解析</title>
    <link href="http://yikun.github.io/2018/08/01/Placement%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-%E5%85%B1%E4%BA%AB%E3%80%81%E5%B5%8C%E5%A5%97%E3%80%81%E5%88%86%E7%BB%84%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yikun.github.io/2018/08/01/Placement深度探索-共享、嵌套、分组模型深度解析/</id>
    <published>2018-08-01T04:15:23.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>在 #63 中我们介绍了最简单的Allocation candidate的过程，在Placment中，是如何实现分享、嵌套、分组的呢？</p><h2 id="1-模型概览"><a href="#1-模型概览" class="headerlink" title="1. 模型概览"></a>1. 模型概览</h2><p><img src="https://user-images.githubusercontent.com/1736354/43573240-df680e7e-9673-11e8-9786-9492c9e8f4f8.png" alt="image"></p><p>如上图所示，对于一共三个节点，然后还有一个128G的共享内存：</p><ol><li>节点1，含有16个VCPU、32768MB内存、包含2个NUMA分别挂2个PF，一个PF含8个VF，一个PF含2个VF</li><li>节点2，含有16个VCPU、32768MB内存</li><li>节点3，含有16个VCPU、16384MB内存</li></ol><h3 id="1-1-Single，独立模型。"><a href="#1-1-Single，独立模型。" class="headerlink" title="1.1 Single，独立模型。"></a>1.1 Single，独立模型。</h3><p>最简单的模型就是将每个Resource Rrovider(RP)看做独立的，当单个模型含有全部请求资源时，才算满足要求。即请求16个VCPU、16384MB的内存，那我们期待的就是获取到ID为1，6，7的节点。</p><h3 id="1-2-Nested，嵌套模型。"><a href="#1-2-Nested，嵌套模型。" class="headerlink" title="1.2 Nested，嵌套模型。"></a>1.2 Nested，嵌套模型。</h3><p>对于嵌套模型，我们期望的是，将整个树的关系都能被发现到，当一颗树上的资源满足请求，即返回树。即请求16个VCPU、32768MB的内存、8个VF，那么我们最终得到的是1节点，他是作为满足条件树的根节点。</p><h3 id="1-3-Sharing，共享模型。"><a href="#1-3-Sharing，共享模型。" class="headerlink" title="1.3 Sharing，共享模型。"></a>1.3 Sharing，共享模型。</h3><p>对于共享模型，我们期望的是，将共享的NFS的资源也考虑进去，当然，这个资源仅共享给一个agg分组的RP，即请求16个VCPU、32768MB的内存、128G的硬盘，我们期望得到的是1节点和6节点。</p><h3 id="1-4-Aggregate，分组模型。"><a href="#1-4-Aggregate，分组模型。" class="headerlink" title="1.4 Aggregate，分组模型。"></a>1.4 Aggregate，分组模型。</h3><p>用户可以通过member_of指定agg，获取某个组内的资源。例如，我指定member_of agg1，那么我们期望得到的就是1节点和7节点。另外，还有一个场景，就是共享模型的提到的，即如果一个RP是共享的，那么在一个Aggregate中的RP都可以共享他的资源。</p><a id="more"></a><h2 id="2-实现深度解析"><a href="#2-实现深度解析" class="headerlink" title="2. 实现深度解析"></a>2. 实现深度解析</h2><p><img src="https://user-images.githubusercontent.com/1736354/43561899-d37ef762-964b-11e8-8820-1ae5acfafe18.png" alt="image"></p><h3 id="2-1-Same-Provider"><a href="#2-1-Same-Provider" class="headerlink" title="2.1 Same Provider"></a>2.1 Same Provider</h3><p>在Placment的实现中，也是将single模型和其他模型通过use_same_provider参数区分开来。我们从简单的入手，先看单一模型的实现。建议先找找刺激，看看<a href="https://github.com/openstack/nova/tree/1adc6ad/nova/api/openstack/placement/objects/resource_provider.py#L2811~#L2916" target="_blank" rel="noopener">代码</a>，：）</p><p>核心流程主要有以下几个过滤条件：</p><h4 id="2-1-1-指定和禁止traits"><a href="#2-1-1-指定和禁止traits" class="headerlink" title="2.1.1 指定和禁止traits"></a>2.1.1 <strong>指定和禁止traits</strong></h4><p>当用户指定或禁止traits时，过滤包含指定traits且不包含禁止traits的resource provider</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> required_traits:</span><br><span class="line">    <span class="comment"># 获取包含所有traits信息的resource provider ids</span></span><br><span class="line">    trait_rps = _get_provider_ids_having_all_traits(ctx, required_traits)</span><br><span class="line">   <span class="comment"># 如果未获取到，直接做短路处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> trait_rps:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"><span class="keyword">if</span> forbidden_traits:</span><br><span class="line">    <span class="comment"># 获取包含任何forbidden traits的rp</span></span><br><span class="line">    forbidden_rp_ids = _get_provider_ids_having_any_trait(</span><br><span class="line">        ctx, forbidden_traits)</span><br><span class="line"><span class="comment"># ... ...</span></span><br><span class="line"><span class="comment"># First filter by the resource providers that had all the required traits</span></span><br><span class="line"><span class="keyword">if</span> trait_rps:</span><br><span class="line">    where_conds.append(rpt.c.id.in_(trait_rps))</span><br><span class="line"><span class="comment"># 除去这些包含forbidden traits的rp</span></span><br><span class="line"><span class="keyword">if</span> forbidden_rp_ids:</span><br><span class="line">    where_conds.append(~rpt.c.id.in_(forbidden_rp_ids))</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/1736354/43569516-42cec200-966a-11e8-9543-d2ab9565fb78.png" alt="image"></p><p>我们看到SQL最开始的where条件就是traits和forbidden traits，放到最前面其实有个目的就是将大部分的RP都可以通过前面的条件过滤掉，这样提升了SQL的整体性能。</p><h4 id="2-1-2-保证可用量"><a href="#2-1-2-保证可用量" class="headerlink" title="2.1.2 保证可用量"></a>2.1.2 <strong>保证可用量</strong></h4><p>当用户请求某些资源时，保证RP的usage满足需求。可用量的检查类似如下过程：<br>a. VCPU &lt; 16          <strong>剩余量检查</strong>，已使用+请求量&lt;=(总量-预留量)*超分比<br>b. 1 &lt; VCPU &lt; 16   <strong>上下限检查</strong>，资源的分配粒度的检查，不能过大，不能过小。<br>c. VCPU % 1           <strong>分配步长</strong>，比如某些资源仅能5G，5G的分配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> rc_id, amount <span class="keyword">in</span> resources.items():</span><br><span class="line">    <span class="comment"># ... ...</span></span><br><span class="line">    <span class="comment"># join对应资源的resource usage信息后，进行条件限制</span></span><br><span class="line">    usage_cond = sa.and_(</span><br><span class="line">        (</span><br><span class="line">        <span class="comment"># 满足剩余可用</span></span><br><span class="line">        (sql.func.coalesce(usage_by_rc.c.used, <span class="number">0</span>) + amount) &lt;=</span><br><span class="line">        (inv_by_rc.c.total - inv_by_rc.c.reserved) *</span><br><span class="line">            inv_by_rc.c.allocation_ratio</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment"># 满足大于最小限额，小于最大限额，且步长满足</span></span><br><span class="line">        inv_by_rc.c.min_unit &lt;= amount,</span><br><span class="line">        inv_by_rc.c.max_unit &gt;= amount,</span><br><span class="line">        amount % inv_by_rc.c.step_size == <span class="number">0</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 对于每个资源都append其usage的限制</span></span><br><span class="line">    where_conds.append(usage_cond)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-指定分组"><a href="#2-1-3-指定分组" class="headerlink" title="2.1.3 指定分组"></a>2.1.3 <strong>指定分组</strong></h4><p>当用户请求包含member_of分组信息时，仅获取aggregates的的resource provider。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If 'member_of' has values, do a separate lookup to identify the</span></span><br><span class="line"><span class="comment"># resource providers that meet the member_of constraints.</span></span><br><span class="line"><span class="keyword">if</span> member_of:</span><br><span class="line">    rps_in_aggs = _provider_ids_matching_aggregates(ctx, member_of)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rps_in_aggs:</span><br><span class="line">        <span class="comment"># Short-circuit. The user either asked for a non-existing</span></span><br><span class="line">        <span class="comment"># aggregate or there were no resource providers that matched</span></span><br><span class="line">        <span class="comment"># the requirements...</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    where_conds.append(rpt.c.id.in_(rps_in_aggs))</span><br></pre></td></tr></table></figure></p><p>上述过程完成后，一个Same Provider的过滤获取流程就走完了，最终包含的rp就是我们需要的信息，可以看出我们过滤了traits、forbidden traits、usage(inventory)、aggregates信息。</p><blockquote><p>Note: 我们在阅读这种长SQL的代码时，一定要抓住where条件，从where条件入手，查看过滤的关键点，理解了整个SQL的大意之后，再根据where条件所需的信息，往前看一连串的join信息。</p></blockquote><h3 id="2-2-NOT-Same-Provider"><a href="#2-2-NOT-Same-Provider" class="headerlink" title="2.2 NOT Same Provider"></a>2.2 NOT Same Provider</h3><p>在上一节中，介绍了单一的Resource provider的获取流程，但是，当嵌套树、共享模型加进来后，事情变得复杂了一些。那么问题变成了，在考虑树状结构和分组信息的情况下，如何获取满足条件的树信息？</p><h4 id="2-2-1-获得满足所有资源条件的树信息"><a href="#2-2-1-获得满足所有资源条件的树信息" class="headerlink" title="2.2.1 获得满足所有资源条件的树信息"></a>2.2.1 获得满足所有资源条件的树信息</h4><p>代码见<a href="https://github.com/openstack/nova/blob/1adc6ad5339706faece09ff69c24302748ed456c/nova/api/openstack/placement/objects/resource_provider.py#L3148-L3187" target="_blank" rel="noopener">nova/api/openstack/placement/objects/resource_provider.py#L3148-L3187</a></p><ol><li><p>满足单个条件的Resource Provider（树的叶子节点）。<br>遍历每个资源类型，获取满足条件的provider id及对应的root id，例如，对于VCPU:16、VF:2的请求，我们会得到的是如下的rp列表：<br>a. 满足VCPU的（红色虚线框），即1, 6, 7。对应结果为：<code>(1, 1), (6, 6), (7, 7)</code><br>b. 满足VF的（蓝色虚线框），即4, 5。对应结果为：<code>(4, 1), (5, 1)</code><br><img src="https://user-images.githubusercontent.com/1736354/43575569-b6a1ecd4-9679-11e8-8a48-548a9588cad4.png" alt="image"></p></li><li><p>找出满足所有条件的树（树的根节点）。<br>在遍历所有用户请求的资源类型的过程中，生成了2个数据：<br>a. provs_with_inv，记录着<strong>所有满足</strong>资源的(provider_id, root_id, rc_id)，这个是并集。对应结果为：<code>[(1, 1), (6, 6), (7, 7), (4, 1), (5, 1)]</code><br>b. trees_with_inv，记录着<strong>满足所有</strong>资源请求的root_id，这个是取root的交集，即set([1, 6, 7]) &amp; set([1, 1])。对应结果为：<code>[1]</code>。<br>然后，根据tree_with_inv过滤provs_with_inv，一遍拿到最终满足条件的所有树（树的根节点）<br><img src="https://user-images.githubusercontent.com/1736354/43618862-71672588-96fd-11e8-969c-28d4e7c20417.png" alt="image"></p></li></ol><p>最终得到的就是，即满足VCPU又满足VF的根节点。</p><h4 id="2-2-2-追加共享的节点。"><a href="#2-2-2-追加共享的节点。" class="headerlink" title="2.2.2 追加共享的节点。"></a>2.2.2 追加共享的节点。</h4><p>如果在树的基础上再考虑共享的节点的话，事情复杂了那么一点点。</p><ol start="0"><li><p>(<strong>共享独有步骤</strong>) 获取所有的共享RP。<br>首先最开始，捞了一把所有共享的RP。获取的方法比较简单，就是找到所有包含“MISC_SHARES_VIA_AGGREGATE”这一traits的RP，并且其剩余的可用量，满足我们的要求即可。</p></li><li><p>(<strong>在原有步骤追加</strong>) 在“满足单个条件的Resource Provider”追加共享信息。<br>在2.2.1的第1步完成时，继续append满足条件的共享信息。例如，对于VCPU:16、VF:2、DISK:128的请求，我们会得到的是如下的rp列表：<br>a. 满足VCPU的（红色虚线框），即1, 6, 7。对应结果为：<code>(1, 1), (6, 6), (7, 7)</code><br>b. 满足VF的（蓝色虚线框），即4, 5。对应结果为：<code>(4, 1), (5, 1)</code><br>c. (<strong>共享新增</strong>) 满足DISK的（紫色虚线框），即8。对应结果为：<code>(8, 1), (8, 6)</code><br><img src="https://user-images.githubusercontent.com/1736354/43621586-e7cb7988-970a-11e8-976a-2fc61c83b2b4.png" alt="image"></p></li><li><p>(<strong>在原有步骤追加</strong>) 在“满足所有条件的树（树的根节点）”与共享信息再取交集。<br>追加上sharing的RP后，我们那两个关键的数据变为了：<br>a. provs_with_inv，记录着<strong>所有满足</strong>资源（<strong>包括共享资源</strong>）的(provider_id, root_id, rc_id)，这个是并集。对应结果为：<code>[(1, 1), (6, 6), (7, 7), (4, 1), (5, 1), (8, 1), (8, 6)]</code>，比之前新增了<code>(8, 1), (8, 6)</code>。 即“anchors for sharing providers”这一方法完成的。<br>b. trees_with_inv，记录着<strong>满足所有</strong>资源请求（<strong>包括共享资源</strong>）的root_id，这个是取root的交集，即set([1, 6, 7]) &amp; set([1, 1]) &amp; set([1, 6])，比原来新增了<code>set([1, 6]</code>。对应结果仍为：<code>[1]</code>。</p></li></ol><p><img src="https://user-images.githubusercontent.com/1736354/43621682-4ec32fc8-970b-11e8-83b5-f95f892279be.png" alt="image"></p><p>最终，就找到了满足条件VCPU:16、VF:2、DISK:128的树。</p><h4 id="2-2-3-“anchors-for-sharing-providers”-–-关键步骤单独解析。"><a href="#2-2-3-“anchors-for-sharing-providers”-–-关键步骤单独解析。" class="headerlink" title="2.2.3 “anchors for sharing providers” – 关键步骤单独解析。"></a>2.2.3 “anchors for sharing providers” – 关键步骤单独解析。</h4><p>刚才我们提到了“anchors for sharing providers”，这个是干啥的？代码见<a href="https://github.com/openstack/nova/blob/1adc6ad5339706faece09ff69c24302748ed456c/nova/api/openstack/placement/objects/resource_provider.py#L433-L489" target="_blank" rel="noopener">nova/api/openstack/placement/objects/resource_provider.py#L433-L489</a><br>这个函数名字有点诡异，共享provider的“锚”？其实这个函数解决的就是：已知共享资源的情况下，如何找到可以使用这些共享资源的树根？<br>其实就是共享的RP与其关联的其他RP取笛卡尔积（即N*M）的过程，可能有点抽象，我们举个例子：<br>已知1、2、3处于一个AGG，然后，1、2共享了一些资源，我需要找到所有可以享用1、2资源的树。<br><img src="https://user-images.githubusercontent.com/1736354/43629343-8d9b9e96-972f-11e8-89f6-772eaed7238e.png" alt="image"></p><ol><li><p>1、2、3均处于同一agg 1中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> resource_provider_id, aggregate_id <span class="keyword">from</span> resource_provider_aggregates;</span><br><span class="line">+<span class="comment">----------------------+--------------+</span></span><br><span class="line">| resource_provider_id | aggregate_id |</span><br><span class="line">+<span class="comment">----------------------+--------------+</span></span><br><span class="line">|                    1 |            1 |</span><br><span class="line">|                    2 |            1 |</span><br><span class="line">|                    3 |            1 |</span><br><span class="line">+<span class="comment">----------------------+--------------+</span></span><br></pre></td></tr></table></figure></li><li><p>通过agg自join取笛卡尔积</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sps.resource_provider_id,sps.aggregate_id,rps.aggregate_id,rps.resource_provider_id</span><br><span class="line">    <span class="comment"># 笛卡尔积的左项</span></span><br><span class="line">    -&gt; <span class="keyword">from</span> resource_provider_aggregates sps</span><br><span class="line">    <span class="comment"># 笛卡尔积的右项</span></span><br><span class="line">    -&gt; <span class="keyword">inner</span> <span class="keyword">join</span> resource_provider_aggregates rps</span><br><span class="line">    -&gt; <span class="keyword">on</span> sps.aggregate_id = rps.aggregate_id</span><br><span class="line">    <span class="comment"># 笛卡尔积的左项，限制为共享的RP</span></span><br><span class="line">    -&gt; <span class="keyword">where</span> sps.resource_provider_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">+<span class="comment">----------------------+--------------+--------------+----------------------+</span></span><br><span class="line">| resource_provider_id | aggregate_id | aggregate_id | resource_provider_id |</span><br><span class="line">+<span class="comment">----------------------+--------------+--------------+----------------------+</span></span><br><span class="line">|                    1 |            1 |            1 |                    1 |</span><br><span class="line">|                    1 |            1 |            1 |                    2 |</span><br><span class="line">|                    1 |            1 |            1 |                    3 |</span><br><span class="line">|                    2 |            1 |            1 |                    1 |</span><br><span class="line">|                    2 |            1 |            1 |                    2 |</span><br><span class="line">|                    2 |            1 |            1 |                    3 |</span><br><span class="line">+<span class="comment">----------------------+--------------+--------------+----------------------+</span></span><br></pre></td></tr></table></figure></li><li><p>在笛卡尔积的基础上关联root<br>然后，再将上述结果，和RP一join，就得到了关联的root。最终，发现可以共享1、2资源的跟节点就是1(1所在树根)、2（2所在树根）、0（3所在树根）</p></li></ol><h4 id="2-2-4-member-of过滤。"><a href="#2-2-4-member-of过滤。" class="headerlink" title="2.2.4 member_of过滤。"></a>2.2.4 member_of过滤。</h4><p>代码见<a href="https://github.com/openstack/nova/blob/1adc6ad5339706faece09ff69c24302748ed456c/nova/api/openstack/placement/objects/resource_provider.py#L3189-L3199" target="_blank" rel="noopener">nova/api/openstack/placement/objects/resource_provider.py#L3189-L3199</a><br>这个逻辑就很简单了，RP和agg一join，然后额外的条件就是RP在agg就行。</p><h4 id="2-2-5-指定或禁止traits。"><a href="#2-2-5-指定或禁止traits。" class="headerlink" title="2.2.5 指定或禁止traits。"></a>2.2.5 指定或禁止traits。</h4><p>代码见<a href="https://github.com/openstack/nova/blob/1adc6ad5339706faece09ff69c24302748ed456c/nova/api/openstack/placement/objects/resource_provider.py#L3213-L3218" target="_blank" rel="noopener">nova/api/openstack/placement/objects/resource_provider.py#L3213-L3218</a><br>留下包含所有traits的RP，干掉包含任意forbidden traits的RP</p><p>又是一篇TL;DR的文章，就这样吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 #63 中我们介绍了最简单的Allocation candidate的过程，在Placment中，是如何实现分享、嵌套、分组的呢？&lt;/p&gt;
&lt;h2 id=&quot;1-模型概览&quot;&gt;&lt;a href=&quot;#1-模型概览&quot; class=&quot;headerlink&quot; title=&quot;1. 模型概览&quot;&gt;&lt;/a&gt;1. 模型概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1736354/43573240-df680e7e-9673-11e8-9786-9492c9e8f4f8.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，对于一共三个节点，然后还有一个128G的共享内存：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点1，含有16个VCPU、32768MB内存、包含2个NUMA分别挂2个PF，一个PF含8个VF，一个PF含2个VF&lt;/li&gt;
&lt;li&gt;节点2，含有16个VCPU、32768MB内存&lt;/li&gt;
&lt;li&gt;节点3，含有16个VCPU、16384MB内存&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1-1-Single，独立模型。&quot;&gt;&lt;a href=&quot;#1-1-Single，独立模型。&quot; class=&quot;headerlink&quot; title=&quot;1.1 Single，独立模型。&quot;&gt;&lt;/a&gt;1.1 Single，独立模型。&lt;/h3&gt;&lt;p&gt;最简单的模型就是将每个Resource Rrovider(RP)看做独立的，当单个模型含有全部请求资源时，才算满足要求。即请求16个VCPU、16384MB的内存，那我们期待的就是获取到ID为1，6，7的节点。&lt;/p&gt;
&lt;h3 id=&quot;1-2-Nested，嵌套模型。&quot;&gt;&lt;a href=&quot;#1-2-Nested，嵌套模型。&quot; class=&quot;headerlink&quot; title=&quot;1.2 Nested，嵌套模型。&quot;&gt;&lt;/a&gt;1.2 Nested，嵌套模型。&lt;/h3&gt;&lt;p&gt;对于嵌套模型，我们期望的是，将整个树的关系都能被发现到，当一颗树上的资源满足请求，即返回树。即请求16个VCPU、32768MB的内存、8个VF，那么我们最终得到的是1节点，他是作为满足条件树的根节点。&lt;/p&gt;
&lt;h3 id=&quot;1-3-Sharing，共享模型。&quot;&gt;&lt;a href=&quot;#1-3-Sharing，共享模型。&quot; class=&quot;headerlink&quot; title=&quot;1.3 Sharing，共享模型。&quot;&gt;&lt;/a&gt;1.3 Sharing，共享模型。&lt;/h3&gt;&lt;p&gt;对于共享模型，我们期望的是，将共享的NFS的资源也考虑进去，当然，这个资源仅共享给一个agg分组的RP，即请求16个VCPU、32768MB的内存、128G的硬盘，我们期望得到的是1节点和6节点。&lt;/p&gt;
&lt;h3 id=&quot;1-4-Aggregate，分组模型。&quot;&gt;&lt;a href=&quot;#1-4-Aggregate，分组模型。&quot; class=&quot;headerlink&quot; title=&quot;1.4 Aggregate，分组模型。&quot;&gt;&lt;/a&gt;1.4 Aggregate，分组模型。&lt;/h3&gt;&lt;p&gt;用户可以通过member_of指定agg，获取某个组内的资源。例如，我指定member_of agg1，那么我们期望得到的就是1节点和7节点。另外，还有一个场景，就是共享模型的提到的，即如果一个RP是共享的，那么在一个Aggregate中的RP都可以共享他的资源。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Python3内建函数扫盲</title>
    <link href="http://yikun.github.io/2018/06/15/Python3%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E6%89%AB%E7%9B%B2/"/>
    <id>http://yikun.github.io/2018/06/15/Python3内建函数扫盲/</id>
    <published>2018-06-15T02:40:26.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p> 已完成11/68: <img src="http://progressed.io/bar/15" alt="Progress: 10/68"></p><h4 id="0-abs绝对值"><a href="#0-abs绝对值" class="headerlink" title="0. abs绝对值"></a>0. abs绝对值</h4><h4 id="1-all（all-items-are-True-）-迭代中所有元素均为True或者为空也返回true"><a href="#1-all（all-items-are-True-）-迭代中所有元素均为True或者为空也返回true" class="headerlink" title="1. all（all items are True?） 迭代中所有元素均为True或者为空也返回true"></a>1. all（all items are True?） 迭代中所有元素均为True或者为空也返回true</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>all([])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="2-any（any-item-is-True-）-迭代中任意一个元素为True，则返回True，否则返回False，为空返回False"><a href="#2-any（any-item-is-True-）-迭代中任意一个元素为True，则返回True，否则返回False，为空返回False" class="headerlink" title="2. any（any item is True?）, 迭代中任意一个元素为True，则返回True，否则返回False，为空返回False"></a>2. any（any item is True?）, 迭代中任意一个元素为True，则返回True，否则返回False，为空返回False</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([<span class="number">0</span>])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([[],[]])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>any([[<span class="number">0</span>],[]])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="3-ascii，返回repr-的ascii形式"><a href="#3-ascii，返回repr-的ascii形式" class="headerlink" title="3. ascii，返回repr()的ascii形式"></a>3. ascii，返回repr()的ascii形式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'中文'</span>)</span><br><span class="line"><span class="string">"'\\u4e2d\\u6587'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="number">1</span>)</span><br><span class="line"><span class="string">'1'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii([])</span><br><span class="line"><span class="string">'[]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="string">'[1, 2, 3]'</span></span><br></pre></td></tr></table></figure><p>repr和eval为反向函数（类似序列化反序列化？）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'[1, 2, 3]'</span>)</span><br><span class="line"><span class="string">"'[1, 2, 3]'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"'[1, 2, 3]'"</span>)</span><br><span class="line"><span class="string">'[1, 2, 3]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'[1, 2, 3]'</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'[1, 2, 3]'</span>)</span><br><span class="line"><span class="string">"'[1, 2, 3]'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="string">'[1, 2, 3]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'[1, 2, 3]'</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><h4 id="4-bin-返回二进制形式"><a href="#4-bin-返回二进制形式" class="headerlink" title="4. bin 返回二进制形式"></a>4. bin 返回二进制形式</h4><h4 id="5-bool-返回布尔值"><a href="#5-bool-返回布尔值" class="headerlink" title="5. bool 返回布尔值"></a>5. bool 返回布尔值</h4><h4 id="6-bytearray"><a href="#6-bytearray" class="headerlink" title="6. bytearray"></a>6. bytearray</h4><p>大部分用法和bytes/str有点像，不过bytearray是可变的类似a list of char，str是immutable的。也就说说改变字符串的时候其实是把内存中真个对象换了，bytearray的话，只换某个字符，性能好一些</p><p>参考学习：<a href="https://stackoverflow.com/questions/9099145/where-are-python-bytearrays-used" target="_blank" rel="noopener">Where are python bytearrays used?</a></p><blockquote><p>A bytearray is very similar to a regular python string (str in python2.x, bytes in python3) but with an important difference, whereas strings are immutable, bytearrays are mutable, a bit like a list of single character strings.</p><p>This is useful because some applications use byte sequences in ways that perform poorly with immutable strings. When you are making lots of little changes in the middle of large chunks of memory, as in a database engine, or image library, strings perform quite poorly; since you have to make a copy of the whole (possibly large) string.  bytearrays have the advantage of making it possible to make that kind of change without making a copy of the memory first.</p><p>But this particular case is actually more the exception, rather than the rule. Most uses involve comparing strings, or string formatting. For the latter, there’s usually a copy anyway, so a mutable type would offer no advantage, and for the former, since immutable strings cannot change, you can calculate a hash of the string and compare that as a shortcut to comparing each byte in order, which is almost always a big win; and so it’s the immutable type (str or bytes) that is the default; and bytearray is the exception when you need it’s special features.</p></blockquote><h4 id="7-bytes"><a href="#7-bytes" class="headerlink" title="7.bytes"></a>7.bytes</h4><p>bytes is an immutable version of bytearray</p><h4 id="8-callable-判断一个obj的argument是否可以call"><a href="#8-callable-判断一个obj的argument是否可以call" class="headerlink" title="8.callable 判断一个obj的argument是否可以call"></a>8.callable 判断一个obj的argument是否可以call</h4><p><a href="https://github.com/openstack/nova/blob/2d6a838/nova/virt/hyperv/driver.py#L75" target="_blank" rel="noopener">https://github.com/openstack/nova/blob/2d6a838/nova/virt/hyperv/driver.py#L75</a></p><h4 id="9-chr-和-ord"><a href="#9-chr-和-ord" class="headerlink" title="9. chr 和 ord"></a>9. chr 和 ord</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">97</span>)</span><br><span class="line"><span class="string">'a'</span></span><br></pre></td></tr></table></figure><h4 id="10-classmethod-和-staticmethod"><a href="#10-classmethod-和-staticmethod" class="headerlink" title="10. @classmethod 和 @staticmethod"></a>10. @classmethod 和 @staticmethod</h4><p>classmethod must have a reference to a class object as the first parameter, whereas staticmethod can have no parameters at all.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'11-09-2012'</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner</a></p><h4 id="11-compile"><a href="#11-compile" class="headerlink" title="11. compile"></a>11. compile</h4><p>将一个字符串编译为字节代码，这个函数可以用在web应用从模板（可含Python语法）生成html。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;str = <span class="string">"for i in range(0,10): print(i)"</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = compile(str,<span class="string">''</span>,<span class="string">'exec'</span>)   <span class="comment"># 编译为字节代码对象 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">&lt;code object &lt;module&gt; at <span class="number">0x10141e0b0</span>, file <span class="string">""</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(c)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 已完成11/68: &lt;img src=&quot;http://progressed.io/bar/15&quot; alt=&quot;Progress: 10/68&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;0-abs绝对值&quot;&gt;&lt;a href=&quot;#0-abs绝对值&quot; class=&quot;headerlink&quot; title=&quot;0. abs绝对值&quot;&gt;&lt;/a&gt;0. abs绝对值&lt;/h4&gt;&lt;h4 id=&quot;1-all（all-items-are-True-）-迭代中所有元素均为True或者为空也返回true&quot;&gt;&lt;a href=&quot;#1-all（all-items-are-True-）-迭代中所有元素均为True或者为空也返回true&quot; class=&quot;headerlink&quot; title=&quot;1. all（all items are True?） 迭代中所有元素均为True或者为空也返回true&quot;&gt;&lt;/a&gt;1. all（all items are True?） 迭代中所有元素均为True或者为空也返回true&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;all([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;all([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;all([])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Cell v2近期相关改进整理</title>
    <link href="http://yikun.github.io/2018/06/06/Cell-v2%E8%BF%91%E6%9C%9F%E7%9B%B8%E5%85%B3%E6%94%B9%E8%BF%9B%E6%95%B4%E7%90%86/"/>
    <id>http://yikun.github.io/2018/06/06/Cell-v2近期相关改进整理/</id>
    <published>2018-06-06T08:49:46.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Handling-a-down-cell"><a href="#Handling-a-down-cell" class="headerlink" title="Handling a down cell"></a>Handling a down cell</h3><p><a href="https://review.openstack.org/#/c/557369" target="_blank" rel="noopener">https://review.openstack.org/#/c/557369</a><br>在某个cell挂掉的时候，会影响跨Cell的查询、计算Quota等操作。在这个BP中提到了几个场景：</p><ol><li>nova list在一个Cell挂的时候，也需要能正常工作。在当前租户Cell没挂时，没影响，挂掉的话，需要构造一些数据（从api拿一些，然后剩下信息填UNKNOW）</li><li>nova service-list在一个Cell挂的时候，也需要能正常工作。也是通过构造解决。</li><li>nova boot，短期解决方案是如果project有其他虚拟机在挂掉的cell不能创建虚拟机，长期解决方案是通过Placement计算quota和usage。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Handling-a-down-cell&quot;&gt;&lt;a href=&quot;#Handling-a-down-cell&quot; class=&quot;headerlink&quot; title=&quot;Handling a down cell&quot;&gt;&lt;/a&gt;Handling a down cell&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>oslo.db中的死锁重试机制优化</title>
    <link href="http://yikun.github.io/2018/04/19/oslo-db%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://yikun.github.io/2018/04/19/oslo-db中的死锁重试机制优化/</id>
    <published>2018-04-19T02:26:46.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h3><p>OpenStack oslo.db是OpenStack中处理DB相关功能的基础组件，基本OpenStack所有的核心组件都会使用这一基础库。</p><p>去年12月，遇到一个死锁的问题 #62 <a href="https://github.com/Yikun/yikun.github.com/issues/62" target="_blank" rel="noopener">一个死锁问题的深入探究</a>，研究了下oslo.db死锁重试的方式，发现其中并没有加入随机机制。在通信领域，有一个叫做“二进制退避机制”的算法（嗯，也算没白读了7年通信，哈哈，在本文立刻提升逼格），就是通过指数递增+随机的方式来解决无中心、多节点接入时产生的冲突的。</p><p>当时，顺着这个思路，我在oslo.db中提交了一个关于改进死锁重试机制的[patch/527362]：<a href="https://review.openstack.org/#/c/527362/" target="_blank" rel="noopener">Improve exponential backoff for wrap_db_retry</a>。4个多月后，终于合入了。写这篇文章主要是为了记录一下自己学习的过程，以及对死锁及其重试机制的思考。</p><a id="more"></a><h3 id="1-死锁与重试"><a href="#1-死锁与重试" class="headerlink" title="1. 死锁与重试"></a>1. 死锁与重试</h3><h4 id="1-1-从死锁说起"><a href="#1-1-从死锁说起" class="headerlink" title="1.1 从死锁说起"></a>1.1 从死锁说起</h4><p>我们先看看MySQL的文档中对死锁的定义：</p><blockquote><p>A deadlock is a situation where different transactions are unable to proceed because each holds a lock that the other needs. Because both transactions are waiting for a resource to become available, neither ever release the locks it holds.</p></blockquote><p>大致意思就是说，死锁是由于每个事务持有另一个事务需要的锁，而导致不同事务都无法继续。因为两个事务都在等待资源变为可用，所以都不释放它拥有的锁。</p><p>一个非常形象的例子如下所示：<br><img src="https://user-images.githubusercontent.com/1736354/38969913-22e76700-43c5-11e8-8ae6-f4b7b6829a14.jpg" alt="20ca9f2e2faf856e15933d95fd0a6a32_articlex"><br>来自4个路口的车“死锁”了，每个路口的车都无法前进，因为自己前行的道路，都被别的路口的车堵住了，而自己因为无法前进也无法释放自己的道路。</p><h4 id="1-2-从容的应对死锁"><a href="#1-2-从容的应对死锁" class="headerlink" title="1.2 从容的应对死锁"></a>1.2 从容的应对死锁</h4><p>当死锁发生的时候，我们能做什么呢？在Mysql的文档中<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html" target="_blank" rel="noopener">How to Minimize and Handle Deadlocks</a>，给出了一些建议，下面我列举几个通用和常见的条目：</p><blockquote><ul><li>Always be prepared to re-issue a transaction if it fails due to deadlock. Deadlocks are not dangerous. Just try again.<br>如果发生了死锁错误了以后随时准备重试，死锁并不危险，放心大胆的重试吧</li><li>Keep transactions small and short in duration to make them less prone to collision.<br>让事务尽可能的小而短，减少冲突的可能。</li><li>Commit transactions immediately after making a set of related changes to make them less prone to collision.<br>提交事务的时候，也是能提交就尽可能地立刻提交</li><li>When modifying multiple tables within a transaction, or different sets of rows in the same table, do those operations in a consistent order each time. Then transactions form well-defined queues and do not deadlock. For example, organize database operations into functions within your application, or call stored routines, rather than coding multiple similar sequences of INSERT, UPDATE, and DELETE statements in different places.<br>当在一个事务中修改不同的表，或者表中不同行的时候，尽量保持一致的顺序。</li></ul></blockquote><p>另外，还提及了一些其他的应对策略，比如调整事务隔离的级别，锁的级别，优化索引的定义之类的，大多数是以预防为主。当发生死锁的时候，我们也应该首先想到是不是这些情况没有处理好，然而，当死锁真正发生的时候，我们还是用最土但最有效的方法去解决：重试！</p><h4 id="1-3-重试？没那么简单"><a href="#1-3-重试？没那么简单" class="headerlink" title="1.3 重试？没那么简单"></a>1.3 重试？没那么简单</h4><p>在重试机制的实现中，重试时长的选择非常关键，有两个因素需要我们仔细思考一下：</p><p>(1) <strong>退避机制-等待的基数时间</strong>。<br>目前时间的基数是，随着重试次数指数增长的，这个基数对于连接失败类的业务是比较有用的，想象一下，这种类型的业务我们重试的目的说白了就是：<strong>“过一段时间，试一试，看看能不能正常连上”</strong>。</p><p>退避策略的选择可以分为普通退避策略和指数退避策略。普通退避策略：也就是傻傻固定间隔的重试，比如，每次重试的时间都是x秒；<br>而还有一种方式就是指数退避：随着重试次数的增加，我们每次等待的时间也会逐渐递增，1秒，2秒，4秒，8秒，16秒等等。</p><p>在<a href="https://amazonaws-china.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">Exponential Backoff And Jitter</a>一文中，也提到了指数退避、普通退避策略，并且附上了实际的仿真结果：<br><img src="https://user-images.githubusercontent.com/1736354/38991051-fe6a7152-440e-11e8-808e-01a0c60f81d6.png" alt="exponential-backoff-and-jitter-blog-figure-4"></p><p>从图上看到，完成同样的事情，使用指数退避时，总的调用次数变少了。尤其在客户端竞争比较多的时候，指数退避的效果很明显。这个指数退避说白了就是：<strong>“再多等一会儿，别急这那么快就重试”</strong>。</p><p>(2) <strong>随机因子-抖动时间窗口</strong>。<br>不加随机因子的问题是，即使我们大家一起等待了很久，但是还是同时去调用的，没有这个抖动，而单单的增加等待时间基数，只会激增等待时间，而对实际的冲突避免没有什么意思。</p><p>我们思考下，对于死锁这种场景来说，我们真的需要很长的等待时间吗？我觉得其实并不需要很长的“等待的基数时间”，我们需要的只是让各种死锁的请求，互相避开即可，所以其实，只需要拉长等待的时间窗口即可。</p><p><img src="https://user-images.githubusercontent.com/1736354/34139128-e2a3ddfc-e4ad-11e7-88fa-937a926d7f37.jpg" alt="jitter"></p><h5 id="3-1-1-Non-Jitter，无随机"><a href="#3-1-1-Non-Jitter，无随机" class="headerlink" title="3.1.1. Non-Jitter，无随机"></a>3.1.1. Non-Jitter，无随机</h5><p>无随机的方式，就是oslo.db目前使用的方式，仅指数增长，等待时间为1秒，2秒，4秒，8秒。</p><h5 id="3-1-2-Full-Jitter，全量随机"><a href="#3-1-2-Full-Jitter，全量随机" class="headerlink" title="3.1.2. Full Jitter，全量随机"></a>3.1.2. Full Jitter，全量随机</h5><p>在退避sleep的时候，加入随机机制，使得sleep的时间随机化，指数拉长调用的窗口，从而降低再次死锁概率。加上这个jitter后，等待时间变为0~1秒，0~2秒，0~4秒，0~8秒，0~16秒等范围内随机。</p><h5 id="3-1-3-Top-X-Jitter，顶部随机"><a href="#3-1-3-Top-X-Jitter，顶部随机" class="headerlink" title="3.1.3. Top X Jitter，顶部随机"></a>3.1.3. Top X Jitter，顶部随机</h5><p>除了全量随机因子外，我们也可以选择顶部随机的方式，保底的等待基数时间随指数递增，在基数时间的上沿边界向下抖动（比如25%）。这种方法来说既保留了“安全”的重试时间，而且抖动时间窗口也在递增。例如我们25%的都抖动随机，等待时间就为1*0.75~1秒，2*0.75~2秒，4*0.75~4秒，8*0.75~8秒，16*0.75秒~16秒。</p><h5 id="3-1-4-Other-Jitter，其他随机方式"><a href="#3-1-4-Other-Jitter，其他随机方式" class="headerlink" title="3.1.4. Other Jitter，其他随机方式"></a>3.1.4. Other Jitter，其他随机方式</h5><p>另外，在<a href="https://amazonaws-china.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">Exponential Backoff And Jitter</a>一文中，介绍了各种随机时间窗口加到退避算法中的流程后，对平均时间和竞争的调用数也做了一个仿真。结果如下图所示：</p><p><img src="https://user-images.githubusercontent.com/1736354/39026065-903c4cea-447d-11e8-85db-1a2fc168fdc1.jpg" alt="simuj"></p><p>很显然，其中，Fulljitter（0~2**n随机）的抖动范围大，平均抖动时间比较低，因此，从平均时间和冲突避免(总调用数)这两个指标综合看，Fulljitter是获胜的。但这并不意味着在所有情况下，我们都需要很低的时间间隔，更长的时间会拥有更“安全”的重试时间，代价则是更耗时了，我想这确实是一个值得思考的tradeoff。</p><p>随机重试时间的选取，我们需要更多的结合业务去看，如果重试的业务是由于竞争冲突引起的（就像死锁），那么，我们就要通过抖动的范围将冲突化解；而如果重试的业务是由于服务暂时不可用，但是可用的时间我们并不确定，这样我们就可以通过增加基数时间来避免无谓的尝试。</p><p>总结一下就是：<strong>通过指数退避机制递增的基数时间，来避免无谓的尝试，通过随机因子机制递增的抖动窗口，来减少冲突的可能</strong>。</p><h3 id="2-oslo-db的改进"><a href="#2-oslo-db的改进" class="headerlink" title="2. oslo.db的改进"></a>2. oslo.db的改进</h3><h4 id="2-1-oslo-db的重试实现"><a href="#2-1-oslo-db的重试实现" class="headerlink" title="2.1 oslo.db的重试实现"></a>2.1 oslo.db的重试实现</h4><p>在得到了充分的理论知识的洗礼后，我们回过头来看看，oslo.db的重试机制的实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重试的基数时间 </span></span><br><span class="line">next_interval = self.retry_interva</span><br><span class="line"><span class="comment"># 重试的最大次数</span></span><br><span class="line">remaining = self.max_retries</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 调用需要重试的函数</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 是否继续重试，不继续就reraise</span></span><br><span class="line">        expected = self._is_exception_expected(e)</span><br><span class="line">        <span class="comment"># reraise</span></span><br><span class="line">        <span class="comment"># 休息next_interval秒</span></span><br><span class="line">        time.sleep(next_interval )</span><br><span class="line">        <span class="comment"># 判断是否递增重试时间</span></span><br><span class="line">        <span class="keyword">if</span> self.inc_retry_interval:</span><br><span class="line">        <span class="comment"># 指数递增，并不超过最大重试时间</span></span><br><span class="line">            next_interval = min(next_interval * <span class="number">2</span>, self.max_retry_interval)</span><br><span class="line">        <span class="comment"># 剩余次数</span></span><br><span class="line">        remaining -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>我将核心的代码提炼出来，我们来分析一下各个入参的作用</p><ul><li>retry_interval：重试的间隔，即基数时间，默认为1秒，即第一次重试1秒</li><li>max_retries：最大重试的次数，默认为20次，即试20次就不试了，并通过内部变量remaining来记录剩余次数</li><li>inc_retry_interval：是否递增最大重试次数，目前为指数递增</li><li>max_retry_interval：最大的重试间隔</li><li>exception_checker：需要进行重试的异常</li></ul><p>可以看到，目前的机制就是我们上文所提到的“指数退避机制”。也就是说，并没有增加随机因子jitter进来。</p><h4 id="2-2-优化！"><a href="#2-2-优化！" class="headerlink" title="2.2 优化！"></a>2.2 优化！</h4><p>于是，这个优化的Patch就诞生了：<a href="https://review.openstack.org/#/c/527362/" target="_blank" rel="noopener">Improve exponential backoff for wrap_db_retry</a>。核心做了2件事情：</p><ol><li>通过增加随机因子jitter参数，为重试机制增加随机抖动的能力。</li><li>在产生死锁的时候，默认启用随机抖动的能力，其中jitter为全量抖动。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.inc_retry_interval:</span><br><span class="line"><span class="comment"># NOTE(jiangyikun): In order to minimize the chance of</span></span><br><span class="line"><span class="comment"># regenerating a deadlock and reduce the average sleep</span></span><br><span class="line"><span class="comment"># time, we are using jitter by default when the</span></span><br><span class="line"><span class="comment"># deadlock is detected. With the jitter,</span></span><br><span class="line"><span class="comment"># sleep_time = [0, next_interval), otherwise, without</span></span><br><span class="line"><span class="comment"># the jitter, sleep_time = next_interval.</span></span><br><span class="line"><span class="keyword">if</span> isinstance(e, exception.DBDeadlock):</span><br><span class="line">jitter = <span class="literal">True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">jitter = self.jitter</span><br><span class="line">sleep_time, next_interval = self._get_inc_interval(next_interval, jitter)</span><br></pre></td></tr></table></figure><p>其中，抖动时间的计算如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_inc_interval</span><span class="params">(self, n, jitter)</span>:</span></span><br><span class="line"><span class="comment"># NOTE(jiangyikun): The "n" help us to record the 2 ** retry_times.</span></span><br><span class="line"><span class="comment"># The "sleep_time" means the real time to sleep:</span></span><br><span class="line"><span class="comment"># - Without jitter: sleep_time = 2 ** retry_times = n</span></span><br><span class="line"><span class="comment"># - With jitter:    sleep_time = [0, 2 ** retry_times) &lt; n</span></span><br><span class="line">        <span class="comment"># 指数增加重试时间间隔</span></span><br><span class="line">n = n * <span class="number">2</span></span><br><span class="line">        <span class="comment"># 全量随机抖动</span></span><br><span class="line"><span class="keyword">if</span> jitter:</span><br><span class="line">sleep_time = random.uniform(<span class="number">0</span>, n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">sleep_time = n</span><br><span class="line"><span class="keyword">return</span> min(sleep_time, self.max_retry_interval), n</span><br></pre></td></tr></table></figure></p><p>这个Patch也在4个月后的几天前，完成了合入。下面也记录一下相关的讨论：</p><ul><li><strong>Michael Bayer（SQLAlchemy的作者）</strong> 也提出了一个<a href="https://review.openstack.org/#/c/527362/1/oslo_db/api.py@178" target="_blank" rel="noopener">思路</a>，就是类似于上文Top X Jitter的随机因子，我和他解释了对于死锁的重试，其实并不需要太多的基数时间，也将aws那个文章给贴上了，最终得到了他的认可。</li><li><strong>Ben Nemec (oslo的现任PTL)</strong>，认为可以通过deadlock识别以及用户手动指定两种方式来开启这个随机因子。</li><li><strong>Jay Pipes (Nova Core, MySQL Contributer)</strong>，提到了一个叫做<a href="https://github.com/jd/tenacity" target="_blank" rel="noopener">tenacity</a>的retry库，说未来也可以考虑用这个取代，库的作者还专门为这个“重试”的轮子写了一篇文章：<a href="https://julien.danjou.info/python-retrying/" target="_blank" rel="noopener">Get back up and try again: retrying in Python</a>，感兴趣的可以读读。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li>Exponential Backoff And Jitter. <a href="https://amazonaws-china.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">链接1</a> <a href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">链接2</a></li><li>Deadlocks in InnoDB <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html</a></li><li>Get back up and try again: retrying in Python <a href="https://julien.danjou.info/python-retrying/" target="_blank" rel="noopener">https://julien.danjou.info/python-retrying/</a></li><li>Improve exponential backoff for wrap_db_retry <a href="https://review.openstack.org/#/c/527362/" target="_blank" rel="noopener">https://review.openstack.org/#/c/527362/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-引言&quot;&gt;&lt;a href=&quot;#0-引言&quot; class=&quot;headerlink&quot; title=&quot;0. 引言&quot;&gt;&lt;/a&gt;0. 引言&lt;/h3&gt;&lt;p&gt;OpenStack oslo.db是OpenStack中处理DB相关功能的基础组件，基本OpenStack所有的核心组件都会使用这一基础库。&lt;/p&gt;
&lt;p&gt;去年12月，遇到一个死锁的问题 #62 &lt;a href=&quot;https://github.com/Yikun/yikun.github.com/issues/62&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个死锁问题的深入探究&lt;/a&gt;，研究了下oslo.db死锁重试的方式，发现其中并没有加入随机机制。在通信领域，有一个叫做“二进制退避机制”的算法（嗯，也算没白读了7年通信，哈哈，在本文立刻提升逼格），就是通过指数递增+随机的方式来解决无中心、多节点接入时产生的冲突的。&lt;/p&gt;
&lt;p&gt;当时，顺着这个思路，我在oslo.db中提交了一个关于改进死锁重试机制的[patch/527362]：&lt;a href=&quot;https://review.openstack.org/#/c/527362/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Improve exponential backoff for wrap_db_retry&lt;/a&gt;。4个多月后，终于合入了。写这篇文章主要是为了记录一下自己学习的过程，以及对死锁及其重试机制的思考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="数据库" scheme="http://yikun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>[Placement深度探索] Granular Resource Request Syntax</title>
    <link href="http://yikun.github.io/2018/04/02/Placement%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-Granular-Resource-Request-Syntax/"/>
    <id>http://yikun.github.io/2018/04/02/Placement深度探索-Granular-Resource-Request-Syntax/</id>
    <published>2018-04-02T02:54:51.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a>1. 问题背景</h3><p>在进行资源请求的时候，由于目前支持的能力有限，我们目前只能请求一个单一类型包含整数数量的资源。</p><p>例如，我们请求VCPU为2，内存为2G，要求其架构为X86架构，即通过以下URL进行请求：</p><blockquote><p>GET /allocation_candidates?resources=VCPU:2,MEMORY_MB:2048&amp;required=HW_CPU_X86_AVX</p></blockquote><p>也不能指定我们需要某一个RP具有某种特质，所有不同类型的资源也只能从一个RP提供。</p><a id="more"></a><p>但是，在进行一些通用和嵌套的Resource Provider时，会有诸如下列的需求：<br>Requirement 1. 根据类型、特质来请求一个allocation，根据相同类型和不同特质来请求不同的多个allocation。<br>Requirement 2. 保证指定的资源来自同一个resource provider<br>Requirement 3. 在资源有限（高饱和度）的情况下，将allocations散布到多个resource provider（多个resource provider拼凑起来）的能力。</p><p>我们通过一个例子来说下这几个场景：<br><img src="https://user-images.githubusercontent.com/1736354/38181314-c5e0d054-3664-11e8-951e-bd811909b6e2.jpg" alt="unnamed"></p><p><strong>Use Case 1</strong><br>我们希望请求一个在NET1上的VF，一个在NET2上的VF。</p><ul><li>[RP1(SRIOV_NET_VF:1), RP2(SRIOV_NET_VF:1)]</li><li>[RP1(SRIOV_NET_VF:1), RP4(SRIOV_NET_VF:1)]</li><li>[RP3(SRIOV_NET_VF:1), RP2(SRIOV_NET_VF:1)]</li><li>[RP3(SRIOV_NET_VF:1), RP4(SRIOV_NET_VF:1)]<br>那么，我们请求的时候，可以使用：</li></ul><blockquote><p>GET /allocation_candidates?resources=SRIOV_NET_VF:1&amp;resources1=SRIOV_NET_VF:1</p></blockquote><p>体现需求1要求的分组能力，在解析的时候，会将resource根据后面的number分组<br>Expect:<br>[RP1(SRIOV_NET_VF:1), RP2(SRIOV_NET_VF:1)]<br>[RP1(SRIOV_NET_VF:1), RP4(SRIOV_NET_VF:1)]<br>[RP3(SRIOV_NET_VF:1), RP2(SRIOV_NET_VF:1)]<br>[RP3(SRIOV_NET_VF:1), RP4(SRIOV_NET_VF:1)]</p><p><strong>Use Case  2</strong><br>请求一个带宽为10000 bytes/sec的vf</p><blockquote><p>GET /allocation_candidates?resources1=SRIOV_NET_VF:1,NET_EGRESS_BYTES_SEC=1</p></blockquote><p>体现需求二，来自同一个Resource Provider。每个分组，通过suffix来作为后缀，来区分resource，同一个组的资源后面number相同，期望请求同一个Resource Provider。<br>Expect:<br>[RP1(SRIOV_NET_VF:1), RP1(NET_EGRESS_BYTES_SEC:10000)]<br>[RP2(SRIOV_NET_VF:1), RP2(NET_EGRESS_BYTES_SEC:10000)]<br>[RP3(SRIOV_NET_VF:1), RP3(NET_EGRESS_BYTES_SEC:10000)]<br>[RP4(SRIOV_NET_VF:1), RP4(NET_EGRESS_BYTES_SEC:10000)]</p><p><strong>Use Case 3</strong><br>请求一个在NET1上带宽为10000bytes/sec的VF，并同时请求一个在NET2上贷款为20000bytes/sec的且网卡带有SSL加速的能力</p><blockquote><p>GET /allocation_candidates?resources1=SRIOV_NET_VF:1,NET_EGRESS_BYTES_SEC=10000<br>&amp;resource2=SRIOV_NET_VF:1,NET_EGRESS_BYTES_SEC=20000&amp;required2=HW_NIC_ACCEL_SSL</p></blockquote><p>体现了需求一和需求二，通过分组来获取不同的Resource Provider，通过同一分组编号来指定一个Resource Provider的能力。</p><ul><li>[RP1(SRIOV_NET_VF:1, NET_EGRESS_BYTES_SEC:10000), RP2(SRIOV_NET_VF:1, NET_EGRESS_BYTES_SEC:20000)]</li><li>[RP3(SRIOV_NET_VF:1, NET_EGRESS_BYTES_SEC:10000), RP2(SRIOV_NET_VF:1, NET_EGRESS_BYTES_SEC:20000)]</li></ul><p><strong>Use Case 4</strong><br>假设一个PF只剩2个VF了，请求一个NET1上4个VF。</p><blockquote><p>GET /allocation_candidates?resources=SRIOV_NET_VF:4</p></blockquote><p>体现需求三，内部会自动将4分割成2个2：<br>Expect: [RP1(SRIOV_NET_VF:2), RP3(SRIOV_NET_VF:2)]</p><h3 id="2-核心实现"><a href="#2-核心实现" class="headerlink" title="2. 核心实现"></a>2. 核心实现</h3><p>这种表达方式我们称之为“Numbered Request Groups”，名字中包含了2个重要信息，一个是“Numbered”，对请求资源进行编号，另一个是“Groups”，根据编号对请求资源进行分组.<br>形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">resources = &#123; resource_classA: rcA_count,</span><br><span class="line">              resource_classB: rcB_count,</span><br><span class="line">              ... &#125;,</span><br><span class="line">required = [ TRAIT_C, TRAIT_D, ... ],</span><br><span class="line"></span><br><span class="line">resources1 = &#123; resource_class1A: rc1A_count,</span><br><span class="line">               resource_class1B: rc1B_count,</span><br><span class="line">               ... &#125;,</span><br><span class="line">required1 = [ TRAIT_1C, TRAIT_1D, ... ],</span><br><span class="line"></span><br><span class="line">resources2 = &#123; resource_class2A: rc2A_count,</span><br><span class="line">               resource_class2B: rc2B_count,</span><br><span class="line">               ... &#125;,</span><br><span class="line">required2 = [ TRAIT_2C, TRAIT_2D, ... ],</span><br><span class="line"></span><br><span class="line">...,</span><br><span class="line"></span><br><span class="line">resourcesX = &#123; resource_classXA: rcXA_count,</span><br><span class="line">               resource_classXB: rcXB_count,</span><br><span class="line">               ... &#125;,</span><br><span class="line">requiredX = [ TRAIT_XC, TRAIT_XD, ... ],</span><br></pre></td></tr></table></figure></p><p>目前的解析部分的核心实现在<a href="https://github.com/openstack/nova/blob/master/nova/api/openstack/placement/util.py#L349-L465" target="_blank" rel="noopener">nova/api/openstack/placement/util.py#L349-L465</a>。</p><p>目前已支持的参数有resources（对inventory请求）、required（对trait请求）、member_of（对aggregate请求）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-问题背景&quot;&gt;&lt;a href=&quot;#1-问题背景&quot; class=&quot;headerlink&quot; title=&quot;1. 问题背景&quot;&gt;&lt;/a&gt;1. 问题背景&lt;/h3&gt;&lt;p&gt;在进行资源请求的时候，由于目前支持的能力有限，我们目前只能请求一个单一类型包含整数数量的资源。&lt;/p&gt;
&lt;p&gt;例如，我们请求VCPU为2，内存为2G，要求其架构为X86架构，即通过以下URL进行请求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GET /allocation_candidates?resources=VCPU:2,MEMORY_MB:2048&amp;amp;required=HW_CPU_X86_AVX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也不能指定我们需要某一个RP具有某种特质，所有不同类型的资源也只能从一个RP提供。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Nova Scheduler Team Meeting跟踪（三月）</title>
    <link href="http://yikun.github.io/2018/03/31/Nova-Scheduler-Team-Meeting%E8%B7%9F%E8%B8%AA%EF%BC%88%E4%B8%89%E6%9C%88%EF%BC%89/"/>
    <id>http://yikun.github.io/2018/03/31/Nova-Scheduler-Team-Meeting跟踪（三月）/</id>
    <published>2018-03-31T10:26:13.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018年3月5日"><a href="#2018年3月5日" class="headerlink" title="2018年3月5日"></a>2018年3月5日</h2><p>PTG刚开完，没什么太多的事儿，jaypipes说了几点：</p><ol><li>jaypipes会发一个recap总结下R版本的重点<br><a href="http://lists.openstack.org/pipermail/openstack-dev/2018-March/128041.html" target="_blank" rel="noopener">http://lists.openstack.org/pipermail/openstack-dev/2018-March/128041.html</a></li><li>最开始的3-4周，都会集中在update_provider_tree系列的patch落地</li><li>在Resource tracker刷新额外traits的合并问题需要讨论，可以在update-provider-tree完成之后去做</li></ol><h2 id="2018年3月5日-1"><a href="#2018年3月5日-1" class="headerlink" title="2018年3月5日"></a>2018年3月5日</h2><h3 id="Feature讨论"><a href="#Feature讨论" class="headerlink" title="Feature讨论"></a>Feature讨论</h3><ol><li>Support traits in Glance <a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a></li><li>Add placement-req-filter spec <a href="https://review.openstack.org/#/c/544585/" target="_blank" rel="noopener">https://review.openstack.org/#/c/544585/</a><br>这是调度流程的一个很大变化，这个BP源自CERN从v1升v2的一个需求，最开始CERN用的是Cell v1规模挺大，大概有上万个计算节点，原来的用法是：<br>第一级调度：一个租户映射到指定的特定Cell中，一般一个Cell中也会把特殊硬件的计算节点集中起来，第二级调度：这样在Cell v1中通过租户找到的Cell，然后剩余的节点就不多了，然后进行第二级调度，调度在Cell内压力就小多了。<br>但是目前Placement是一个全局的，并不能感知到Cell，也就是说最差情况，Placement过滤得不好，可能导致真正Scheduler的时候，有上万的节点，所以，就在Placment前面加了一个步骤Pre filter。目前的作用就是，把Placement做不到的，自定义程度很高的Filter放到这里来。</li><li>Forbidden Traits <a href="https://review.openstack.org/#/c/548915/" target="_blank" rel="noopener">https://review.openstack.org/#/c/548915/</a><br>required里面通过叹号来表示不想要某种traits</li><li>Support default allocation ratios <a href="https://review.openstack.org/#/c/552105/" target="_blank" rel="noopener">https://review.openstack.org/#/c/552105/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2018年3月5日&quot;&gt;&lt;a href=&quot;#2018年3月5日&quot; class=&quot;headerlink&quot; title=&quot;2018年3月5日&quot;&gt;&lt;/a&gt;2018年3月5日&lt;/h2&gt;&lt;p&gt;PTG刚开完，没什么太多的事儿，jaypipes说了几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Nova Scheduler Team Meeting跟踪（二月）</title>
    <link href="http://yikun.github.io/2018/02/07/Nova-Scheduler-Team-Meeting%E8%B7%9F%E8%B8%AA%EF%BC%88%E4%BA%8C%E6%9C%88%EF%BC%89/"/>
    <id>http://yikun.github.io/2018/02/07/Nova-Scheduler-Team-Meeting跟踪（二月）/</id>
    <published>2018-02-07T18:40:58.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-会议记录"><a href="#1-会议记录" class="headerlink" title="1. 会议记录"></a>1. 会议记录</h1><h2 id="2018年2月5日"><a href="#2018年2月5日" class="headerlink" title="2018年2月5日"></a>2018年2月5日</h2><h3 id="1-Feature讨论"><a href="#1-Feature讨论" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>目前已经Freature Freeze了，因此，对于BP来说，没有什么太多更新了，只是简单的罗列了下相关的Patch。<br><strong>Provider Tree series</strong> starting with: <a href="https://review.openstack.org/#/c/537648/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537648/</a><br><strong>Nested RP traits selection</strong>: <a href="https://review.openstack.org/#/c/531899/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531899/</a><br>目前，Nested RP的这2部分工作也不会在Queens版本合入了，会推迟到Rocky。</p><p><strong>Granular resource requests review</strong>: <a href="https://review.openstack.org/#/c/517757/" target="_blank" rel="noopener">https://review.openstack.org/#/c/517757/</a><br>resource和requeired分组的支持，API部分的PatchQueens版本未完成。</p><p><strong>Remove microversion fallback</strong>:<a href="https://review.openstack.org/#/c/528794/" target="_blank" rel="noopener">https://review.openstack.org/#/c/528794/</a><br>由于目前Queens已经使用1.14作为默认的microversion，因此，对于之前的一些兼容版本不会再使用了，所以对之前的兼容代码进行了清理。</p><p><strong>Use alternate hosts for resize</strong>:<a href="https://review.openstack.org/#/c/537614/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537614/</a><br>Alternate hosts已合入，上面是补了一些test case</p><h3 id="2-Bug讨论"><a href="#2-Bug讨论" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><h4 id="1-Generation及重试问题"><a href="#1-Generation及重试问题" class="headerlink" title="1. Generation及重试问题"></a>1. Generation及重试问题</h4><p><strong>Add generation support in aggregate association</strong> <a href="https://review.openstack.org/#/c/540447/" target="_blank" rel="noopener">https://review.openstack.org/#/c/540447/</a><br>没有什么新的bug了，在之前讨论的aggregate相关的API增加generation的问题，cdent提了一个BP，会在Rocky版本完成。<br><strong>placement server needs to retry allocations, server-side</strong> <a href="https://bugs.launchpad.net/nova/+bug/1719933" target="_blank" rel="noopener">https://bugs.launchpad.net/nova/+bug/1719933</a><br>对于并发更新时的重试问题，还是有一些讨论，<br>@edleafe 认为，对于一些场景，请求aloocation时，用户认为有足够容量呀，不能够失败。<br>@jaypipes还是原来的意见：</p><blockquote><p>it should “fail” in so much as a 409 Conflict is returned and allows the caller to retry if it wants.</p></blockquote><p>也就是说，409肯定是要失败，重试的事情需要调用他的人来做。<br>当然，也会在PTG讨论下，generation到底怎么样去使用和暴露。已经把这个问题记到<a href="https://etherpad.openstack.org/p/nova-ptg-rocky" target="_blank" rel="noopener">nova-ptg-rocky</a>：Do we have a concurrency problem with PUT /allocations/{consumer_uuid} and/or POST /allocations ?</p><h3 id="3-开放讨论"><a href="#3-开放讨论" class="headerlink" title="(3) 开放讨论"></a>(3) 开放讨论</h3><p>Placement queens summary <a href="https://anticdent.org/placement-queens-summary.html" target="_blank" rel="noopener">https://anticdent.org/placement-queens-summary.html</a><br>Placement extraction <a href="https://anticdent.org/placement-extraction.html" target="_blank" rel="noopener">https://anticdent.org/placement-extraction.html</a></p><h4 id="关于将Placement抽离"><a href="#关于将Placement抽离" class="headerlink" title="关于将Placement抽离"></a>关于将Placement抽离</h4><p>@cdent 完成了两篇文章，一个是queens版本的placement总结，另外一个是cdent做的，关于将Placement从Nova抽离出来的一些工作。<br>关于将Placement抽离出来，大家发表了自己的看法：<br>@cdent 他认为，较早的把Placement分离出来，对于Placement和Nova来说都好，目前抽离的工作量比较小，好分离，另外，目前Nova投入的大量的时间和优先级放在Placement相关的事务上，分离出来，对Nova好一些。<br>@bauzas 不太同意现在去分离，他主要是担心Nova和Placement分离后，有点难协调。</p><h2 id="2018年2月12日"><a href="#2018年2月12日" class="headerlink" title="2018年2月12日"></a>2018年2月12日</h2><h3 id="1-Feature讨论-1"><a href="#1-Feature讨论-1" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>目前的Feature的讨论，已经开始Rocky版本的了。</p><h4 id="1-Support-traits-in-Glance"><a href="#1-Support-traits-in-Glance" class="headerlink" title="1. Support traits in Glance"></a>1. Support traits in Glance</h4><p><a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a><br>这个BP主要是希望为Glance增加Traits支持，在Glance的Properties中，增加类似”trait:HW_CPU_X86_AVX2=required”, “trait:CUSTOM_TRUSTED_HOST=required”的支持，让Placement调度的时候支持。</p><h4 id="2-Resource-Class-Affinity-Spec"><a href="#2-Resource-Class-Affinity-Spec" class="headerlink" title="2. Resource Class Affinity Spec"></a>2. Resource Class Affinity Spec</h4><p><a href="https://review.openstack.org/543062" target="_blank" rel="noopener">https://review.openstack.org/543062</a><br>efried写的一个bp，看名字知其意，调度的时候考虑Resouce Class的亲和。</p><h3 id="2-bug讨论"><a href="#2-bug讨论" class="headerlink" title="(2) bug讨论"></a>(2) bug讨论</h3><p><strong>Handle volume-backed instances in IsolatedHostsFilter</strong>：<a href="https://review.openstack.org/#/q/topic:bug/1746483+(status:open+OR+status:merged)" target="_blank" rel="noopener">https://review.openstack.org/#/q/topic:bug/1746483+(status:open+OR+status:merged)</a><br>Matt发现了一个Filter的问题，主要是对volume-backed的情况进行一些异常处理。在Scheduler会议中，已经很久没有讨论过非Placement的问题。- -!</p><h3 id="3-开放讨论-1"><a href="#3-开放讨论-1" class="headerlink" title="(3) 开放讨论"></a>(3) 开放讨论</h3><p><strong>Add optional healthcheck middleware</strong> <a href="https://review.openstack.org/#/c/542992/" target="_blank" rel="noopener">https://review.openstack.org/#/c/542992/</a><br>一个用于健康检查的midleware，对于API服务挺有用，尤其是对于LB场景下的检查活跃来说。<br>Feature的spec在这里：<a href="https://review.openstack.org/#/c/531456/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531456/</a></p><h2 id="2018年2月19日"><a href="#2018年2月19日" class="headerlink" title="2018年2月19日"></a>2018年2月19日</h2><h3 id="1-Feature讨论-2"><a href="#1-Feature讨论-2" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>Glance image traits <a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a><br>Resource class的亲和性 至少到S版本才会落（包括在Placement中支持NUMA亲和），优先级不高，提了下Placement RBAC的需求(Policy/RBAC support in Placement REST API)可能会更高一些。<br>update provider tree的优先级很高解决了很多问题</p><h3 id="2-Bug讨论-1"><a href="#2-Bug讨论-1" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><p><strong>Placement returns 503 when Keystone is down</strong> <a href="https://bugs.launchpad.net/nova/+bug/1749797" target="_blank" rel="noopener">https://bugs.launchpad.net/nova/+bug/1749797</a><br>Keystone挂的时候，Placement会返回一个503，这个问题最后是在keystone middleware里面加了一些detail信息: <a href="https://review.openstack.org/546108" target="_blank" rel="noopener">https://review.openstack.org/546108</a></p><h3 id="3-开放讨论-2"><a href="#3-开放讨论-2" class="headerlink" title="(3)开放讨论"></a>(3)开放讨论</h3><p><strong>调度失败的”Nova valid host”足够了吗？</strong><br>@arvindn05 这哥们提到在虚拟机调度的时候，我们仅仅返回了”no valid host”，为啥不503一个，然后返回为啥调度失败。<br>@edleafe 说了2点，503肯定不合适，错误是用户，不是系统。详细信息不显示是因为不想把底层的硬件架构拓扑之类的信息暴露给用户。管理员可以通过日志之类的看到失败原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-会议记录&quot;&gt;&lt;a href=&quot;#1-会议记录&quot; class=&quot;headerlink&quot; title=&quot;1. 会议记录&quot;&gt;&lt;/a&gt;1. 会议记录&lt;/h1&gt;&lt;h2 id=&quot;2018年2月5日&quot;&gt;&lt;a href=&quot;#2018年2月5日&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Nova Scheduler Team Meeting跟踪（一月）</title>
    <link href="http://yikun.github.io/2018/02/01/Nova-Scheduler-Team-Meeting%E8%B7%9F%E8%B8%AA%EF%BC%88%E4%B8%80%E6%9C%88%EF%BC%89/"/>
    <id>http://yikun.github.io/2018/02/01/Nova-Scheduler-Team-Meeting跟踪（一月）/</id>
    <published>2018-02-01T20:32:51.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>从今年开始，要细度每次的Nova Meeting了，确实对于整体把握整体社区某个领域的进度非常有用。我是这样设想的，按月汇总，每次一篇文章，包含以下几部分</p><ol><li><strong>记录</strong>。按照meeting日期，记录主要内容</li><li><strong>总结</strong>。总结每次meeting的每次内容，简短的一句话或者一段话，避免流水账</li><li><strong>TODO</strong>。每次meeting不一定能完全理解，把他们记录下来，学习后闭环。</li></ol><h1 id="1-会议记录"><a href="#1-会议记录" class="headerlink" title="1. 会议记录"></a>1. 会议记录</h1><h2 id="2018年1月8日"><a href="#2018年1月8日" class="headerlink" title="2018年1月8日"></a>2018年1月8日</h2><p>2018年的第一个team meeting，我们可以看到重点的工作还是在Nested Resource Provider这个BP，在这个时间，大家还是希望能够把Nested Resource Provider这个BP在Queens版本完成。</p><h3 id="1-Feature讨论"><a href="#1-Feature讨论" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Provider"><a href="#1-Nested-Resource-Provider" class="headerlink" title="1. Nested Resource Provider"></a>1. Nested Resource Provider</h4><ul><li>@2uasimojo(efried) 正在完成ComputeDriver.update_provider_tree() <a href="https://review.openstack.org/#/c/521685/" target="_blank" rel="noopener">https://review.openstack.org/#/c/521685/</a></li><li>@jaypipes 正在完成GET /allocation_candidates部分 <a href="https://review.openstack.org/#/c/531443/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531443/</a><br>@bauzas 表示Xen可能是Nested Resource Provider最棒的目标用户。</li></ul><p>@jaypipes </p><ul><li>目前NRP的目标还是Queens版本完成，可以把NRP的report部分、candidates部分、xen作为client/consumer在Queens完成</li><li>而NUMA/PCI部分的工作，估计搞不定，所以意味着我们在Queens还是需要PciPassthroughFilter及NUMATopologyFilter</li><li>driver consumption的工作会在Queens完成，包括driver通过update_provider_tree来上报信息给RP，也包括了从scheduler中基于allocation来做设备的创建和分配。</li></ul><h4 id="2-Alternate-hosts"><a href="#2-Alternate-hosts" class="headerlink" title="2. Alternate hosts"></a>2. Alternate hosts</h4><p>解决了一个<a href="https://launchpad.net/bugs/1741125" target="_blank" rel="noopener">bug/1741125 Instance resize intermittently fails when rescheduling</a><br><a href="https://review.openstack.org/#/c/531022/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531022/</a></p><h4 id="3-limit-on-allocation-candidates"><a href="#3-limit-on-allocation-candidates" class="headerlink" title="3. limit on allocation_candidates"></a>3. limit on allocation_candidates</h4><p>dansmith增加了一个CONF.scheduler.max_placement_results，用于限制每次备选节点的请求，默认1000<br><a href="https://review.openstack.org/#/c/531517/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531517/</a></p><h3 id="2-Open-discussion"><a href="#2-Open-discussion" class="headerlink" title="(2) Open discussion"></a>(2) Open discussion</h3><h4 id="关于Resource-Provider的genration-id的讨论。"><a href="#关于Resource-Provider的genration-id的讨论。" class="headerlink" title="关于Resource Provider的genration id的讨论。"></a>关于Resource Provider的genration id的讨论。</h4><p>在随后的开放讨论中，由于Resource Provider的aggregate信息在更新时，会有在不同节点上的多个请求并发进行更新的问题，我们需要一种方案去解决race conditions。是的，就是我们在 #65 提到的方法。</p><p>@2uasimojo(efried) 提到，这种方案并不是进程或者线程的锁，建议按照原来的实现，给更新RP的aggregate加上genration id，用于解决并发下的竞态更新问题。<br>即在PUT的时候，用户需要传入genration id，这个id就是Get时候的genration id。这种方案看似有点土，我更新个字段还得自己传genration，太不方便了。<br>但是，却是一种很好的方法来解决从Get直到PUT入库中间的竞争。<br>大家对这点，达成了一致，另外，我们在更新rp的aggregate的时候，仅更新正更新的rp的generation，而不需要更新aggregate中其他rp的genration。</p><p>最终，决定让 @cdent 去做generations-on-aggregate placement microversion相关的patch。</p><h4 id="关于conflict-409后重试机制的讨论"><a href="#关于conflict-409后重试机制的讨论" class="headerlink" title="关于conflict 409后重试机制的讨论"></a>关于conflict 409后重试机制的讨论</h4><p>@2uasimojo(efried) 提出了这个问题，对于409的处理，一直不是很清晰，因为我们重试的时候，不知道到底应该是仅仅重试之前的操作，还是说再看看这个数据是不是已经更新之类的。</p><p>@jaypipes 说，发生409后，更新的调用者，需要回答一个问题“OK，我们需要更新的东西已经变了，在我进行重试时，检查一下我想要更新的东西是否已经更新过了”，所有的generation变化，只是表达了“something changed”，而不是“this thins changed”。所以在我们进行409的重试时，我们需要重读下所有的provider信息（比如traits、inventory等），然后检查下，我们想更新的东西是否已经存在了，如果是这样的话，我们什么都不做，如果没有，我们需要重新的调用update/set。<br>这个想要更新的状态取决于virt driver，和他希望做什么。（比如更新inventory和traits肯定是不一样的）。<br>总结来说，就是我们最初的设计：client-driven state retries，而不是傻傻的重试。</p><p>本次Meeting总的来说还是充满干货的，尤其是对generation和409重试的讨论。</p><h2 id="2018年1月15日"><a href="#2018年1月15日" class="headerlink" title="2018年1月15日"></a>2018年1月15日</h2><h3 id="1-Feature讨论-1"><a href="#1-Feature讨论-1" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers"><a href="#1-Nested-Resource-Providers" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>NRP的进度没有太大进展，目前包含update_provider_tree和GET /allocation_candidates两部分内容。</p><h4 id="2-Granular-resource-requests"><a href="#2-Granular-resource-requests" class="headerlink" title="2. Granular resource requests"></a>2. Granular resource requests</h4><p>这个是为了支持用户进行复杂资源请求的bp，最近会专门写一个文章记录一下其实现。</p><h4 id="3-Alternate-Hosts"><a href="#3-Alternate-Hosts" class="headerlink" title="3. Alternate Hosts"></a>3. Alternate Hosts</h4><p>目前这个特性基本完成了，相关Patch：<br><a href="https://review.openstack.org/#/c/526436" target="_blank" rel="noopener">patch/526436</a> Change compute RPC to use alternates for resize</p><h3 id="2-Bug讨论"><a href="#2-Bug讨论" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><p><a href="https://bugs.launchpad.net/nova/+bug/1743120" target="_blank" rel="noopener">bug/1743120</a>: placement inadvertently imports many python modules it does not need<br>这个bug主要是说Placement导入了很多不需要的模块，主要是和Nova耦合太近，不利于后面拆分，并且直接使用Nova的也不够简洁。所以，清理、化简，保持干净。</p><h3 id="Open-discussion"><a href="#Open-discussion" class="headerlink" title="Open discussion"></a>Open discussion</h3><h4 id="ProviderTree-accessors"><a href="#ProviderTree-accessors" class="headerlink" title="ProviderTree accessors"></a>ProviderTree accessors</h4><p>Patch在这里：<a href="https://review.openstack.org/#/c/533244" target="_blank" rel="noopener">https://review.openstack.org/#/c/533244</a><br>主要为了对比ComputeDriver.update_provider_tree和缓存在report client的ProviderTree的变化。抽象出来了一个结构ProviderData，专门来返回数据。</p><p>总的来说，本次Meeting的讨论内容较少，集中在Nested Resource Provider上面。</p><h2 id="2018年1月22日"><a href="#2018年1月22日" class="headerlink" title="2018年1月22日"></a>2018年1月22日</h2><p>重要事件：1月25日，Queens版本的Feature Freeze即将到来。</p><h3 id="1-Feature讨论-2"><a href="#1-Feature讨论-2" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers-1"><a href="#1-Nested-Resource-Providers-1" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>目前还是包括update_provider_tree series和Nested RP selection两部分。update_provider_tree series接近完成了（不包括resource tracker端到端的上报），Nested RP selection，会推到Rocky版本。</p><h4 id="2-Request-Traits-in-Nova"><a href="#2-Request-Traits-in-Nova" class="headerlink" title="2. Request Traits in Nova"></a>2. Request Traits in Nova</h4><p>Nova中支持请求traits，另外这个请求也额外的提到了Granular resource requests特性，有部分功能是重合的，后续分析Granular resource requests时候，重点关注下。</p><h4 id="3-Use-alternate-hosts-for-resize"><a href="#3-Use-alternate-hosts-for-resize" class="headerlink" title="3. Use alternate hosts for resize"></a>3. Use alternate hosts for resize</h4><p>Alternate hosts这个bp已经基本完成，后续也需要学习下。</p><h3 id="2-Bug讨论-1"><a href="#2-Bug讨论-1" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><h4 id="Remove-microversion-fallback-code-from-report-client"><a href="#Remove-microversion-fallback-code-from-report-client" class="headerlink" title="Remove microversion fallback code from report client"></a>Remove microversion fallback code from report client</h4><p><a href="https://review.openstack.org/#/c/528794/" target="_blank" rel="noopener">https://review.openstack.org/#/c/528794/</a> 在Queens版本，nova默认支持1.14了，所以移除了一些之前版本的兼容代码。</p><h2 id="2018年1月29日"><a href="#2018年1月29日" class="headerlink" title="2018年1月29日"></a>2018年1月29日</h2><h3 id="1-Feature讨论-3"><a href="#1-Feature讨论-3" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers-2"><a href="#1-Nested-Resource-Providers-2" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>Provider Tree series部分的工作已完成，<a href="https://review.openstack.org/#/c/533808/" target="_blank" rel="noopener">https://review.openstack.org/#/c/533808/</a><br> First provider tree patch in progress： <a href="https://review.openstack.org/#/c/537648/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537648/</a> 这部分是端到端的从resource tracker中调用driver的update tree，应该会推到Rocky去做<br>Nested RP traits selection: <a href="https://review.openstack.org/#/c/531899/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531899/</a> 没有什么进展<br>从开放讨论中，@efried 提到，想要端到端的使用NRP，需要完成三部分：a. Resource Tracker刷新update_provider_tree b. jaypieps的NRP in alloc cands c. driver实现update_provider_tree。这三项工作，都没有在Queens完成，不过都比较接近完成了。</p><h4 id="2-Singular-request-group-traits"><a href="#2-Singular-request-group-traits" class="headerlink" title="2. Singular request group traits"></a>2. Singular request group traits</h4><p>基本完成</p><h4 id="3-Granular-resource-requests"><a href="#3-Granular-resource-requests" class="headerlink" title="3. Granular resource requests"></a>3. Granular resource requests</h4><p>完整实现推迟到Queens版本，<a href="https://review.openstack.org/#/c/517757/" target="_blank" rel="noopener">https://review.openstack.org/#/c/517757/</a></p><h4 id="4-Use-alternate-hosts-for-resize"><a href="#4-Use-alternate-hosts-for-resize" class="headerlink" title="4. Use alternate hosts for resize"></a>4. Use alternate hosts for resize</h4><p><a href="https://review.openstack.org/#/c/537614/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537614/</a> 已经merge，至此，已经可以支持resize时候的alternate hostsl了</p><h3 id="2-开放讨论"><a href="#2-开放讨论" class="headerlink" title="(2) 开放讨论"></a>(2) 开放讨论</h3><h4 id="1-Idea-for-a-simple-way-to-expose-compute-driver-capabilities-in-the-REST-API"><a href="#1-Idea-for-a-simple-way-to-expose-compute-driver-capabilities-in-the-REST-API" class="headerlink" title="1. Idea for a simple way to expose compute driver capabilities in the REST API"></a>1. Idea for a simple way to expose compute driver capabilities in the REST API</h4><p><a href="http://lists.openstack.org/pipermail/openstack-dev/2018-January/126653.html" target="_blank" rel="noopener">http://lists.openstack.org/pipermail/openstack-dev/2018-January/126653.html</a> Matt提出希望用一种简单方法保持driver的兼容</p><h1 id="2-TODO"><a href="#2-TODO" class="headerlink" title="2. TODO"></a>2. TODO</h1><ol><li>了解Idea for a simple way to expose compute driver capabilities in the REST API详细内容</li><li>Granular resource requests分析</li><li>Alternate hosts分析</li><li>Nested Resource Provider分析</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从今年开始，要细度每次的Nova Meeting了，确实对于整体把握整体社区某个领域的进度非常有用。我是这样设想的，按月汇总，每次一篇文章，包含以下几部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;记录&lt;/strong&gt;。按照meeting日期，记录主要内容&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Nova Scheduler Team Meeting跟踪</title>
    <link href="http://yikun.github.io/2018/02/01/Nova-Scheduler-Team-Meeting%E8%B7%9F%E8%B8%AA/"/>
    <id>http://yikun.github.io/2018/02/01/Nova-Scheduler-Team-Meeting跟踪/</id>
    <published>2018-02-01T12:32:51.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>从今年开始，要细度每次的Nova Meeting了，确实对于整体把握整体社区某个领域的进度非常有用。我是这样设想的，按月汇总，每次一篇文章，包含以下几部分</p><ol><li><strong>记录</strong>。按照meeting日期，记录主要内容</li><li><strong>总结</strong>。总结每次meeting的每次内容，简短的一句话或者一段话，避免流水账</li><li><strong>TODO</strong>。每次meeting不一定能完全理解，把他们记录下来，学习后闭环。</li></ol><h1 id="1-会议记录"><a href="#1-会议记录" class="headerlink" title="1. 会议记录"></a>1. 会议记录</h1><h2 id="2018年1月8日"><a href="#2018年1月8日" class="headerlink" title="2018年1月8日"></a>2018年1月8日</h2><p>2018年的第一个team meeting，我们可以看到重点的工作还是在Nested Resource Provider这个BP，在这个时间，大家还是希望能够把Nested Resource Provider这个BP在Queens版本完成。</p><h3 id="1-Feature讨论"><a href="#1-Feature讨论" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Provider"><a href="#1-Nested-Resource-Provider" class="headerlink" title="1. Nested Resource Provider"></a>1. Nested Resource Provider</h4><ul><li>@2uasimojo(efried) 正在完成ComputeDriver.update_provider_tree() <a href="https://review.openstack.org/#/c/521685/" target="_blank" rel="noopener">https://review.openstack.org/#/c/521685/</a></li><li>@jaypipes 正在完成GET /allocation_candidates部分 <a href="https://review.openstack.org/#/c/531443/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531443/</a><br>@bauzas 表示Xen可能是Nested Resource Provider最棒的目标用户。</li></ul><p>@jaypipes </p><ul><li>目前NRP的目标还是Queens版本完成，可以把NRP的report部分、candidates部分、xen作为client/consumer在Queens完成</li><li>而NUMA/PCI部分的工作，估计搞不定，所以意味着我们在Queens还是需要PciPassthroughFilter及NUMATopologyFilter</li><li>driver consumption的工作会在Queens完成，包括driver通过update_provider_tree来上报信息给RP，也包括了从scheduler中基于allocation来做设备的创建和分配。</li></ul><h4 id="2-Alternate-hosts"><a href="#2-Alternate-hosts" class="headerlink" title="2. Alternate hosts"></a>2. Alternate hosts</h4><p>解决了一个<a href="https://launchpad.net/bugs/1741125" target="_blank" rel="noopener">bug/1741125 Instance resize intermittently fails when rescheduling</a><br><a href="https://review.openstack.org/#/c/531022/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531022/</a></p><h4 id="3-limit-on-allocation-candidates"><a href="#3-limit-on-allocation-candidates" class="headerlink" title="3. limit on allocation_candidates"></a>3. limit on allocation_candidates</h4><p>dansmith增加了一个CONF.scheduler.max_placement_results，用于限制每次备选节点的请求，默认1000<br><a href="https://review.openstack.org/#/c/531517/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531517/</a></p><h3 id="2-Open-discussion"><a href="#2-Open-discussion" class="headerlink" title="(2) Open discussion"></a>(2) Open discussion</h3><h4 id="关于Resource-Provider的genration-id的讨论。"><a href="#关于Resource-Provider的genration-id的讨论。" class="headerlink" title="关于Resource Provider的genration id的讨论。"></a>关于Resource Provider的genration id的讨论。</h4><p>在随后的开放讨论中，由于Resource Provider的aggregate信息在更新时，会有在不同节点上的多个请求并发进行更新的问题，我们需要一种方案去解决race conditions。是的，就是我们在 #65 提到的方法。</p><p>@2uasimojo(efried) 提到，这种方案并不是进程或者线程的锁，建议按照原来的实现，给更新RP的aggregate加上genration id，用于解决并发下的竞态更新问题。<br>即在PUT的时候，用户需要传入genration id，这个id就是Get时候的genration id。这种方案看似有点土，我更新个字段还得自己传genration，太不方便了。<br>但是，却是一种很好的方法来解决从Get直到PUT入库中间的竞争。<br>大家对这点，达成了一致，另外，我们在更新rp的aggregate的时候，仅更新正更新的rp的generation，而不需要更新aggregate中其他rp的genration。</p><p>最终，决定让 @cdent 去做generations-on-aggregate placement microversion相关的patch。</p><h4 id="关于conflict-409后重试机制的讨论"><a href="#关于conflict-409后重试机制的讨论" class="headerlink" title="关于conflict 409后重试机制的讨论"></a>关于conflict 409后重试机制的讨论</h4><p>@2uasimojo(efried) 提出了这个问题，对于409的处理，一直不是很清晰，因为我们重试的时候，不知道到底应该是仅仅重试之前的操作，还是说再看看这个数据是不是已经更新之类的。</p><p>@jaypipes 说，发生409后，更新的调用者，需要回答一个问题“OK，我们需要更新的东西已经变了，在我进行重试时，检查一下我想要更新的东西是否已经更新过了”，所有的generation变化，只是表达了“something changed”，而不是“this thins changed”。所以在我们进行409的重试时，我们需要重读下所有的provider信息（比如traits、inventory等），然后检查下，我们想更新的东西是否已经存在了，如果是这样的话，我们什么都不做，如果没有，我们需要重新的调用update/set。<br>这个想要更新的状态取决于virt driver，和他希望做什么。（比如更新inventory和traits肯定是不一样的）。<br>总结来说，就是我们最初的设计：client-driven state retries，而不是傻傻的重试。</p><p>本次Meeting总的来说还是充满干货的，尤其是对generation和409重试的讨论。</p><h2 id="2018年1月15日"><a href="#2018年1月15日" class="headerlink" title="2018年1月15日"></a>2018年1月15日</h2><h3 id="1-Feature讨论-1"><a href="#1-Feature讨论-1" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers"><a href="#1-Nested-Resource-Providers" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>NRP的进度没有太大进展，目前包含update_provider_tree和GET /allocation_candidates两部分内容。</p><h4 id="2-Granular-resource-requests"><a href="#2-Granular-resource-requests" class="headerlink" title="2. Granular resource requests"></a>2. Granular resource requests</h4><p>这个是为了支持用户进行复杂资源请求的bp，最近会专门写一个文章记录一下其实现。</p><h4 id="3-Alternate-Hosts"><a href="#3-Alternate-Hosts" class="headerlink" title="3. Alternate Hosts"></a>3. Alternate Hosts</h4><p>目前这个特性基本完成了，相关Patch：<br><a href="https://review.openstack.org/#/c/526436" target="_blank" rel="noopener">patch/526436</a> Change compute RPC to use alternates for resize</p><h3 id="2-Bug讨论"><a href="#2-Bug讨论" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><p><a href="https://bugs.launchpad.net/nova/+bug/1743120" target="_blank" rel="noopener">bug/1743120</a>: placement inadvertently imports many python modules it does not need<br>这个bug主要是说Placement导入了很多不需要的模块，主要是和Nova耦合太近，不利于后面拆分，并且直接使用Nova的也不够简洁。所以，清理、化简，保持干净。</p><h3 id="Open-discussion"><a href="#Open-discussion" class="headerlink" title="Open discussion"></a>Open discussion</h3><h4 id="ProviderTree-accessors"><a href="#ProviderTree-accessors" class="headerlink" title="ProviderTree accessors"></a>ProviderTree accessors</h4><p>Patch在这里：<a href="https://review.openstack.org/#/c/533244" target="_blank" rel="noopener">https://review.openstack.org/#/c/533244</a><br>主要为了对比ComputeDriver.update_provider_tree和缓存在report client的ProviderTree的变化。抽象出来了一个结构ProviderData，专门来返回数据。</p><p>总的来说，本次Meeting的讨论内容较少，集中在Nested Resource Provider上面。</p><h2 id="2018年1月22日"><a href="#2018年1月22日" class="headerlink" title="2018年1月22日"></a>2018年1月22日</h2><p>重要事件：1月25日，Queens版本的Feature Freeze即将到来。</p><h3 id="1-Feature讨论-2"><a href="#1-Feature讨论-2" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers-1"><a href="#1-Nested-Resource-Providers-1" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>目前还是包括update_provider_tree series和Nested RP selection两部分。update_provider_tree series接近完成了（不包括resource tracker端到端的上报），Nested RP selection，会推到Rocky版本。</p><h4 id="2-Request-Traits-in-Nova"><a href="#2-Request-Traits-in-Nova" class="headerlink" title="2. Request Traits in Nova"></a>2. Request Traits in Nova</h4><p>Nova中支持请求traits，另外这个请求也额外的提到了Granular resource requests特性，有部分功能是重合的，后续分析Granular resource requests时候，重点关注下。</p><h4 id="3-Use-alternate-hosts-for-resize"><a href="#3-Use-alternate-hosts-for-resize" class="headerlink" title="3. Use alternate hosts for resize"></a>3. Use alternate hosts for resize</h4><p>Alternate hosts这个bp已经基本完成，后续也需要学习下。</p><h3 id="2-Bug讨论-1"><a href="#2-Bug讨论-1" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><h4 id="Remove-microversion-fallback-code-from-report-client"><a href="#Remove-microversion-fallback-code-from-report-client" class="headerlink" title="Remove microversion fallback code from report client"></a>Remove microversion fallback code from report client</h4><p><a href="https://review.openstack.org/#/c/528794/" target="_blank" rel="noopener">https://review.openstack.org/#/c/528794/</a> 在Queens版本，nova默认支持1.14了，所以移除了一些之前版本的兼容代码。</p><h2 id="2018年1月29日"><a href="#2018年1月29日" class="headerlink" title="2018年1月29日"></a>2018年1月29日</h2><h3 id="1-Feature讨论-3"><a href="#1-Feature讨论-3" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><h4 id="1-Nested-Resource-Providers-2"><a href="#1-Nested-Resource-Providers-2" class="headerlink" title="1. Nested Resource Providers"></a>1. Nested Resource Providers</h4><p>Provider Tree series部分的工作已完成，<a href="https://review.openstack.org/#/c/533808/" target="_blank" rel="noopener">https://review.openstack.org/#/c/533808/</a><br> First provider tree patch in progress： <a href="https://review.openstack.org/#/c/537648/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537648/</a> 这部分是端到端的从resource tracker中调用driver的update tree，应该会推到Rocky去做<br>Nested RP traits selection: <a href="https://review.openstack.org/#/c/531899/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531899/</a> 没有什么进展<br>从开放讨论中，@efried 提到，想要端到端的使用NRP，需要完成三部分：a. Resource Tracker刷新update_provider_tree b. jaypieps的NRP in alloc cands c. driver实现update_provider_tree。这三项工作，都没有在Queens完成，不过都比较接近完成了。</p><h4 id="2-Singular-request-group-traits"><a href="#2-Singular-request-group-traits" class="headerlink" title="2. Singular request group traits"></a>2. Singular request group traits</h4><p>基本完成</p><h4 id="3-Granular-resource-requests"><a href="#3-Granular-resource-requests" class="headerlink" title="3. Granular resource requests"></a>3. Granular resource requests</h4><p>完整实现推迟到Queens版本，<a href="https://review.openstack.org/#/c/517757/" target="_blank" rel="noopener">https://review.openstack.org/#/c/517757/</a></p><h4 id="4-Use-alternate-hosts-for-resize"><a href="#4-Use-alternate-hosts-for-resize" class="headerlink" title="4. Use alternate hosts for resize"></a>4. Use alternate hosts for resize</h4><p><a href="https://review.openstack.org/#/c/537614/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537614/</a> 已经merge，至此，已经可以支持resize时候的alternate hostsl了</p><h3 id="2-开放讨论"><a href="#2-开放讨论" class="headerlink" title="(2) 开放讨论"></a>(2) 开放讨论</h3><h4 id="1-Idea-for-a-simple-way-to-expose-compute-driver-capabilities-in-the-REST-API"><a href="#1-Idea-for-a-simple-way-to-expose-compute-driver-capabilities-in-the-REST-API" class="headerlink" title="1. Idea for a simple way to expose compute driver capabilities in the REST API"></a>1. Idea for a simple way to expose compute driver capabilities in the REST API</h4><p><a href="http://lists.openstack.org/pipermail/openstack-dev/2018-January/126653.html" target="_blank" rel="noopener">http://lists.openstack.org/pipermail/openstack-dev/2018-January/126653.html</a> Matt提出希望用一种简单方法保持driver的兼容</p><h1 id="1-会议记录-1"><a href="#1-会议记录-1" class="headerlink" title="1. 会议记录"></a>1. 会议记录</h1><h2 id="2018年2月5日"><a href="#2018年2月5日" class="headerlink" title="2018年2月5日"></a>2018年2月5日</h2><h3 id="1-Feature讨论-4"><a href="#1-Feature讨论-4" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>目前已经Freature Freeze了，因此，对于BP来说，没有什么太多更新了，只是简单的罗列了下相关的Patch。<br><strong>Provider Tree series</strong> starting with: <a href="https://review.openstack.org/#/c/537648/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537648/</a><br><strong>Nested RP traits selection</strong>: <a href="https://review.openstack.org/#/c/531899/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531899/</a><br>目前，Nested RP的这2部分工作也不会在Queens版本合入了，会推迟到Rocky。</p><p><strong>Granular resource requests review</strong>: <a href="https://review.openstack.org/#/c/517757/" target="_blank" rel="noopener">https://review.openstack.org/#/c/517757/</a><br>resource和requeired分组的支持，API部分的PatchQueens版本未完成。</p><p><strong>Remove microversion fallback</strong>:<a href="https://review.openstack.org/#/c/528794/" target="_blank" rel="noopener">https://review.openstack.org/#/c/528794/</a><br>由于目前Queens已经使用1.14作为默认的microversion，因此，对于之前的一些兼容版本不会再使用了，所以对之前的兼容代码进行了清理。</p><p><strong>Use alternate hosts for resize</strong>:<a href="https://review.openstack.org/#/c/537614/" target="_blank" rel="noopener">https://review.openstack.org/#/c/537614/</a><br>Alternate hosts已合入，上面是补了一些test case</p><h3 id="2-Bug讨论-2"><a href="#2-Bug讨论-2" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><h4 id="1-Generation及重试问题"><a href="#1-Generation及重试问题" class="headerlink" title="1. Generation及重试问题"></a>1. Generation及重试问题</h4><p><strong>Add generation support in aggregate association</strong> <a href="https://review.openstack.org/#/c/540447/" target="_blank" rel="noopener">https://review.openstack.org/#/c/540447/</a><br>没有什么新的bug了，在之前讨论的aggregate相关的API增加generation的问题，cdent提了一个BP，会在Rocky版本完成。<br><strong>placement server needs to retry allocations, server-side</strong> <a href="https://bugs.launchpad.net/nova/+bug/1719933" target="_blank" rel="noopener">https://bugs.launchpad.net/nova/+bug/1719933</a><br>对于并发更新时的重试问题，还是有一些讨论，<br>@edleafe 认为，对于一些场景，请求aloocation时，用户认为有足够容量呀，不能够失败。<br>@jaypipes还是原来的意见：</p><blockquote><p>it should “fail” in so much as a 409 Conflict is returned and allows the caller to retry if it wants.</p></blockquote><p>也就是说，409肯定是要失败，重试的事情需要调用他的人来做。<br>当然，也会在PTG讨论下，generation到底怎么样去使用和暴露。已经把这个问题记到<a href="https://etherpad.openstack.org/p/nova-ptg-rocky" target="_blank" rel="noopener">nova-ptg-rocky</a>：Do we have a concurrency problem with PUT /allocations/{consumer_uuid} and/or POST /allocations ?</p><h3 id="3-开放讨论"><a href="#3-开放讨论" class="headerlink" title="(3) 开放讨论"></a>(3) 开放讨论</h3><p>Placement queens summary <a href="https://anticdent.org/placement-queens-summary.html" target="_blank" rel="noopener">https://anticdent.org/placement-queens-summary.html</a><br>Placement extraction <a href="https://anticdent.org/placement-extraction.html" target="_blank" rel="noopener">https://anticdent.org/placement-extraction.html</a></p><h4 id="关于将Placement抽离"><a href="#关于将Placement抽离" class="headerlink" title="关于将Placement抽离"></a>关于将Placement抽离</h4><p>@cdent 完成了两篇文章，一个是queens版本的placement总结，另外一个是cdent做的，关于将Placement从Nova抽离出来的一些工作。<br>关于将Placement抽离出来，大家发表了自己的看法：<br>@cdent 他认为，较早的把Placement分离出来，对于Placement和Nova来说都好，目前抽离的工作量比较小，好分离，另外，目前Nova投入的大量的时间和优先级放在Placement相关的事务上，分离出来，对Nova好一些。<br>@bauzas 不太同意现在去分离，他主要是担心Nova和Placement分离后，有点难协调。</p><h2 id="2018年2月12日"><a href="#2018年2月12日" class="headerlink" title="2018年2月12日"></a>2018年2月12日</h2><h3 id="1-Feature讨论-5"><a href="#1-Feature讨论-5" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>目前的Feature的讨论，已经开始Rocky版本的了。</p><h4 id="1-Support-traits-in-Glance"><a href="#1-Support-traits-in-Glance" class="headerlink" title="1. Support traits in Glance"></a>1. Support traits in Glance</h4><p><a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a><br>这个BP主要是希望为Glance增加Traits支持，在Glance的Properties中，增加类似”trait:HW_CPU_X86_AVX2=required”, “trait:CUSTOM_TRUSTED_HOST=required”的支持，让Placement调度的时候支持。</p><h4 id="2-Resource-Class-Affinity-Spec"><a href="#2-Resource-Class-Affinity-Spec" class="headerlink" title="2. Resource Class Affinity Spec"></a>2. Resource Class Affinity Spec</h4><p><a href="https://review.openstack.org/543062" target="_blank" rel="noopener">https://review.openstack.org/543062</a><br>efried写的一个bp，看名字知其意，调度的时候考虑Resouce Class的亲和。</p><h3 id="2-bug讨论"><a href="#2-bug讨论" class="headerlink" title="(2) bug讨论"></a>(2) bug讨论</h3><p><strong>Handle volume-backed instances in IsolatedHostsFilter</strong>：<a href="https://review.openstack.org/#/q/topic:bug/1746483+(status:open+OR+status:merged)" target="_blank" rel="noopener">https://review.openstack.org/#/q/topic:bug/1746483+(status:open+OR+status:merged)</a><br>Matt发现了一个Filter的问题，主要是对volume-backed的情况进行一些异常处理。在Scheduler会议中，已经很久没有讨论过非Placement的问题。- -!</p><h3 id="3-开放讨论-1"><a href="#3-开放讨论-1" class="headerlink" title="(3) 开放讨论"></a>(3) 开放讨论</h3><p><strong>Add optional healthcheck middleware</strong> <a href="https://review.openstack.org/#/c/542992/" target="_blank" rel="noopener">https://review.openstack.org/#/c/542992/</a><br>一个用于健康检查的midleware，对于API服务挺有用，尤其是对于LB场景下的检查活跃来说。<br>Feature的spec在这里：<a href="https://review.openstack.org/#/c/531456/" target="_blank" rel="noopener">https://review.openstack.org/#/c/531456/</a></p><h2 id="2018年2月19日"><a href="#2018年2月19日" class="headerlink" title="2018年2月19日"></a>2018年2月19日</h2><h3 id="1-Feature讨论-6"><a href="#1-Feature讨论-6" class="headerlink" title="(1) Feature讨论"></a>(1) Feature讨论</h3><p>Glance image traits <a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a><br>Resource class的亲和性 至少到S版本才会落（包括在Placement中支持NUMA亲和），优先级不高，提了下Placement RBAC的需求(Policy/RBAC support in Placement REST API)可能会更高一些。<br>update provider tree的优先级很高解决了很多问题</p><h3 id="2-Bug讨论-3"><a href="#2-Bug讨论-3" class="headerlink" title="(2) Bug讨论"></a>(2) Bug讨论</h3><p><strong>Placement returns 503 when Keystone is down</strong> <a href="https://bugs.launchpad.net/nova/+bug/1749797" target="_blank" rel="noopener">https://bugs.launchpad.net/nova/+bug/1749797</a><br>Keystone挂的时候，Placement会返回一个503，这个问题最后是在keystone middleware里面加了一些detail信息: <a href="https://review.openstack.org/546108" target="_blank" rel="noopener">https://review.openstack.org/546108</a></p><h3 id="3-开放讨论-2"><a href="#3-开放讨论-2" class="headerlink" title="(3)开放讨论"></a>(3)开放讨论</h3><p><strong>调度失败的”Nova valid host”足够了吗？</strong><br>@arvindn05 这哥们提到在虚拟机调度的时候，我们仅仅返回了”no valid host”，为啥不503一个，然后返回为啥调度失败。<br>@edleafe 说了2点，503肯定不合适，错误是用户，不是系统。详细信息不显示是因为不想把底层的硬件架构拓扑之类的信息暴露给用户。管理员可以通过日志之类的看到失败原因。</p><h2 id="2018年3月5日"><a href="#2018年3月5日" class="headerlink" title="2018年3月5日"></a>2018年3月5日</h2><p>PTG刚开完，没什么太多的事儿，jaypipes说了几点：</p><ol><li>jaypipes会发一个recap总结下R版本的重点<br><a href="http://lists.openstack.org/pipermail/openstack-dev/2018-March/128041.html" target="_blank" rel="noopener">http://lists.openstack.org/pipermail/openstack-dev/2018-March/128041.html</a></li><li>最开始的3-4周，都会集中在update_provider_tree系列的patch落地</li><li>在Resource tracker刷新额外traits的合并问题需要讨论，可以在update-provider-tree完成之后去做</li></ol><h2 id="2018年3月5日-1"><a href="#2018年3月5日-1" class="headerlink" title="2018年3月5日"></a>2018年3月5日</h2><h3 id="Feature讨论"><a href="#Feature讨论" class="headerlink" title="Feature讨论"></a>Feature讨论</h3><ol><li>Support traits in Glance <a href="https://review.openstack.org/#/c/541507/" target="_blank" rel="noopener">https://review.openstack.org/#/c/541507/</a></li><li>Add placement-req-filter spec <a href="https://review.openstack.org/#/c/544585/" target="_blank" rel="noopener">https://review.openstack.org/#/c/544585/</a><br>这是调度流程的一个很大变化，这个BP源自CERN从v1升v2的一个需求，最开始CERN用的是Cell v1规模挺大，大概有上万个计算节点，原来的用法是：<br>第一级调度：一个租户映射到指定的特定Cell中，一般一个Cell中也会把特殊硬件的计算节点集中起来，第二级调度：这样在Cell v1中通过租户找到的Cell，然后剩余的节点就不多了，然后进行第二级调度，调度在Cell内压力就小多了。<br>但是目前Placement是一个全局的，并不能感知到Cell，也就是说最差情况，Placement过滤得不好，可能导致真正Scheduler的时候，有上万的节点，所以，就在Placment前面加了一个步骤Pre filter。目前的作用就是，把Placement做不到的，自定义程度很高的Filter放到这里来。</li><li>Forbidden Traits <a href="https://review.openstack.org/#/c/548915/" target="_blank" rel="noopener">https://review.openstack.org/#/c/548915/</a><br>required里面通过叹号来表示不想要某种traits</li><li>Support default allocation ratios <a href="https://review.openstack.org/#/c/552105/" target="_blank" rel="noopener">https://review.openstack.org/#/c/552105/</a></li></ol><h1 id="2-TODO"><a href="#2-TODO" class="headerlink" title="2. TODO"></a>2. TODO</h1><ol><li>了解Idea for a simple way to expose compute driver capabilities in the REST API详细内容</li><li>Granular resource requests分析</li><li>Alternate hosts分析</li><li>Nested Resource Provider分析</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从今年开始，要细度每次的Nova Meeting了，确实对于整体把握整体社区某个领域的进度非常有用。我是这样设想的，按月汇总，每次一篇文章，包含以下几部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;记录&lt;/strong&gt;。按照meeting日期，记录主要内容&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[Placement深度探索] Resource Provider中的并发控制机制</title>
    <link href="http://yikun.github.io/2018/01/23/Placement%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-Resource-Provider%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yikun.github.io/2018/01/23/Placement深度探索-Resource-Provider中的并发控制机制/</id>
    <published>2018-01-23T02:02:42.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>最近，在处理Nova Metadata并发更新的问题(<a href="https://bugs.launchpad.net/nova/+bug/1650188" target="_blank" rel="noopener">bug/1650188</a>)的时候，发现Resource Provider的并发控制机制在最开始就考虑，是通过乐观锁的机制实现并发控制的，简单的说就是：</p><ol><li>为Resource Provider增加了一个generation的字段，用来记录数据更新迭代的版本。</li><li>每次进行刷新（如新增、删除、更新）的时候，检查generation和最初读取的是否一致，若一致则字段值自增，完成数据更新，否则抛出并发更新的异常，返回给用户一个409。</li></ol><p>其实，这个方式就是我们常说的乐观并发控制（OCC, Optimistic Concurrency Control，也称作乐观锁）机制。</p><h3 id="2-详细流程"><a href="#2-详细流程" class="headerlink" title="2. 详细流程"></a>2. 详细流程</h3><p>用户通过API对Resource Provider的资源进行更新时，会传入一个generation参数</p><blockquote><p>curl -X PUT <a href="http://10.76.6.31/placement/resource_providers/7d2590ae-9999-4080-9306-058b4c915e32/traits" target="_blank" rel="noopener">http://10.76.6.31/placement/resource_providers/7d2590ae-9999-4080-9306-058b4c915e32/traits</a> -H “X-Auth-Token: $TOKEN” -H “OpenStack-API-Version: placement 1.16” -H “Accept: application/json” -H “Content-Type: application/json” -d ‘{<br>    <strong>“resource_provider_generation”: 0,</strong><br>    “traits”: [“CUSTOM_YIKUN_TEST”]<br>}’</p></blockquote><p>在最终的数据刷新时，完成事务提交前，会对generation进行刷新，例如对于本例中的traits更新，对应的代码在这里：<a href="https://github.com/openstack/nova/blob/6d227722d4287726e144e4cf928c8e6ae52a6a4c/nova/objects/resource_provider.py#L571" target="_blank" rel="noopener">nova/objects/resource_provider.py#def _set_traits</a>，相当于做了一次检查，如果generation和用户预期的一致，更新成功，如果更新失败，则会raise并发更新失败的error。</p><p><img src="https://user-images.githubusercontent.com/1736354/35274760-51f95ca0-0078-11e8-8ad0-29e6f48e3b64.jpg" alt="generation"></p><p>如上图所示，如果操作A和操作B并发的请求进来，当A请求成功后，刷新了genration，这样，当B进行刷新的时候，就会刷新失败。</p><p>在Placement中，在对Resource Provider下的资源（例如allocation、inventory、trait等）进行修改时，均会对resource provider的generation进行刷新。我们看下实现的细节：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_increment_provider_generation</span><span class="params">(ctx, rp)</span>:</span></span><br><span class="line">    <span class="string">"""Increments the supplied provider's generation value, supplying the</span></span><br><span class="line"><span class="string">    currently-known generation. Returns whether the increment succeeded.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param ctx: `nova.context.RequestContext` that contains an oslo_db Session</span></span><br><span class="line"><span class="string">    :param rp: `ResourceProvider` whose generation should be updated.</span></span><br><span class="line"><span class="string">    :returns: The new resource provider generation value if successful.</span></span><br><span class="line"><span class="string">    :raises nova.exception.ConcurrentUpdateDetected: if another thread updated</span></span><br><span class="line"><span class="string">            the same resource provider's view of its inventory or allocations</span></span><br><span class="line"><span class="string">            in between the time when this object was originally read</span></span><br><span class="line"><span class="string">            and the call to set the inventory.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    rp_gen = rp.generation</span><br><span class="line">    new_generation = rp_gen + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 注意这里的更新条件，通过id及generation匹配</span></span><br><span class="line">    upd_stmt = _RP_TBL.update().where(sa.and_(</span><br><span class="line">            _RP_TBL.c.id == rp.id,</span><br><span class="line">            _RP_TBL.c.generation == rp_gen)).values(</span><br><span class="line">                    generation=(new_generation))</span><br><span class="line"></span><br><span class="line">    res = ctx.session.execute(upd_stmt)</span><br><span class="line">    <span class="comment"># 如果rowcount为0，说明已经不是之前的RP了</span></span><br><span class="line">    <span class="keyword">if</span> res.rowcount != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> exception.ConcurrentUpdateDetected</span><br><span class="line">    <span class="keyword">return</span> new_generation</span><br></pre></td></tr></table></figure></p><h3 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h3><ol><li><a href="https://people.eecs.berkeley.edu/~fox/summaries/database/optimistic_concurrency.html" target="_blank" rel="noopener">On Optimistic Methods for Concurrency Control</a>：对乐观并发控制机制及其要点进行了一些总结。</li><li>阿里巴巴Java开发手册：<blockquote><p>并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据。</p><p>说明:如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p></blockquote></li><li><a href="http://www.hollischuang.com/archives/934" target="_blank" rel="noopener">深入理解乐观锁与悲观锁</a>：介绍了乐观锁和悲观锁的基本原理，并举例说明。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h3&gt;&lt;p&gt;最近，在处理Nova Metadata并发更新的问题(&lt;a href=&quot;https://bugs.launchpad.n
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[Placement深度探索] Nested Resource Providers</title>
    <link href="http://yikun.github.io/2017/12/26/Placement%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-Nested-Resource-Providers/"/>
    <id>http://yikun.github.io/2017/12/26/Placement深度探索-Nested-Resource-Providers/</id>
    <published>2017-12-26T08:33:42.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-背景概述"><a href="#1-背景概述" class="headerlink" title="1. 背景概述"></a>1. 背景概述</h2><p>顾名思义，Nested Resource Providers，即嵌套的资源提供者。在Ocata版本，这个<a href="https://specs.openstack.org/openstack/nova-specs/specs/ocata/approved/nested-resource-providers.html" target="_blank" rel="noopener">bp/nested-resource-providers</a>就被提出，主要是为了使用户可以定义不同的Resource Provider之间的层级关系（hierarchical relationship）。</p><p>我们知道，目前Placement的功能已初具雏形，我们可以记录系统中可数的资源的总数。一个Resource Provider有一系列不同资源种类的存量信息（Inventory），也通过已分配量（Allocation）信息来记录已使用量。通过Resource Provider/Inventory/Allocation这三个关键模型，我们就可以解决以下几个需求：</p><ol><li><strong>每个Resource Provider有多少某种类型的资源</strong>？通过Invetory记录，例如某个主机VCPU的总量；</li><li><strong>系统已经消耗了多少某种类型的资源</strong>？通过Allocation记录，例如某个虚拟机消耗了1GB的内存；</li><li><strong>每个Resource Provider为某种类型的资源提供多少超分配的能力</strong>？通过Inventory的allocation_ratio字段来记录。</li></ol><p>如下图所示，一个计算节点包含8个CPU，500GB硬盘，16GB内存，已使用3个CPU，3GB硬盘，2GB内存，这个计算节点所属高IO组，具备SSD的能力，抽象为Placement模型后，若下图所示：</p><p><img src="https://user-images.githubusercontent.com/1736354/35139070-699e3be0-fd2c-11e7-8172-20f2cdb6671f.jpg" alt="placement"></p><p>计算节点对应Resource Provider（蓝色），其包含的某种类型资源的总量对应Inventory（紫色），资源的类型对应Resource Class（灰色），已使用量对应Allocation（绿色），所属的组对应Placement组（黄色），计算节点的特质对应Trait（橙色）。</p><p>在之前的实现中，对于RP之间的关系，也仅仅支持aggregate功能。例如，某个RP可以把自己的资源，通过aggregate将RP的资源共享给同一aggregate的其他RP。这一功能对于共享存储、共享IP池之类的业务是满足需求的，但是，对于类似父子的这种关系，是无法支持的。</p><p>例如，在NUMA场景下，我们不但需要将主机的内存和VCPU资源记录，同时也需要记录每个主机上的某个NUMA的资源总量及消耗情况，这个就属于父子关系。</p><h2 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h2><p>在<a href="https://etherpad.openstack.org/p/nested-resource-providers" title="nested-resource-providers的etherpad" target="_blank" rel="noopener">nested-resource-providers</a>中提到一场景：</p><blockquote><p>there are resource classes that represent a consumable entity that is within another consumable entity. An example of such a resource class is the amount of memory “local” to a particular NUMA cell.</p></blockquote><p>就是说一些类型代表一种资源消费的实体，同时，包含了另外一种资源消费的实体。举个例子就是memory这种resource class，这个memory是属于某个NUMA的。让我们通过一个例子来看下这个问题。</p><p>在一些对性能或时延有苛刻要求的场景，我们通常希望一个虚拟机能够部署到某个NUMA上（一个主机通常含有多个NUMA CELL，注意这个CELL和我们在Nova中说的Cell V2不是一个含义，而是NUMA独有的名词）。假设我们已经创建了一个叫做“NUMA_MEMORY_MB”的资源类型，资源的总量是192GB。当我们希望将它创建到一个磁盘大小充足并且NUMA内存充足的主机上时，如果仅考虑这个主机上的总内存，可能会找到一个并不是我们期望的主机。我们必须考虑每个NUMA CELL中的内存是否充足。</p><p><img src="https://user-images.githubusercontent.com/1736354/35147337-321bf046-fd49-11e7-8814-3f256b4d02ad.jpg" alt="numa"></p><p>如上图所示，假设一个主机总共有192GB内存。其中128GB分配给了NUMA CELL0，另外64GB分配给了NUMA CELL1。</p><ul><li>虚拟机A消耗了112GB内存，落在了NUMA CELL0上，NUMA CELL0还剩16GB内存</li><li>虚拟机B消耗了48GB内存，落在了NUMA CELL1上，NUMA CELL1还剩16GB内存</li><li>虚拟机C来的时候说：我需要32GB内存。我们应该如何调度主机呢？</li></ul><p>这时，现有的Placement机制，会汇总一个Resource Provider下面所有的某种资源的总和，即会查到的是主机上总内存，发现还有32GB，调度时，就认为这个主机可以作为备选主机。然而，实际我们从上图已经可以看出，实际每个NUMA CELL可供调度的内存均只有16GB，其实是不满足要求的。</p><h2 id="3-基础的数据模型"><a href="#3-基础的数据模型" class="headerlink" title="3. 基础的数据模型"></a>3. 基础的数据模型</h2><p>在现有Resource Provider的基础上，实现这种嵌套关系，基础的数据模型非常重要。在关系数据库中，对分层数据进行管理，主要有2个模型：</p><p><img src="https://user-images.githubusercontent.com/1736354/35257252-264f5338-0033-11e8-9fb3-bc25d5d7c353.jpg" alt="datamodel"></p><ol><li>邻接表（Adjacency list）。记录parent，即父节点。</li><li>嵌套集合（Nested sets）。记录left和right，注意这里不是指兄弟节点，而是类似一个编号，right=left+2n+1，根节点比较特殊，left为1，right为2n，其中，n为节点的总数。</li></ol><p>有关邻接表和嵌套模型的内容可以参考<a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" title="Managing Hierarchical Data in MySQL" target="_blank" rel="noopener">Managing Hierarchical Data in MySQL</a>和<a href="http://joinfu.com/presentations/joinfu/joinfu_part_two.pdf" title="Join-fu: The Art of SQL" target="_blank" rel="noopener">Join-fu: The Art of SQL</a>。</p><p>Reousce Provider最终选择了邻接表作为基础数据结构，在<a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" title="Managing Hierarchical Data in MySQL" target="_blank" rel="noopener">etherpad</a>中，轻描淡写的描述了下选择的原因：</p><blockquote><p><strong>A simple way of modeling this kind of nesting in a relational data store is to use something called an adjacency list model.</strong> We add a NULLABLE parent_resource_provider_id column to the resource_providers table to indicate that the resource provider is either a “top-level” provider (such as a compute host) or a “nested” provider (such as a NUMA cell on the compute host).</p></blockquote><p>个人认为，选择这个模型的原因除了实现比较简单外，还有就是Resource Provider嵌套层级的不是非常深，即使进行一些查询时需要left join几次，也不会有非常大的性能损耗。当然，正如Jaypipes的PPT所述那样，比起Nest Sets来说，Adjacency list是<strong>very common but doesn’t scale</strong>。 </p><p>另外，<a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" title="Managing Hierarchical Data in MySQL" target="_blank" rel="noopener">Managing Hierarchical Data in MySQL</a>的“LIMITATIONS OF THE ADJACENCY LIST MODEL”一节中，提到了2个这个数据结构的限制，回头看来，在Placement进行设计时，都有应对的措施：</p><blockquote><p>Working with the adjacency list model in pure SQL can be difficult at best. Before being able to see the full path of a category we have to know the level at which it resides. In addition, special care must be taken when deleting nodes because of the potential for orphaning an entire sub-tree in the process (delete the portable electronics category and all of its children are orphaned). </p></blockquote><p>其一，是Full-path的遍历（例如，获取一个父树），我们必须要多次join，并且需要知道自己在第几层，从而决定join的次数。这个在Placement，加了一个root_id进行解决。<br>其二，是删除父类节点时，有可能造成底下的树被孤立了，这个Placement则是通过限制用户行为来解决的，即不允许删除有子节点的父节点。</p><p>因此，最终在Resource Provider的模型中，我们新增了2个field：</p><ol><li><strong>parent_provider_uuid</strong>：表示Resource Provider的直接父亲节点。对于非嵌套的节点，这个field为NULL，对于嵌套的节点来说，这个字段在大多数情况可能是计算节点的UUID，表示这个资源是host下的资源；<blockquote><p>Indicates the UUID of the immediate parent provider. This will be None for the vast majority of providers, and for nested resource providers, this will most likely be the compute host’s UUID.</p></blockquote></li><li><strong>root_provider_uuid</strong>：表示这个Resource Provider是一个树形providers的根节点。这个节点可以允许我们实现一个高效的树形访问，从而避免递归地查询父子关系。<blockquote><p>Indicates the UUID of the resource provider that is at the “root” of the tree of providers. This field allows us to implement efficient tree-access queries and avoid use of recursive queries to follow child-&gt;parent relations.</p></blockquote></li></ol><p>数据模型的Patch在这: <a href="https://review.openstack.org/#/c/377138" target="_blank" rel="noopener">patch/377138</a>。</p><h2 id="4-核心流程解析"><a href="#4-核心流程解析" class="headerlink" title="4. 核心流程解析"></a>4. 核心流程解析</h2><h3 id="4-1-创建-删除-Nest-Resource-Provider"><a href="#4-1-创建-删除-Nest-Resource-Provider" class="headerlink" title="4.1 创建/删除 Nest Resource Provider"></a>4.1 创建/删除 Nest Resource Provider</h3><p>最简单的流程就是对Nest Resource Provider进行操作了，对于创建的流程来说，需要用户传递父亲节点，请求的格式类似：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Shared storage"</span>,</span><br><span class="line">    <span class="attr">"parent_provider_uuid"</span>: <span class="string">"542df8ed-9be2-49b9-b4db-6d3183ff8ec8"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在创建的过程中，如果包含了父亲节点，那么，我们可以很方便的找到其对应的root节点，然后填到自己的root中（子节点和父节点有相同的root）；如果没有父节点的话，那么这个子节点的根节点就是自己了（参考代码：<a href="https://github.com/openstack/nova/blob/85a957dcd9c2e3dc8ed03f7e1f88a535bcced7f7/nova/objects/resource_provider.py#L812-L819" target="_blank" rel="noopener">nova/objects/resource_provider.py#L812-L819</a>）。</p><p>同样的，在删除节点的时候，也需要考虑下嵌套的关系，在Resource Provider删除时，加了一个简单的限制：如果一个Resource Provider有子节点(参考代码：<a href="https://github.com/openstack/nova/blob/85a957dcd9c2e3dc8ed03f7e1f88a535bcced7f7/nova/objects/resource_provider.py#L824-L830" target="_blank" rel="noopener">nova/objects/resource_provider.py#L824-L830</a>)，则不允许进行删除。</p><h3 id="4-2-获取满足条件的Resource-Provider"><a href="#4-2-获取满足条件的Resource-Provider" class="headerlink" title="4.2 获取满足条件的Resource Provider"></a>4.2 获取满足条件的Resource Provider</h3><p>在 #63 中，我们提到过Nested Resource Provider的获取流程，参考<a href="https://review.openstack.org/#/c/534968" target="_blank" rel="noopener">Patch/534968</a>大致的过程有以下几步：</p><ol><li>获取满足条件的所有树的Root id。在这一步中，对整棵树中的资源，进行了获取和判断。参考<a href="https://review.openstack.org/#/c/534866" target="_blank" rel="noopener">Patch/534866</a>。</li><li>获取root id对应的树的usage信息。参考<a href="https://review.openstack.org/#/c/534967" target="_blank" rel="noopener">Patch/534967</a><br><img src="https://user-images.githubusercontent.com/1736354/35499685-69550382-050e-11e8-8350-7e5b7d2d2391.jpg" alt="nest"><br>例如，对于上述的结构中，当用户进行请求时，则会将右边的树获取出来，然后最终拿到父亲节点。</li></ol><p>由于目前Patch还在开发中，并且在估计最早要到Rocky版本才能完成，所以，等到全部完成后，再进行更详尽的介绍。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://etherpad.openstack.org/p/nested-resource-providers" title="nested-resource-providers的etherpad" target="_blank" rel="noopener">nested-resource-providers的etherpad</a></li><li><a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/" title="Managing Hierarchical Data in MySQL" target="_blank" rel="noopener">Managing Hierarchical Data in MySQL</a></li><li><a href="http://joinfu.com/presentations/joinfu/joinfu_part_two.pdf" title="Join-fu: The Art of SQL" target="_blank" rel="noopener">Join-fu: The Art of SQL</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-背景概述&quot;&gt;&lt;a href=&quot;#1-背景概述&quot; class=&quot;headerlink&quot; title=&quot;1. 背景概述&quot;&gt;&lt;/a&gt;1. 背景概述&lt;/h2&gt;&lt;p&gt;顾名思义，Nested Resource Providers，即嵌套的资源提供者。在Ocata版本，这个
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[Placement深度探索] Get Allocation Candidates</title>
    <link href="http://yikun.github.io/2017/12/25/Placement%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-Get-Allocation-Candidates/"/>
    <id>http://yikun.github.io/2017/12/25/Placement深度探索-Get-Allocation-Candidates/</id>
    <published>2017-12-25T09:25:17.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-功能概述"><a href="#1-功能概述" class="headerlink" title="1 功能概述"></a>1 功能概述</h2><p>Placement的一个重要的接口，就是获取满足指定资源条件的allocation。举个例子，用户说，<code>我需要1个VCPU，512MB内存，1GB磁盘的资源，Placement你帮我找找看看，有没有合适的资源</code>。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET http://10.76.6.31/placement/allocation_candidates?resources=DISK_GB:1,MEMORY_MB:512,VCPU:1 -H <span class="string">"X-Auth-Token: <span class="variable">$TOKEN</span>"</span> -H <span class="string">"OpenStack-API-Version: placement 1.15"</span></span><br></pre></td></tr></table></figure><p>用户通过allocation_cadidates接口进行查询，参数是<code>DISK_GB:1,MEMORY_MB:512,VCPU:1</code>，随后，Placement自己做了一大堆的查询之后，“告诉”用户：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"allocation_requests"</span>: [&#123;</span><br><span class="line">        <span class="attr">"allocations"</span>: &#123;</span><br><span class="line">            <span class="attr">"f05575b2-3df6-4018-84f6-f2a75795b59b"</span>: &#123;</span><br><span class="line">                <span class="attr">"resources"</span>: &#123;</span><br><span class="line">                    <span class="attr">"DISK_GB"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"MEMORY_MB"</span>: <span class="number">512</span>,</span><br><span class="line">                    <span class="attr">"VCPU"</span>: <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="attr">"provider_summaries"</span>: &#123;</span><br><span class="line">        <span class="attr">"f05575b2-3df6-4018-84f6-f2a75795b59b"</span>: &#123;</span><br><span class="line">            <span class="attr">"resources"</span>: &#123;</span><br><span class="line">                <span class="attr">"DISK_GB"</span>: &#123;</span><br><span class="line">                    <span class="attr">"capacity"</span>: <span class="number">243</span>,</span><br><span class="line">                    <span class="attr">"used"</span>: <span class="number">6</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"MEMORY_MB"</span>: &#123;</span><br><span class="line">                    <span class="attr">"capacity"</span>: <span class="number">11206</span>,</span><br><span class="line">                    <span class="attr">"used"</span>: <span class="number">3200</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"VCPU"</span>: &#123;</span><br><span class="line">                    <span class="attr">"capacity"</span>: <span class="number">16</span>,</span><br><span class="line">                    <span class="attr">"used"</span>: <span class="number">8</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是我查找到的结果：</p><blockquote><ol><li><strong>资源请求参数(allocation_requests)</strong>：您请求资源，DISK有1GB，MEMORY有512MB，VCPU有1个。我帮你找到一个UUID为<code>f05575b2-3df6-4018-84f6-f2a75795b59b</code>的Resource Provider，满足这个条件。</li><li><strong>Provider详细信息(provider_summaries)</strong>：这个Resource Provider，它DISK总量为243GB使用了6GB，MEMORY总量为11206MB使用了3200MB，VCPU总个数为16个，已使用了8个。</li></ol></blockquote><h2 id="2-实现详情"><a href="#2-实现详情" class="headerlink" title="2 实现详情"></a>2 实现详情</h2><h3 id="2-1-整体流程"><a href="#2-1-整体流程" class="headerlink" title="2.1 整体流程"></a>2.1 整体流程</h3><p><img src="https://user-images.githubusercontent.com/1736354/35491560-223fbf9a-04e2-11e8-98d9-13f5d5ba2658.jpg" alt="list_allocation_candidates"></p><p>整体流程如上图所示</p><ol><li>在<a href="https://specs.openstack.org/openstack/nova-specs/specs/queens/approved/granular-resource-requests.html" target="_blank" rel="noopener">bp/granular-resource-requests</a>中，对输入的资源请求格式，进行了定义，使能用户请求诸如traits、nest、share资源的请求方式。</li><li>在请求前，对Resource Class、os_traits信息进行同步。</li><li>请求时，对不同种的资源结构，分别进行了处理<br>(1) 最简单的分支，就是按照资源来匹配满足要求的单个Resource Provider，主要就是对比请求的资源和现有资源的情况，看是否满足用户的需求，即请求量+已使用量&lt;=总存量<br>(2) 考虑共享的资源，在满足“请求量+已使用量&lt;=总存量”的情况下，再对共享资源进行考虑，需要额外将在同一aggreegate的共享资源，考虑进来。<br>(3) 考虑嵌套的资源，如果Resource Provider之间存在嵌套关系，需要获取满足资源请求的tree的信息，主要流程是先获取满足（考虑树中的总和、共用信息）的树的根节点（一般就是计算节点了），然后根据满足的信息，再获取资源的情况。</li></ol><h3 id="2-2-最简单的例子"><a href="#2-2-最简单的例子" class="headerlink" title="2.2 最简单的例子"></a>2.2 最简单的例子</h3><p>下面以一个single reousrce provider（就是说不考虑嵌套、共享之类的）的请求来举个例子：</p><h5 id="Step-1-查询满足条件的resouce-provider"><a href="#Step-1-查询满足条件的resouce-provider" class="headerlink" title="Step 1. 查询满足条件的resouce provider"></a>Step 1. 查询满足条件的resouce provider</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> rp.id</span><br><span class="line"><span class="keyword">FROM</span> resource_providers <span class="keyword">AS</span> rp</span><br><span class="line">    <span class="comment">-- vcpu信息join</span></span><br><span class="line">    <span class="comment">-- vcpu总存量信息</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> inventories <span class="keyword">AS</span> inv_vcpu</span><br><span class="line">        <span class="keyword">ON</span> inv_vcpu.resource_provider_id = rp.id </span><br><span class="line">        <span class="keyword">AND</span> inv_vcpu.resource_class_id = %(resource_class_id_1)s</span><br><span class="line">    <span class="comment">-- vcpu已使用量信息</span></span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> allocations.resource_provider_id <span class="keyword">AS</span> resource_provider_id,</span><br><span class="line">        <span class="keyword">sum</span>(allocations.used) <span class="keyword">AS</span> used</span><br><span class="line">        <span class="keyword">FROM</span> allocations</span><br><span class="line">        <span class="keyword">WHERE</span> allocations.resource_class_id = %(resource_class_id_2)s</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> allocations.resource_provider_id</span><br><span class="line">    ) <span class="keyword">AS</span> usage_vcpu</span><br><span class="line">        <span class="keyword">ON</span> inv_vcpu.resource_provider_id = usage_vcpu.resource_provider_id</span><br><span class="line">    <span class="comment">-- memory信息join</span></span><br><span class="line">    <span class="comment">-- memory总存量信息</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> inventories <span class="keyword">AS</span> inv_memory_mb</span><br><span class="line">        <span class="keyword">ON</span> inv_memory_mb.resource_provider_id = rp.id</span><br><span class="line">        <span class="keyword">AND</span> inv_memory_mb.resource_class_id = %(resource_class_id_3)s</span><br><span class="line">    <span class="comment">-- memory已使用量信息</span></span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> allocations.resource_provider_id <span class="keyword">AS</span> resource_provider_id,</span><br><span class="line">            <span class="keyword">sum</span>(allocations.used) <span class="keyword">AS</span> used</span><br><span class="line">        <span class="keyword">FROM</span> allocations</span><br><span class="line">        <span class="keyword">WHERE</span> allocations.resource_class_id = %(resource_class_id_4)s</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> allocations.resource_provider_id</span><br><span class="line">    ) <span class="keyword">AS</span> usage_memory_mb</span><br><span class="line">        <span class="keyword">ON</span> inv_memory_mb.resource_provider_id = usage_memory_mb.resource_provider_id</span><br><span class="line">    <span class="comment">-- disk信息join</span></span><br><span class="line">    <span class="comment">-- disk总存量信息</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> inventories <span class="keyword">AS</span> inv_disk_gb</span><br><span class="line">        <span class="keyword">ON</span> inv_disk_gb.resource_provider_id = rp.id</span><br><span class="line">        <span class="keyword">AND</span> inv_disk_gb.resource_class_id = %(resource_class_id_5)s</span><br><span class="line">    <span class="comment">-- disk已使用量信息</span></span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> allocations.resource_provider_id</span><br><span class="line">        <span class="keyword">AS</span> resource_provider_id, <span class="keyword">sum</span>(allocations.used) <span class="keyword">AS</span> used</span><br><span class="line">        <span class="keyword">FROM</span> allocations</span><br><span class="line">        <span class="keyword">WHERE</span> allocations.resource_class_id = %(resource_class_id_6)s</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> allocations.resource_provider_id</span><br><span class="line">        ) <span class="keyword">AS</span> usage_disk_gb</span><br><span class="line">            <span class="keyword">ON</span> inv_disk_gb.resource_provider_id = usage_disk_gb.resource_provider_id</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"><span class="comment">-- vcpu满足上限/下限/步长条件</span></span><br><span class="line"><span class="keyword">coalesce</span>(usage_vcpu.used, %(coalesce_1)s) + %(coalesce_2)s &lt;= (</span><br><span class="line">inv_vcpu.total - inv_vcpu.reserved) * inv_vcpu.allocation_ratio <span class="keyword">AND</span></span><br><span class="line">inv_vcpu.min_unit &lt;= %(min_unit_1)s <span class="keyword">AND</span></span><br><span class="line">inv_vcpu.max_unit &gt;= %(max_unit_1)s <span class="keyword">AND</span></span><br><span class="line">%(step_size_1)s % inv_vcpu.step_size = %(param_1)s <span class="keyword">AND</span></span><br><span class="line"><span class="comment">-- memory满足上限/下限/步长条件</span></span><br><span class="line"><span class="keyword">coalesce</span>(usage_memory_mb.used, %(coalesce_3)s) + %(coalesce_4)s &lt;= (</span><br><span class="line">inv_memory_mb.total - inv_memory_mb.reserved) * inv_memory_mb.allocation_ratio <span class="keyword">AND</span></span><br><span class="line">inv_memory_mb.min_unit &lt;= %(min_unit_2)s <span class="keyword">AND</span></span><br><span class="line">inv_memory_mb.max_unit &gt;= %(max_unit_2)s <span class="keyword">AND</span></span><br><span class="line">%(step_size_2)s % inv_memory_mb.step_size = %(param_2)s <span class="keyword">AND</span></span><br><span class="line"><span class="comment">-- disk满足上限/下限/步长条件</span></span><br><span class="line"><span class="keyword">coalesce</span>(usage_disk_gb.used, %(coalesce_5)s) + %(coalesce_6)s &lt;= (</span><br><span class="line">inv_disk_gb.total - inv_disk_gb.reserved) * inv_disk_gb.allocation_ratio <span class="keyword">AND</span></span><br><span class="line">inv_disk_gb.min_unit &lt;= %(min_unit_3)s <span class="keyword">AND</span></span><br><span class="line">inv_disk_gb.max_unit &gt;= %(max_unit_3)s <span class="keyword">AND</span></span><br><span class="line">%(step_size_3)s % inv_disk_gb.step_size = %(param_3)s</span><br></pre></td></tr></table></figure><p>此步完成后，就可以拿到满足给定条件的Resource Provider的ID了。</p><h5 id="Step-2-查询满足条件的resouce-provider及其对应的总存量、已使用量信息"><a href="#Step-2-查询满足条件的resouce-provider及其对应的总存量、已使用量信息" class="headerlink" title="Step 2. 查询满足条件的resouce provider及其对应的总存量、已使用量信息"></a>Step 2. 查询满足条件的resouce provider及其对应的总存量、已使用量信息</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从inventory/allocation/resource_provider表取信息</span></span><br><span class="line"><span class="keyword">SELECT</span> rp.id <span class="keyword">AS</span> resource_provider_id, rp.uuid <span class="keyword">AS</span> resource_provider_uuid,</span><br><span class="line">    inv.resource_class_id, inv.total, inv.reserved, inv.allocation_ratio,</span><br><span class="line">    <span class="string">`usage`</span>.used</span><br><span class="line"><span class="keyword">FROM</span> resource_providers <span class="keyword">AS</span> rp</span><br><span class="line">    <span class="comment">-- inventory信息，每个rp的总量</span></span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> inventories <span class="keyword">AS</span> inv</span><br><span class="line">        <span class="keyword">ON</span> rp.id = inv.resource_provider_id</span><br><span class="line">    <span class="comment">-- allocation信息</span></span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="comment">-- 每个rp和class的已使用量</span></span><br><span class="line">        <span class="keyword">SELECT</span> allocations.resource_provider_id <span class="keyword">AS</span> resource_provider_id,</span><br><span class="line">        allocations.resource_class_id <span class="keyword">AS</span> resource_class_id,</span><br><span class="line">        <span class="keyword">sum</span>(allocations.used) <span class="keyword">AS</span> used</span><br><span class="line">        <span class="keyword">FROM</span> allocations</span><br><span class="line">        <span class="keyword">WHERE</span> allocations.resource_provider_id <span class="keyword">IN</span> (%(resource_provider_id_1)s) <span class="keyword">AND</span></span><br><span class="line">            allocations.resource_class_id <span class="keyword">IN</span> (</span><br><span class="line">                %(resource_class_id_1)s,</span><br><span class="line">                %(resource_class_id_2)s,</span><br><span class="line">                %(resource_class_id_3)s</span><br><span class="line">            )</span><br><span class="line">        <span class="comment">-- 按照rp_id和rp_class_id进行分组</span></span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> allocations.resource_provider_id, allocations.resource_class_id</span><br><span class="line">    ) <span class="keyword">AS</span> <span class="string">`usage`</span></span><br><span class="line">        <span class="keyword">ON</span> <span class="string">`usage`</span>.resource_provider_id = inv.resource_provider_id <span class="keyword">AND</span></span><br><span class="line">        <span class="string">`usage`</span>.resource_class_id = inv.resource_class_id</span><br><span class="line"><span class="comment">-- 查询指定id及class的resource</span></span><br><span class="line"><span class="keyword">WHERE</span> rp.id <span class="keyword">IN</span> (%(id_1)s) <span class="keyword">AND</span></span><br><span class="line">    inv.resource_class_id <span class="keyword">IN</span> (</span><br><span class="line">        %(resource_class_id_4)s,</span><br><span class="line">        %(resource_class_id_5)s,</span><br><span class="line">        %(resource_class_id_6)s</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>查询的最终结果如下：<br><img src="https://user-images.githubusercontent.com/1736354/34344401-874dbff4-ea20-11e7-835b-c3bea5599896.png" alt="image"></p><p>其实我们可以看到，这个接口的作用就是说，用户给一些资源的请求，然后placement就去查，满足条件的resource provider。</p><p>当然，作为placement最重要也是最复杂的接口之一，加上嵌套、共享、分组之后，情况变得越来越复杂，但是，核心的实现是差不多的，都是一个套路，join一系列我们需要的信息，然后在where判断这些信息是否满足条件，最后，把满足条件的RP返回给用户。</p><p>后续，我也会在分析学习独立的feature（比如Nested Resource Provider、Sharing Resource Provider等），加上此接口的变化点和深入解析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-功能概述&quot;&gt;&lt;a href=&quot;#1-功能概述&quot; class=&quot;headerlink&quot; title=&quot;1 功能概述&quot;&gt;&lt;/a&gt;1 功能概述&lt;/h2&gt;&lt;p&gt;Placement的一个重要的接口，就是获取满足指定资源条件的allocation。举个例子，用户说，&lt;code&gt;我需要1个VCPU，512MB内存，1GB磁盘的资源，Placement你帮我找找看看，有没有合适的资源&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>一个死锁问题的深入探究</title>
    <link href="http://yikun.github.io/2017/12/13/%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6/"/>
    <id>http://yikun.github.io/2017/12/13/一个死锁问题的深入探究/</id>
    <published>2017-12-13T11:47:10.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章可以看做是一个问题定位、分析、学习过程的记录，介绍了OpenStack Nova一个死锁问题的分析和解决的过程，你将从本文了解到SQLAlchemy的session中的语序排序机制、OpenStack的死锁重试机制及改进点以及一些调试的手段。</p><h3 id="0-背景"><a href="#0-背景" class="headerlink" title="0. 背景"></a>0. 背景</h3><p>在Nova对虚拟机进行一些操作的时候，比如创建、停止虚拟机之类的操作的时候，会将这些事件记录在instance_actions表里面记录操作的时间、操作类型以及一些操作事件详情。</p><p>例如，我们可以通过instnace-action-list来查看虚拟机的操作，并可以通过对应的req id来查操作中的事件详情，如果是失败的话，还可以从事件详情中，看到对应的错误栈信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nova instance-action-list e92885a9-06d6-4491-ac43-6fd04e32ee72</span></span><br><span class="line">+--------+------------------------------------------+---------+----------------------------+</span><br><span class="line">| Action | Request_ID                               | Message | Start_Time                 |</span><br><span class="line">+--------+------------------------------------------+---------+----------------------------+</span><br><span class="line">| create | req-416cb88e-5adb-4c0f-9c32-6370d3661940 | -       | 2017-12-13T12:08:36.000000 |</span><br><span class="line">| stop   | req-52155da3-d2ca-463c-b380-6034c0b5fdf1 | -       | 2017-12-13T12:09:17.000000 |</span><br><span class="line">+--------+------------------------------------------+---------+----------------------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> nova instance-action e92885a9-06d6-4491-ac43-6fd04e32ee72 req-52155da3-d2ca-463c-b380-6034c0b5fdf1</span></span><br><span class="line">+---------------+--------------------------------------------------+</span><br><span class="line">| Property      | Value                                            |</span><br><span class="line">+---------------+--------------------------------------------------+</span><br><span class="line">| action        | stop                                             |</span><br><span class="line">| events        | [&#123;u'event': u'compute_stop_instance',            |</span><br><span class="line">|               |   u'finish_time': u'2017-12-13T12:09:23.000000', |</span><br><span class="line">|               |   u'result': u'Success',                         |</span><br><span class="line">|               |   u'start_time': u'2017-12-13T12:09:18.000000',  |</span><br><span class="line">|               |   u'traceback': None&#125;]                           |</span><br><span class="line">| instance_uuid | e92885a9-06d6-4491-ac43-6fd04e32ee72             |</span><br><span class="line">| message       | -                                                |</span><br><span class="line">| project_id    | 0232cef222f7479fae3fd8fa24d8c382                 |</span><br><span class="line">| request_id    | req-52155da3-d2ca-463c-b380-6034c0b5fdf1         |</span><br><span class="line">| start_time    | 2017-12-13T12:09:17.000000                       |</span><br><span class="line">| user_id       | 5b0b6a4c068f4c1ba78b50d8a4db5057                 |</span><br><span class="line">+---------------+--------------------------------------------------+</span><br></pre></td></tr></table></figure></p><p>在instance_action的表里面，记录着action的更新时间，比如event结束了，我们也期望能够action里面能记录update的时间，但是目前并没有进行刷新。</p><p><img src="https://user-images.githubusercontent.com/1736354/34138279-ac8d220e-e4a9-11e7-8617-8f8ddb0ef34a.jpg" alt="action"></p><p>这个patch想做的事儿也比较简单，如上图所示，就是在event进行记录（比如开始和结束）的时候，也对action的更新时间也做刷新。也就是说，我们在写instance_event_action表后，也需要写instance_action表去记录下刷新时间。大致代码的关键逻辑如下所示（省略了一些无关的代码细节）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pick_context_manager_writer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action_event_finish</span><span class="params">(context, values)</span>:</span></span><br><span class="line">    <span class="string">"""Finish an event on an instance action."""</span></span><br><span class="line">    <span class="comment"># 原有获取action</span></span><br><span class="line">    action = _action_get_by_request_id(context, values[<span class="string">'instance_uuid'</span>],</span><br><span class="line">                                       values[<span class="string">'request_id'</span>])</span><br><span class="line">    <span class="comment"># 原有获取event</span></span><br><span class="line">    event_ref = model_query(context, models.InstanceActionEvent).\</span><br><span class="line">                            filter_by(action_id=action[<span class="string">'id'</span>]).\</span><br><span class="line">                            filter_by(event=values[<span class="string">'event'</span>]).\</span><br><span class="line">                            first()</span><br><span class="line">    <span class="comment"># 原有的event刷新流程</span></span><br><span class="line">    event_ref.update(values)</span><br><span class="line">    <span class="comment"># **新增的刷新action时间逻辑**</span></span><br><span class="line">    action.update(&#123;<span class="string">'updated_at'</span>: values[<span class="string">'finish_time'</span>]&#125;)</span><br><span class="line">    action.save(context.session)</span><br><span class="line">    <span class="keyword">return</span> event_ref</span><br></pre></td></tr></table></figure></p><h3 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h3><p>在修复Nova的这个事件时间刷新问题(<a href="https://bugs.launchpad.net/nova/+bug/1719561" target="_blank" rel="noopener">bug/507473</a>)的时候，CI会概率性地挂一些用例，先开始以为是CI不稳定，workflow+1之后，最终的门禁检查一直过不了。Matt recheck了几次都是失败的，然后问：</p><blockquote><p>I’m not sure if the test failures this patch is hitting are related to this change or not - they definitely don’t seem to be (I’m not sure why we’d get an UnexpectedTaskStateError during resize due to this change).</p></blockquote><p>这才引起了我的注意，我找了下归档的日志发现：</p><blockquote><p>Exception during message handling: DBDeadlock: (pymysql.err.InternalError) (1213, u’<strong>Deadlock found when trying to get lock</strong>; try restarting transaction’) [SQL: u’<strong>UPDATE instance_actions SET updated_at=%(updated_at)s WHERE instance_actions.id = %(instance_actions_id)s</strong>‘] [parameters: {‘instance_actions_id’: 23, ‘updated_at’: datetime.datetime(2017, 12, 4, 2, 48, 36, 91068)}]</p></blockquote><p>第一反应是，我去！死锁了？简单的一个update怎么会死锁？确认了下where条件比较单一，并不是因为条件排序不稳定引起的死锁；也确认了下action数据库的索引，也比较简单，也不会有死锁问题。然后，就看业务代码，代码逻辑也很简单，一个事务里面包含了4件事，2个查询，2个刷新。不科学啊！</p><h3 id="2-发现"><a href="#2-发现" class="headerlink" title="2. 发现"></a>2. 发现</h3><p>遇到这种活久见的问题，最好的办法就是把每一句SQL都dump出来，因为不是裸写SQL，鬼知道SQLAlchemy中间的ORM那层为我们做了什么。</p><p>OpenStack的oslo.db为我们提供了一个配置项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[database]</span><br><span class="line"># (Integer) Verbosity of SQL debugging information: 0=None, 100=Everything.</span><br><span class="line">connection_debug = 100</span><br></pre></td></tr></table></figure></p><p>把他设置成100就可以dump出执行的每一句SQL了，这个方法在我们进行调试的时候很方便。然后，进行复现，结果让我震惊了（问号脸？？？代码是一样的，生成SQL的顺序却是不一致的）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从API dump的结果</span></span><br><span class="line"><span class="keyword">BEGIN</span> (implicit)</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> instance_actions <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> instance_actions_events <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="comment">-- 先刷新action</span></span><br><span class="line"><span class="keyword">UPDATE</span> instance_actions <span class="keyword">SET</span> updated_at=%(updated_at)s <span class="keyword">WHERE</span> instance_actions.id= %(instance_actions_id)s</span><br><span class="line"><span class="comment">-- 再刷新action_event</span></span><br><span class="line"><span class="keyword">UPDATE</span> instance_actions_events <span class="keyword">SET</span> updated_at=%(updated_at)s, finish_time=%(finish_time)s, <span class="keyword">result</span>=%(<span class="keyword">result</span>)s <span class="keyword">WHERE</span> instance_actions_events.id = %(instance_actions_events_id)s</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从Conductor dump的结果</span></span><br><span class="line"><span class="keyword">BEGIN</span> (implicit)</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> instance_actions <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> instance_actions_events <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="comment">-- 先刷新action_event</span></span><br><span class="line"><span class="keyword">UPDATE</span> instance_actions_events <span class="keyword">SET</span> updated_at=%(updated_at)s, finish_time=%(finish_time)s, <span class="keyword">result</span>=%(<span class="keyword">result</span>)s <span class="keyword">WHERE</span> instance_actions_events.id = %(instance_actions_events_id)s</span><br><span class="line"><span class="comment">-- 再刷新action</span></span><br><span class="line"><span class="keyword">UPDATE</span> instance_actions <span class="keyword">SET</span> updated_at=%(updated_at)s <span class="keyword">WHERE</span> instance_actions.id= %(instance_actions_id)s</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure></p><p>完整的SQL dump我贴在了<a href="http://paste.openstack.org/show/628609/" target="_blank" rel="noopener">paste/628609</a>，可以分析出来，就是产生死锁的根本原因：<strong>在一个事务中，更新2个表的相反行</strong>。并发执行2个这样的事务，一个事务拿着action表的行锁，一个事务拿着action_event表的行锁，它们都互相等着对方释放，最终产生了死锁，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/1736354/34138652-98867f06-e4ab-11e7-8d68-fea01b118e8b.jpg" alt="deadlockjpg"></p><p>从MySQL官方DOC里，给的建议<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html" target="_blank" rel="noopener">How to Minimize and Handle Deadlocks</a>中，我们也看到了类似的建议：</p><blockquote><p>When modifying multiple tables within a transaction, or different sets of rows in the same table, do those operations in a consistent order each time. Then transactions form well-defined queues and do not deadlock. For example, organize database operations into functions within your application, or call stored routines, rather than coding multiple similar sequences of INSERT, UPDATE, and DELETE statements in different places.</p></blockquote><p>核心意思就是说，我们在一个transaction中更新多个表的时候，或者说在一个表中更新不同行的时候，一定要保证每一次调用的顺序是一致的。最终，临时解决这个问题的方式也比较简单，就是在这个函数上加一个<a href="https://review.openstack.org/#/c/507473/16/nova/db/sqlalchemy/api.py@6304" target="_blank" rel="noopener">死锁重试装饰器</a>，即在发生死锁的时候进行重试，CI终于全绿了。</p><h3 id="3-进一步分析"><a href="#3-进一步分析" class="headerlink" title="3. 进一步分析"></a>3. 进一步分析</h3><p>问题解决就结束了吗？不，2个疑问一直在心中徘徊：</p><blockquote><ol><li>死锁重试的装饰器是怎么实现的，真的有效吗？</li><li>SQLalchemy做了什么导致最终生成SQL的顺序是不稳定的，为什么要这么做？</li></ol></blockquote><h4 id="3-1-oslo-db的死锁重试机制"><a href="#3-1-oslo-db的死锁重试机制" class="headerlink" title="3.1 oslo.db的死锁重试机制"></a>3.1 oslo.db的死锁重试机制</h4><p>这个问题的场景和上研的时候，在通信中搞的“退避算法”很类似（HINOC中信道接纳的时候，多个节点并行接纳时，如果发生冲突，需要退避重试），都是冲突避免，通信中是避免信道冲突，而这里则是避免数据库的死锁。</p><p>我们从<a href="https://github.com/openstack/oslo.db/blob/4a727233dc2b7d1021ed7932d2cd27d8053dca31/oslo_db/api.py#L127-L161" target="_blank" rel="noopener">oslo_db/api.py</a>可以看到他的实现，原理比较简单，就是隔几秒（2的retry数次方秒），如果调用成功，就终止重试。伪代码大概如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">try</span>):</span><br><span class="line">    sleep(t)</span><br><span class="line">    <span class="comment"># 指数递增</span></span><br><span class="line">    t = t * <span class="number">2</span></span><br><span class="line">    <span class="comment"># 超过上限取上限</span></span><br><span class="line">    t = min(max_t, t)</span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">raise</span> deadlock:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>虽然看着隔了一些时间，但是，这种指数递增的机制对于死锁这种问题没有什么卵用，大家一起等，然后再一起调，还是会再次产生死锁。对于这个问题，我提交了一个Patch对其进行优化，具体内容可以参考 #71 <a href="https://github.com/Yikun/yikun.github.com/issues/71" target="_blank" rel="noopener">《oslo.db中的死锁重试机制优化》</a>的详细分析。</p><h4 id="3-2-SQLAlchemy-Session中的排序机制"><a href="#3-2-SQLAlchemy-Session中的排序机制" class="headerlink" title="3.2 SQLAlchemy Session中的排序机制"></a>3.2 SQLAlchemy Session中的排序机制</h4><p>上文已经提到，造成死锁的根本原因实际上是在一个事务中，更新2个表的时候的顺序不一致。在并发调用的时候，产生了死锁。Python的代码是按顺序更新的（先更新event内容，再更新action），但是为什么SQLAlchemy产生的SQL是乱序的呢？</p><p>通过阅读SQLAlchemy的源码，最终找到了答案。先说结论：Session中的操作顺序，由UnitOfWork机制决定最终的调用顺序，如果没有依赖关系，最终执行顺序是不稳定的。</p><h5 id="3-2-1-SQLAlchemy的缓存刷新机制"><a href="#3-2-1-SQLAlchemy的缓存刷新机制" class="headerlink" title="3.2.1. SQLAlchemy的缓存刷新机制"></a>3.2.1. SQLAlchemy的缓存刷新机制</h5><p>SQLAlchemy在进行数据刷新的时候，会有一个flush的过程(实现见<a href="https://github.com/zzzeek/sqlalchemy/blob/75bdcd096f12012bf45cffebd597c33b501c2ef2/lib/sqlalchemy/orm/session.py#L2203" target="_blank" rel="noopener">lib/sqlalchemy/orm/session.py#def flush</a>，这个过程会将所有的object的变化，刷新到数据库中。例如，会将插入、修改、删除，转换为INSERT、UPDATE、DELETE等操作。而刷新执行的顺序，是通过Session的”UNIT of Worker”依赖机制保证的。</p><p>我们可以从有SQLalchemy作者写的一篇关于其架构的文章<a href="http://www.aosabook.org/en/sqlalchemy.html" target="_blank" rel="noopener">《SQLAlchemy》</a>中看到一些关于Session相关的数据结构：<br><img src="https://user-images.githubusercontent.com/1736354/34139960-93fe0f2e-e4b2-11e7-94ab-e439712a7258.png" alt="session-overview"></p><p>Session维护着如上图所示的结构，在每次刷新的时候，会将object的变动刷新到数据库中。如作者所说说，flush这个函数可能是 SQLAlchemy最复杂的函数。</p><h5 id="3-2-2-SQLAlchemy的UNIT-of-WORK机制"><a href="#3-2-2-SQLAlchemy的UNIT-of-WORK机制" class="headerlink" title="3.2.2. SQLAlchemy的UNIT of WORK机制"></a>3.2.2. SQLAlchemy的UNIT of WORK机制</h5><p>我们先看看来自作者的介绍：</p><blockquote><p>The job of the unit of work is to move all of the pending state present in a particular Session out to the database, emptying out the new, dirty, and deleted collections maintained by the Session. Once completed, the in-memory state of the Session and what’s present in the current transaction match. The primary challenge is to determine the correct series of persistence steps, and then to perform them in the correct order.</p></blockquote><p>UOW的工作主要是将session维护的new、dirty、deleted的集合清掉并落入数据库中。主要挑战就是决定正确的持久化步骤和顺序。我们看到了关键的地方，排序！</p><p>从这篇文章中，我们了解到，其实对于UOW来说，共有两级排序：<br><img src="https://user-images.githubusercontent.com/1736354/34144270-c8be1bfa-e4cb-11e7-87df-ab894059bd13.jpg" alt="sort"><br>1） 第一级排序，是针对于多个表（class）之前的排序，依赖信息从表之间的关系获取，例如文章中所举的User和Address的例子，需要在user插入后，有了主键，然后再去更新。<br>2）第二季排序，是针对于一个表（class）之中操作的排序，例如文章中所举的，前一个插入的user依赖后一个user。</p><p>然而，无论是哪个排序，如果表和表之间在SQLAlchemy定义模型的时候，并没有指定其顺序，那么便没有依赖关系，也便意味着，顺序是不稳定的。</p><p>在我们出现的问题中，action和action_event在<a href="https://github.com/openstack/nova/blob/07c925a5321e379293bbf0e55bf3c40798eaf21b/nova/db/sqlalchemy/models.py#L1272-L1309" target="_blank" rel="noopener">model定义的代码</a>中，并未指定action和event之前的关系，因此，SQLAlchemy分析依赖的时候，只是将这两个表当做独立的2个表。</p><h5 id="3-2-3-实战一把"><a href="#3-2-3-实战一把" class="headerlink" title="3.2.3. 实战一把"></a>3.2.3. 实战一把</h5><p>为了证明我们的分析，我们在SQLAlchemy打印一些日志来记录依赖关系和最终执行的结果，代码见<a href="https://github.com/zzzeek/sqlalchemy/blob/68879d50faa9e2602e55d5d191647b1cf864e5ab/lib/sqlalchemy/orm/unitofwork.py#L372-L377" target="_blank" rel="noopener">lib/sqlalchemy/ormunitofwork.py</a>，取消掉这些注释即可。</p><blockquote><p>dependencies: set([(SaveUpdateAll(Mapper|InstanceActionEvent|instance_actions_events), DeleteAll(Mapper|InstanceActionEvent|instance_actions_events)), (SaveUpdateAll(Mapper|InstanceAction|instance_actions), DeleteAll(Mapper|InstanceAction|instance_actions))])</p><p>cycles: set([])</p><p>sort: [SaveUpdateAll(Mapper|InstanceAction|instance_actions), SaveUpdateAll(Mapper|InstanceActionEvent|instance_actions_events), DeleteAll(Mapper|InstanceActionEvent|instance_actions_events), DeleteAll(Mapper|InstanceAction|instance_actions)]</p><p>COUNT OF POSTSORT ACTIONS 4</p></blockquote><p>上面共4行信息，我们需要的是dependencies信息和sort信息，从依赖信息我们可以看到，我们进行的这个事务仅有2组依赖，分别是action和event_action的缓存入库先于缓存清空，而action和event_action之间是没有依赖关系的。所以，最终生成的sort列表，其实是无法保证稳定性的。</p><p>所以，才会出现我们本文所出的问题，一会先刷新action，一会先刷新action_event。然而，对于这种问题并不是无解，我们只需要在这两个表里加入relationship，使他们有依赖就可以了。如果确实没有什么关联，那我们就需要思考把更新拆分到更小的事务中了，就像MySQL官网说的那样：<strong>Keep transactions small and short in duration to make them less prone to collision</strong>。</p><h3 id="4-总结。"><a href="#4-总结。" class="headerlink" title="4. 总结。"></a>4. 总结。</h3><p>TL;DR。写完这篇文章发现，有点太长了，不想细看的看看总结吧，哈哈。</p><ol><li>遇到OpenStack数据库相关问题，可以通过设置[database]/connection_debug=100进行SQL打印。</li><li>SQLAlchemy对于一个session中的更新顺序，如果表之间没有依赖，是无法保证顺序的。</li><li>在一个事务中，更新多张表，需要考虑顺序，若ORM无法保证的更新顺序，尽量不要放在同一个事务中，尽量确保事务做的事简单。</li><li>oslo.db目前的死锁重试机制，是大家一起等X秒，很有可能再次死锁。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://bugs.launchpad.net/nova/+bug/1719561" target="_blank" rel="noopener">Instance action’s updated_at issue</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks-handling.html" target="_blank" rel="noopener">How to Minimize and Handle Deadlocks</a></li><li><a href="https://amazonaws-china.com/blogs/architecture/exponential-backoff-and-jitter/" target="_blank" rel="noopener">Exponential Backoff And Jitter</a></li><li><a href="http://www.sqlalchemy.org/library.html" target="_blank" rel="noopener">SQLAlchemy library(tutorials, arch doc, talks, posts</a></li><li><a href="https://news.ycombinator.com/item?id=10321331" target="_blank" rel="noopener">Some discussion on backoff algorithm</a></li><li><a href="https://stackoverflow.com/questions/10154343/is-sqlalchemy-saves-order-in-adding-objects-to-session" target="_blank" rel="noopener">Is SQLAlchemy saves order in adding objects to session?</a></li><li><a href="http://www.aosabook.org/en/sqlalchemy.html" target="_blank" rel="noopener">SQLAlchemy at Architecture of Open Source Applications</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章可以看做是一个问题定位、分析、学习过程的记录，介绍了OpenStack Nova一个死锁问题的分析和解决的过程，你将从本文了解到SQLAlchemy的session中的语序排序机制、OpenStack的死锁重试机制及改进点以及一些调试的手段。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Nova调度相关特性理解与梳理</title>
    <link href="http://yikun.github.io/2017/12/06/Nova%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7%E7%90%86%E8%A7%A3%E4%B8%8E%E6%A2%B3%E7%90%86/"/>
    <id>http://yikun.github.io/2017/12/06/Nova调度相关特性理解与梳理/</id>
    <published>2017-12-06T01:41:11.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>准备拿这篇文章梳理下OpenStack Nova调度相关的特性，由于目前Placement的引入，说起调度，和这个组件是分不开的，所以本文也可以看做是Placement的一个历史特性的梳理。第一阶段会按照版本，先把调度相关的BP过一遍，然后再通过理解和使用加强理解。好吧，我承认又开了一个系列的坑，话不多说，开始！</p><a id="more"></a><h2 id="Liberty版本"><a href="#Liberty版本" class="headerlink" title="Liberty版本"></a>Liberty版本</h2><p>L版本特性列表：<a href="https://blueprints.launchpad.net/nova/liberty" target="_blank" rel="noopener">链接</a><br><a href="https://blueprints.launchpad.net/nova/+spec/request-spec-object" target="_blank" rel="noopener">https://blueprints.launchpad.net/nova/+spec/request-spec-object</a><br><a href="https://blueprints.launchpad.net/nova/+spec/request-spec-object-mitaka" target="_blank" rel="noopener">https://blueprints.launchpad.net/nova/+spec/request-spec-object-mitaka</a></p><h2 id="Mitaka版本"><a href="#Mitaka版本" class="headerlink" title="Mitaka版本"></a>Mitaka版本</h2><p>根据<a href="https://specs.openstack.org/openstack/nova-specs/priorities/mitaka-priorities.html" target="_blank" rel="noopener">M版本特性优先级</a>的信息，我们看到M版本规划的工作还是围绕着request spec和object来展开的。在<a href="https://blueprints.launchpad.net/nova/mitaka" target="_blank" rel="noopener">M版本特性列表</a>中，我们可以看到确实重点还是在request spec的完善，其中虽然Inventory的拆分在这个版本提出，但是最终没有被完全实现，而是拖延到了N版本才完成。</p><h3 id="Add-concept-of-resource-classes"><a href="#Add-concept-of-resource-classes" class="headerlink" title="Add concept of resource classes"></a>Add concept of resource classes</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/resource-classes" target="_blank" rel="noopener">bp/resource-classes</a></p><p>原来我们增加某种资源的时候，都需要给instance的object增加filed，每一次改变，都要刷一下db shema，或是增加filed或是增加整个table，也就是说新增一种类型的支持，管理员就要把数据库也升级，这意味着会有业务中断，很不合理。<br>随着资源种类变多，这种方式有点臃肿，也不是很优雅，在紧接着的generic resource pool的bp中，也亟需把资源抽象出来了。<br>因此，在M版本新增了一个Resource Class的object，用于记录虚拟机资源的类型，无论增加新的独立资源类型还是共享资源类型，都不需要再对db结构刷新了。<br>这个BP可以说是generic-resource-pools这个bp的基础，只有通过这种通用的方式将资源类型表征出来，才有可能将所有的资源都抽象出来。</p><h2 id="Newton版本"><a href="#Newton版本" class="headerlink" title="Newton版本"></a>Newton版本</h2><p>根据<a href="https://specs.openstack.org/openstack/nova-specs/priorities/newton-priorities.html#scheduler" target="_blank" rel="noopener">N版本特性优先级</a>来看，首次提到了要把Placement相关的东西独立出来，并且把cell数据库中的compute node的数据迁移到API DB的inventory和allocation中。因此，这个版本可以看做是Placement的元年。而从<a href="https://blueprints.launchpad.net/nova/newton" target="_blank" rel="noopener">N版本特性列表</a>中，我们看到了Placement所依赖的那些基础结构和模型均已在这个版本支持了。</p><h3 id="Add-concept-of-generic-resource-pools"><a href="#Add-concept-of-generic-resource-pools" class="headerlink" title="Add concept of generic resource pools"></a>Add concept of generic resource pools</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/generic-resource-pools" target="_blank" rel="noopener">bp/generic-resource-pools</a></p><p>这个是一个非常重要的BP，可以认为是Placement组件的初始BP，原先，compute node的理念，把计算的资源强行绑到某一个node上了，而实际上，存在着一些诸如共享资源的情况，可能多个计算节点共享着某些资源。<br>所以，Nova期望能够定义一种“通用的资源”模型。<br>我们可以看到几个在Placement的重要概念都有在这个BP提到。<br>Resource Provider：名释其意，资源提供者，结构比较简单，UUID和这个RP对应的一些基本信息，比如name之类的，资源提供的具体资源的存量和消耗量，通过UUID关联到其他表中。<br>Inventory：存量，用来记录资源的总量，并且记录着资源可分配的最大、最小、步长等信息。每个RP（比如计算节点）的每种资源（比如vcpu、内存等）都占一行。<br>Allocation：已分配量，用于记录某个RP（如计算节点）被某个消耗者（如虚拟机）</p><h3 id="Add-concept-of-resource-providers-partial"><a href="#Add-concept-of-resource-providers-partial" class="headerlink" title="Add concept of resource providers (partial)"></a>Add concept of resource providers (partial)</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/resource-providers" target="_blank" rel="noopener">bp/resource-providers</a></p><p>Resource Provider模型主要的目的就是为了把compute node这个模型替换掉。<br>原来Nova假设所有的资源都是通过单个计算节点提供的，所以所有的资源都通过compute node来记录，后面发现对于共享资源的这种场景比较棘手了。<br>所以，提出了通过RP这个新的模型准确的记录资源情况。</p><h3 id="Scheduler-Move-inventory-fields-of-compute-node-continued"><a href="#Scheduler-Move-inventory-fields-of-compute-node-continued" class="headerlink" title="Scheduler: Move inventory fields of compute node (continued)"></a>Scheduler: Move inventory fields of compute node (continued)</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/compute-node-inventory-newton" target="_blank" rel="noopener">bp/compute-node-inventory-newton</a></p><p>首次提出在mitaka版本，直到Newton版本才实现。<br>之前，nova是用compute node来记录计算节点上的资源，即一种资源都会有一列，比如vcpus、memory_mb、local_gb。<br>这样资源对应的所有资源的总量、已使用量、剩余量每个都占一列，所有的都揉在一起。<br>在我们增加资源类型的时候，需要加很多列，而且在进行资源更新的时候，都需要刷新compute node，而且这些更新是有锁的，效率很低。<br>这个BP先把总量信息Inventory抽出来了，其中有个字段是resource type，就是在resource class中实现的资源类型。<br>这样一来，增加一种新的资源类型时，数据库结构不会发生变化，只是增加了一条resource type不同的记录。<br>疑问：inventory在何时会被刷新，何时会被访问？</p><h3 id="Resource-providers-Move-allocation-fields"><a href="#Resource-providers-Move-allocation-fields" class="headerlink" title="Resource providers: Move allocation fields"></a>Resource providers: Move allocation fields</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/resource-providers-allocations" target="_blank" rel="noopener">bp/resource-providers-allocations</a><br>与Inventory类似，allocation也是compute node拆出来的，用来记录某个RP被某个消费者消费的记录。<br>疑问：allocation在何时会被刷新，何时会被访问？</p><p>可以看到，在Newton版本，Placement所依赖的基本能力（如Resource Provider、Inventory、Allocation等）均已经被支持了。</p><h2 id="Ocata版本"><a href="#Ocata版本" class="headerlink" title="Ocata版本"></a>Ocata版本</h2><p>根据<a href="https://specs.openstack.org/openstack/nova-specs/priorities/ocata-priorities.html" target="_blank" rel="noopener">O版本特性优先级</a>，我们可以看到，调度统一放在了API Cell中的Conductor进行，而特意的将Resource Provider作为一个重要的环节，其中包括了调度的Placement接入、Aggregate支持以及自定义资源类型。从<a href="https://blueprints.launchpad.net/nova/ocata" target="_blank" rel="noopener">O版本特性列表</a>也可以看出，Ocata版本主要工作也是集中在Cell V2架构的调度能力及Resource Provider相关能力机制的补齐。</p><h3 id="Scheduling-interaction-for-cells"><a href="#Scheduling-interaction-for-cells" class="headerlink" title="Scheduling interaction for cells"></a>Scheduling interaction for cells</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/cells-scheduling-interaction" target="_blank" rel="noopener">bp/cells-scheduling-interaction</a><br>从O版本后，调度会在API Cell进行，这个BP在conductor中增加了schedule_and_build_instances方法，通过这个方法向指定的cell进行虚拟机创建。将API Cell和计算Cell分离，将调度层与计算层解耦。</p><h3 id="Resource-Providers-Custom-Resource-Classes"><a href="#Resource-Providers-Custom-Resource-Classes" class="headerlink" title="Resource Providers - Custom Resource Classes"></a>Resource Providers - Custom Resource Classes</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/custom-resource-classes" target="_blank" rel="noopener">bp/custom-resource-classes</a></p><p>为Placement增加自定义Resource class的能力，之前仅支持基本的vCPU、内存、磁盘等基本的资源类型，这个BP增加了让用户自定义资源类型的能力，比如增加自定义的FPGA、裸机调度的能力。<br>增加了一个resource classes表，用于记录自定义的资源。并且增加了基本的CRUD接口，使用户可以增加、删除、修改、获取指定的resource class。</p><h3 id="Add-concept-of-generic-resource-pools-1"><a href="#Add-concept-of-generic-resource-pools-1" class="headerlink" title="Add concept of generic resource pools"></a>Add concept of generic resource pools</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/generic-resource-pools-ocata" target="_blank" rel="noopener">bp/generic-resource-pools-ocata</a></p><p>继续支持generic resource provider的基本能力，比如aggregate等。使用新的Placement及Resource tracker来对资源进行刷新和调度。</p><h3 id="Filter-the-list-of-ResourceProviders-that-match-a-request"><a href="#Filter-the-list-of-ResourceProviders-that-match-a-request" class="headerlink" title="Filter the list of ResourceProviders that match a request"></a>Filter the list of ResourceProviders that match a request</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/resource-providers-get-by-request" target="_blank" rel="noopener">bp/resource-providers-get-by-request</a></p><p>用户通过请求可以获取一个满足用户资源需求的Resource Provider的列表。</p><h3 id="Resource-providers-Move-scheduler-filters-to-DB"><a href="#Resource-providers-Move-scheduler-filters-to-DB" class="headerlink" title="Resource providers: Move scheduler filters to DB"></a>Resource providers: Move scheduler filters to DB</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/resource-providers-scheduler-db-filters" target="_blank" rel="noopener">bp/resource-providers-scheduler-db-filters</a></p><p>看着有点标题党的BP，把Filter全搞到DB了？实际上，只是在Filter&amp;Weight之前，加入了Placement请求的流程，相当于先通过Placement进行过滤，然后再进行后续的Filter和Weight。<br>这个BP标志着我们的Placement真正开始工作了，在每次的虚拟机创建的流程中，都增加了和Placement交互的流程，在大规模部署的环境中，我们不用一个一个host来过滤了，先通过Placement搞一把，会把不满足条件的节点过滤掉很多，大幅度提升调度的性能。</p><h3 id="Use-policies-for-authZ-in-placement-API"><a href="#Use-policies-for-authZ-in-placement-API" class="headerlink" title="Use policies for authZ in placement API"></a>Use policies for authZ in placement API</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/placement-api-policy-authz" target="_blank" rel="noopener">bp/placement-api-policy-authz</a></p><p>为Placement服务增加Policy机制。</p><h2 id="Pike版本"><a href="#Pike版本" class="headerlink" title="Pike版本"></a>Pike版本</h2><p>P版本特性列表：<a href="https://blueprints.launchpad.net/nova/pike" target="_blank" rel="noopener">链接</a></p><h3 id="Placement-Allocation-Requests"><a href="#Placement-Allocation-Requests" class="headerlink" title="Placement Allocation Requests"></a>Placement Allocation Requests</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/placement-allocation-requests" target="_blank" rel="noopener">bp/placement-allocation-requests</a></p><p>新增了一个allocation_candidates的接口，通过这个接口，支持用户请求资源，期待返回满足用户需求的resource provider。原来，在O版本的实现，仅支持返回单个的resource provider，这样对于共享及嵌套的rp有些问题，现在把这个接口增加后，使得用户可以进行更复杂的过滤。</p><h3 id="Scheduler-claiming-resources-to-the-Placement-API"><a href="#Scheduler-claiming-resources-to-the-Placement-API" class="headerlink" title="Scheduler claiming resources to the Placement API"></a>Scheduler claiming resources to the Placement API</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/placement-claims" target="_blank" rel="noopener">bp/placement-claims</a></p><p>将资源claim的过程从compute移动到scheduler中，主要有2个考虑：其一是减少从调度成功到claim时的时间，从而降低重试的可能，因为从scheduler拿到这个可选的请求，再到compute node进行claim，消耗时间较长，在资源较为紧张的时候，并发请求有可能在scheduler是满足的，但是真正到compute时，已经被其他人消耗了；其二是为了适配Cell V2的架构，Cell V2中，子Cell不应该反向去调用scheduler，比如在重试的时候。在Q版本，会有一个“调度备选节点列表”，配合这个，减少调度重试的可能。</p><h3 id="Allow-custom-resource-classes-in-flavor-extra-specs"><a href="#Allow-custom-resource-classes-in-flavor-extra-specs" class="headerlink" title="Allow custom resource classes in flavor extra specs"></a>Allow custom resource classes in flavor extra specs</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/custom-resource-classes-in-flavors" target="_blank" rel="noopener">bp/custom-resource-classes-in-flavors</a></p><p>允许在Flavor中定义自定义的resource class，并在调度的流程中增加处理这个extra specs的能力。形式类似于<code>resources:$CUSTOM_RESOURCE_CLASS=$N</code>或者<code>resources:$STANDARD_RESOURCE_CLASS=0</code>。</p><h3 id="Resource-providers-custom-resource-classes-Pike"><a href="#Resource-providers-custom-resource-classes-Pike" class="headerlink" title="Resource providers: custom resource classes (Pike)"></a>Resource providers: custom resource classes (Pike)</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/custom-resource-classes-pike" target="_blank" rel="noopener">bp/custom-resource-classes-pike</a></p><p>继续完善自定义资源类型的能力。</p><h3 id="Add-project-user-association-to-placement"><a href="#Add-project-user-association-to-placement" class="headerlink" title="Add project/user association to placement"></a>Add project/user association to placement</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/placement-project-user" target="_blank" rel="noopener">bp/placement-project-user</a></p><p>为Placement增加project和user的过滤能力，仅获取某个租户或者用户的资源情况。bp完成后，用户可以直接通过project和user去拿资源可用情况了，底层会直接从数据库过滤，而不是像现在的，全拿到然后再从所有结果中去统计。</p><h3 id="Idempotent-PUT-resource-class"><a href="#Idempotent-PUT-resource-class" class="headerlink" title="Idempotent PUT resource class"></a>Idempotent PUT resource class</h3><p>Link: <a href="https://blueprints.launchpad.net/nova/+spec/placement-put-resource-class" target="_blank" rel="noopener">bp/placement-put-resource-class</a><br>允许用户直接通过PUT来创建不存在的resource class，而不是先POST（创建）再PUT（更新）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备拿这篇文章梳理下OpenStack Nova调度相关的特性，由于目前Placement的引入，说起调度，和这个组件是分不开的，所以本文也可以看做是Placement的一个历史特性的梳理。第一阶段会按照版本，先把调度相关的BP过一遍，然后再通过理解和使用加强理解。好吧，我承认又开了一个系列的坑，话不多说，开始！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>跨Cell场景下查询的那些事儿</title>
    <link href="http://yikun.github.io/2017/11/16/%E8%B7%A8Cell%E5%9C%BA%E6%99%AF%E4%B8%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://yikun.github.io/2017/11/16/跨Cell场景下查询的那些事儿/</id>
    <published>2017-11-16T13:19:14.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>我们知道Nova目前正在慢慢地演进到Cell V2架构，Cell V2架构中，很重要的一个变化就是数据库的拆分，清晰的划分了数据库的职能，从而有具备横向扩展的能力。顶层数据库(nova_api)用来存储全局数据，而Cell中的数据库(nova_cellX)仅存储计算节点相关的数据。比如，创建虚拟机的全局数据，比如Flavor、Keypair之类的数据，放在上层的nova_api数据库中，而虚拟机本身的信息，比如某个虚拟机的信息，放在了子Cell中。</p><p><img src="https://user-images.githubusercontent.com/1736354/33543222-307b8974-d911-11e7-9993-5373720491df.jpg" alt="cell"></p><p>这样的架构另一个好处是Cell很轻松的可以实现扩展，从而提升虚拟机数量的规模。然而，这引入了一个问题，就是没有一个地方存储着全量虚拟机的数据了。当我们需要一些全局的虚拟机数据查询时（比如查询全量虚拟机列表）就比较棘手了。</p><a id="more"></a><h3 id="2-数据库的拆分"><a href="#2-数据库的拆分" class="headerlink" title="2. 数据库的拆分"></a>2. 数据库的拆分</h3><p>其实这样的架构在目前互联网业务中十分常见，随着业务量和历史数据的增长，很多业务都需要进行分表分库，切分的目的主要有2个，一是单个数据库的存储空间已经不足以支撑庞大的数据量，另外一个是单个数据库所能承载的连接数或者并发数不足以满足逐渐飙升的请求。一般来说，数据库的分库为垂直分库和水平分库。</p><p><img src="https://user-images.githubusercontent.com/1736354/33540293-5f4852ca-d905-11e7-8e48-04b111cdbdf2.jpg" alt="split"></p><ol><li><p>垂直分库。<br>一般按照功能划分，每个分库的功能不同。把不同功能查询或写入的负载均分到独立功能库中。例如，我们将一些基础信息独立成一个库，详细信息独立成一个库，这种按照功能的划分，将负载均衡，只需要基础信息的去访问基础库，需要详细信息的时候，再去查详细信息的库。<br>在Cell V2的架构中，我们可以将nova_api和nova_cellX的数据库划分看成是垂直划分，对于nova_api库来说，只用关心上层全局数据的存储处理，而对于nova_cell库来说需要关心的是每个子cell里面数据的存储处理。</p></li><li><p>水平分库。<br>一般通过某种方法把数据打散到不同的库中，每个库的表结构是相同的。例如，我们根据用户ID进行分库，可以通过映射表、取余、Hash的方式来确定某个用户的请求到底落到哪个数据库去查。<br>在Cell V2的架构中，每个Cell数据的划分，就可以看做是水平分库了，虚拟机按照一定的“规则”，落到了不同的Cell中。</p></li></ol><p>一般的业务演进，一般是先进行垂直分表分库，然后当用户或者数据规模达到一定程度后，再通过水平分库提升规模。就像OpenStack Nova一样，最开始所有的数据都聚集在一个叫Nova的库里，然后拆分出nova_api和nova，最后再将nova_cell拆出来，并根据虚拟机ID和Cell进行mapping，从而完成水平分库。</p><h3 id="2-引入的问题"><a href="#2-引入的问题" class="headerlink" title="2. 引入的问题"></a>2. 引入的问题</h3><p><img src="https://user-images.githubusercontent.com/1736354/33540482-43540b12-d906-11e7-99de-6fa30d29fcba.jpg" alt="mapping"></p><p>在Cell V2的场景下，对于单个虚拟机来说基本没什么变化，无非就是多了一个映射查询的步骤：先查找虚拟机所对应的Cell数据库，然后对这个数据库进行操作即可。</p><p>然而，由于水平切分导致每个Cell都丢失了“全局视角”，例如之前我们进行虚拟机列表查询时，在原来只需要在一个数据库查询，现在需要在多个数据库查询，尤其是需要指定一些全局参数进行查询时，比如limit、marker、sort等参数一加上，就更恶心了。</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>这个问题，在多Cell场景一直没有得到很好的解决，只是在各个Cell里面搜集各个cell排序好的数据，然后append到结果里面，也并没有进行最终排序。呈现给用户来看，就是数据是乱序的。</p><p>直到Q版本，Dan Smith大神提了一系列的<a href="https://review.openstack.org/#/q/topic:instance-list+(status:open+OR+status:merged" target="_blank" rel="noopener">instance-list Patch</a>)，初步解决了这个问题。</p><p><img src="https://user-images.githubusercontent.com/1736354/33541997-310a2d28-d90c-11e7-860b-9302f33af6d5.jpg" alt="paging"></p><p>我们先看看他的实现，这一系列的Patch最关键的实现在<a href="https://github.com/openstack/nova/blob/f4b3b77511366115a5ecef23d8d145ab9c4d953a/nova/compute/instance_list.py" target="_blank" rel="noopener">instance_list.py</a>中，大致的撇一眼整体的实现，<strong>全局/局部marker</strong>、<strong>并行搜集跨Cell数据</strong>、<strong>heap归并排序</strong>，相信从这几个关键词中你已经猜到了实现的大概逻辑。下面，我们先整体介绍一下整体的实现逻辑，然后再对实现细节做详细的解释。</p><p>我们举个例子，来看看在跨cell场景下，如果获取一个虚拟机的列表</p><p>假设我们有2个cell，里面有编号为i0~i5的6个虚拟机，从i0到i5，按顺序依次创建。当我们查询全量虚拟机时，按照创建时间逆序，我们期待得到的结果是<code>i5 i4 i3 i2 i1 i0</code>。再传递limit=2/sort=orderby(created_at,desc)/marker(i5)之后，处理的过程如下：</p><h4 id="Step-1-查找全局marker。"><a href="#Step-1-查找全局marker。" class="headerlink" title="Step 1 查找全局marker。"></a>Step 1 查找全局marker。</h4><p>我们首先需要在各个Cell中查找，<code>i5</code>是否存在。对于虚拟机来说，比较简单，在nova_api数据库中存在instance_mappings表，这个表里面记录了虚拟机和cell的映射关系，如果marker在cell中，我们直接可以从mapping表中找到它及其对应的cell。<br>我们的例子中，我们找到了位于cell2中的<code>i5</code>。</p><p><img src="https://user-images.githubusercontent.com/1736354/33542019-3f48325e-d90c-11e7-9b9a-9943b4dc7ede.jpg" alt="gmarker"></p><p>参考代码：<a href="https://github.com/openstack/nova/blob/3a19f89f34a1eaee7eec2dcc7b809058d61950f0/nova/compute/instance_list.py#L134,L142" target="_blank" rel="noopener">nova/compute/instance_list.py#L134,L142</a><br>具体获取marker时，是先在instance_mapping中查找了marker所在的cell，然后，在target_cell拿到了marker的信息，参考代码<a href="https://github.com/openstack/nova/blob/3a19f89f34a1eaee7eec2dcc7b809058d61950f0/nova/compute/instance_list.py#L66,L88" target="_blank" rel="noopener">nova/compute/instance_list.py#L66,L88</a>。</p><h4 id="Step-2-并行查询子Cell中的local-marker，并获取满足条件的虚拟机。"><a href="#Step-2-并行查询子Cell中的local-marker，并获取满足条件的虚拟机。" class="headerlink" title="Step 2 并行查询子Cell中的local marker，并获取满足条件的虚拟机。"></a>Step 2 并行查询子Cell中的local marker，并获取满足条件的虚拟机。</h4><p><img src="https://user-images.githubusercontent.com/1736354/33542026-4784411a-d90c-11e7-8499-b24ef3a4cd03.jpg" alt="finding"></p><p>在第一步中，我们拿到了i5的信息，由于排序是按照created_at，逆序，那我们查询local marker的时候，只需要一条SQL就可以拿到Cell中满足条件的local marker：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> instances <span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">where</span> created_at &lt;= i5.created_at</span><br></pre></td></tr></table></figure></p><p>然后，我们再根据这个local marker就可以拿到满足条件的虚拟机列表了。当然，我们需要各取limit个，因为也许最终满足条件的都在一个cell中，所以，我们取得的虚拟机列表中虚拟机的个数应该按照全局limit来获取。<br>值得注意的是，local marker如果不是global marker的话，我们需要把local marker也算在满足条件的列表中，因为全局来看，这个marker也是满足用户条件的。如果local marker也刚好就是global marker，那这个marker就不用管了。<br>参考代码<a href="https://github.com/openstack/nova/blob/3a19f89f34a1eaee7eec2dcc7b809058d61950f0/nova/compute/instance_list.py#L166,L212" target="_blank" rel="noopener">nova/compute/instance_list.py#L166,L212</a>，先找到满足条件的第一个local marker，然后就按照之前的流程，获取marker之后的记录就可以了。</p><h4 id="Step-3-合并排序。"><a href="#Step-3-合并排序。" class="headerlink" title="Step 3 合并排序。"></a>Step 3 合并排序。</h4><p>在步骤2中，我们会得到2个列表，分别是从cell1和cell2中拿到的数据。这两个列表是有序的，但是当我们合并后，需要进行全局重排序。这样，我们就拿到了有序的列表。<br><img src="https://user-images.githubusercontent.com/1736354/33542040-5001b066-d90c-11e7-8bbb-b1119c30d037.jpg" alt="merge"></p><p>参考代码<a href="https://github.com/openstack/nova/blob/3a19f89f34a1eaee7eec2dcc7b809058d61950f0/nova/compute/instance_list.py#L228,L234" target="_blank" rel="noopener">nova/compute/instance_list.py#L228,L234</a>，可以看到，由于每个cell拿到的数据都是有序的，因此，最终排序的时候，也是用了heapq这个数据结构，来高效的完成有序列表的合并排序。</p><h4 id="Step-4-进行limit操作。"><a href="#Step-4-进行limit操作。" class="headerlink" title="Step 4 进行limit操作。"></a>Step 4 进行limit操作。</h4><p>最后，我们在第三步的结果上，进行limit操作就好了。在合并的过程中，对limit进行检查，最终，完成limit且排好序的结果。<br><img src="https://user-images.githubusercontent.com/1736354/33542045-5555ae1e-d90c-11e7-98b9-20eab3a9820a.jpg" alt="limit"></p><h3 id="4-The-end-the-begin"><a href="#4-The-end-the-begin" class="headerlink" title="4. The end, the begin."></a>4. The end, the begin.</h3><p>Instance list给我们示范了一个跨Cell场景下列表的实现，主要有2个地方很有亮点，一个是并行的查询各个Cell的数据，一个是最终排序选择了heapq作为排序的结构，在保证分页正常的情况下，也兼顾了性能。<br>比较残忍的是，随着跨Cell迁移的支持，几乎后续所有和子Cell数据相关的列表查询，都需要进行跨Cell的支持，比如migration、instance action。</p><p>架构很丰满，实现很骨感。不多说了，滚去写cross cell support的patch了。：）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h3&gt;&lt;p&gt;我们知道Nova目前正在慢慢地演进到Cell V2架构，Cell V2架构中，很重要的一个变化就是数据库的拆分，清晰的划分了数据库的职能，从而有具备横向扩展的能力。顶层数据库(nova_api)用来存储全局数据，而Cell中的数据库(nova_cellX)仅存储计算节点相关的数据。比如，创建虚拟机的全局数据，比如Flavor、Keypair之类的数据，放在上层的nova_api数据库中，而虚拟机本身的信息，比如某个虚拟机的信息，放在了子Cell中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/1736354/33543222-307b8974-d911-11e7-9993-5373720491df.jpg&quot; alt=&quot;cell&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样的架构另一个好处是Cell很轻松的可以实现扩展，从而提升虚拟机数量的规模。然而，这引入了一个问题，就是没有一个地方存储着全量虚拟机的数据了。当我们需要一些全局的虚拟机数据查询时（比如查询全量虚拟机列表）就比较棘手了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[译] An Update on the Placement API and Scheduler plans for Queens</title>
    <link href="http://yikun.github.io/2017/10/25/%E8%AF%91-An-Update-on-the-Placement-API-and-Scheduler-plans-for-Queens/"/>
    <id>http://yikun.github.io/2017/10/25/译-An-Update-on-the-Placement-API-and-Scheduler-plans-for-Queens/</id>
    <published>2017-10-25T06:10:07.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://github.com/jaypipes/articles/blob/master/openstack/placement-queens-update.md" target="_blank" rel="noopener">https://github.com/jaypipes/articles/blob/master/openstack/placement-queens-update.md</a></p><p>这篇文章主要讲了在过去几个版本中，OpenStack社区对于Nova调度及Placement服务相关工作的更新进展。我也会着重介绍一些我们在Q版本中主要处理的几个BP，同时也介绍了未来重点工作的路标，我们会在未来的几个release中完成它们。</p><a id="more"></a><h3 id="1-过去版本完成情况的总结"><a href="#1-过去版本完成情况的总结" class="headerlink" title="1. 过去版本完成情况的总结"></a>1. 过去版本完成情况的总结</h3><p>Placement API已经在OpenStack的N版本成为一个独立的API endpoint。</p><p>Placement API将存量记录(tracking inventory)、资源消耗(resource consumption)、资源的分组和共享(grouping and sharing of resources)以及表示资源所具能力字符串标签（string capability tags, traits）这些数据暴露出来。</p><p>从那之后，社区持续地改进API，并且在Nova中更进一步地进行集成。</p><p>在Newton版本，主要是让nova-compute正确地对本地的资源进行盘点，然后把这些inventory记录送到Placement API中。</p><p>在Ocata版本，我们开始将nova-scheduler服务与Placement API进行集成。我们在scheduler进行了一些修改，使用Placement API进行满足一些基本资源请求条件的计算节点过滤。我们也添加了aggregates，来提供resource provider的分组机制。</p><p>在Pike版本，我们主要将资源claim这个步骤从nova-compute移动到nova-scheduler中。做这个事主要有2个原因：一个是性能/扩展以及和Cells V2架构适配。在”候选主机列表及cell中重试”一节中，进行了详细介绍。</p><h3 id="2-Queens版本的优先级"><a href="#2-Queens版本的优先级" class="headerlink" title="2. Queens版本的优先级"></a>2. Queens版本的优先级</h3><p>在丹佛的PTG中，Nova社区团队决定了在调度和资源placment功能中3个主要的工作：</p><ol><li>妥当地处理迁移操作</li><li>在多cell中的备选主机列表及重试操作</li><li>嵌套的resource provider</li></ol><p>应该指出的是，我们理解在这个领域仍然有许多许多的新功能需求，一些已经在我们的“雷达”中很多年了。我们承认当一些管理员或者一些潜在的用户看到一些长时间存在的问题或者工作并没有出现在Queens版本的高优先级列表中，会有点沮丧。然而，core团队实际能够review的东西是有限的，所以我们必须做这些决策。当然，我们也非常欢迎大家在PTG和邮件列表里来讨论这些决策。</p><p>另外一个应该指出的是，尽管在Q版本的scheduler和resource placement领域中，仅有这3个高优先级工作，但这并不意味着其他的工作不能被review或者推进。这个仅代表core团队将重点review这些领域的patch。</p><h3 id="3-正确的处理移动操作"><a href="#3-正确的处理移动操作" class="headerlink" title="3. 正确的处理移动操作"></a>3. 正确的处理移动操作</h3><p>我们在Q版本第一优先级需要处理的是做与placement API相关的move操作（比如migrate、resize、evacuate、unshelve等）的收尾及测试用例的全覆盖。</p><p>在Pike版本所剩时间不多时，Balasz Gibizer、Dan Smith和Matt Riedemann发现了一系列问题：在做Nova支持的各种各样的move操作时，资源应该如何在Placement API中记录。在Pike版本的时候，我们开始在nova-scheduler服务里进行资源的claim。很显然我们也需要在move操作的时候进行claim处理。在最初版本的实现，在虚拟机迁移的过程中，我们为虚拟机创建了一个成对的allocation，源节点和目的节点的资源都会占用一条allocation记录。这样做，可以工作，但是这个方案明显有弊端，尤其是在我们在同节点进行resize的操作。</p><p>这产生了一系列关于在迁移时产生错误的或者丢了一些allocation记录的问题，我们需要在resource tracker和compute manger中，塞了很多不优雅的代码，来处理在滚动升级中新的conductor和scheduler服务的兼容，并且旧的计算节点也写入了不正确的记录。</p><p>Dan Smith也提出了一个解决在迁移操作中记录allocation问题的方法<a href="http://specs.openstack.org/openstack/nova-specs/specs/queens/approved/migration-allocations.html" target="_blank" rel="noopener">migration-allocations</a>，但是因为时间问题，我们没办法在Pike版本实现。</p><p>在Queens版本，我们需要优选Dan的解决方案，即在迁移之前，在allocation记录中，将源节点的UUID替换为迁移object自己的UUID。这样允许目的节点使用虚拟机的UUID来占用allocation，一旦迁移成功，我们便可仅仅删除被migration UUID消费的allocation就行了。再也不用受双倍的allcations困扰了。</p><h3 id="4-候选主机列表及cell中重试"><a href="#4-候选主机列表及cell中重试" class="headerlink" title="4. 候选主机列表及cell中重试"></a>4. 候选主机列表及cell中重试</h3><p>第二优先级的事情是，我们应该在Cells V2部署中支持创建虚拟机请求的重试能力。</p><p>上面，我已经说过了，将资源claim的过程从compute移动到scheduler中，有两个原因，让我们来仔细讨论一下。</p><p>首先，现在的版本存在一个问题：2个scheduler进程为2个虚拟机选择同一个host时，当启动虚拟机先第一个host启动完成时，消耗了host的最后一点资源。然后，不幸的第2个启动进程，必须进行重新调度流程。这个流程有点太重了，sheduler必须通过通过RPC来为虚拟机获取一个新的目的节点，然后许多状态都需要通过request spec来传递。补充一下，并没有什么能够确保新的节点就一定可用，可能同样的命运将降临，再一次触发了重试。</p><p>在nova-scheduler代替目的计算节点来进行资源claim操作，意味着我们可以显著的减少在compute节点进行claim的时间和复杂性（造成重试操作的主要原因是在计算节点claim资源的竞争和竞态条件）</p><p>现在我们尝试在scheduler服务选择目标主机的时候，进行资源的claim操作。如果Placment API返回200 OK，我们就知道虚拟机已经在目的节点已经占用了这个资源，唯一可能造成重试的操作就是某些不正常的主机失败，即不是常见的失败原因。如果Placement API返回409冲突，我们可以从返回的error中看到失败原因，到底是因为并发刷新失败了，还是说目的节点确实没有足够的空间来容纳虚拟机。</p><p>如果另外的进程在目标主机完成资源claim的时间介于虚拟机调度选择和尝试claim资源之间，我们会简单的重试（在scheduler代码的小循环）尝试在目的主机claim资源。如果目的主机资源耗尽了，scheduler会选择另外的目的主机。我们完成这些时，不会启动的请求发送到目标的compute主机。</p><p>我们将资源的claim移动到scheduler的第二个原因，是因为Cells V2架构。再次说明，Cells V2架构移除了独立分离又略显奇葩的Cells V1旧代码。单单使用的Cells V2 API控制面，意味着能够更简单也更容易地进行代码维护。</p><p>然而，Cells V2设计架构的一个原则是一个启动（或者移动）虚拟机请求会获取到目标的cell，他没有向上调用的能力与API层进行通信。这对于我们目前的重试机制来说是一个问题。当前的重试机制依靠失败的计算节点来初始化资源的claim，并且能够反向调用scheduler，来找到另外的host进行虚拟机的启动。</p><p>Ed Leafe正在Quees版本努力，让scheduler从API/Scheduler传递一系列备选主机和allocation到目标的cell。这个备选主机和allocation信息，将会被cell的conducotr用来去那些备选的目的节点去重试，虚拟机资源的claim依靠备选host，无需访问上层的API/Scheduler。</p><h3 id="5-嵌套的resource-providers"><a href="#5-嵌套的resource-providers" class="headerlink" title="5. 嵌套的resource providers"></a>5. 嵌套的resource providers</h3><p>第三优先级的事情是我们称之为”嵌套的resource providers”的东西。</p><p>例如，NUMA Cells和包含它的主机，SR-IOV网卡功能和包含它的主机，物理GPU组和包含它的主机。</p><p>让我们举个2个计算节点的例子，2个节点每个都含有2个SR-IOV网卡。第一个计算节点每个网卡都有8个虚拟机网卡，第二个计算节点其中的一个物理网卡被标记为直通的（意味着用户能够全面掌控）另外一个网卡则被指为8个虚拟机网卡，与第一个计算节点类似。</p><p><img src="https://user-images.githubusercontent.com/1736354/32042485-4af9dfd2-ba6a-11e7-8d3c-121ff9945bfa.png" alt="nested-resource-providers-advanced-topo"></p><p>目前，Placement API无法理解父子provider这层关系。嵌套的resource provider这个spec和patch让Placement服务能够感知到这些，也允许用户区分子资源provider的父资源provider的UUID。</p><p>嵌套的resource provider开启了一系列的功能，包括PCI设备、高级网络、NUMA等的支持。正因如此，我们将共享的resource provider在Q版本放在了相对来说不重要的位置，然后更专注实现基本的嵌套resource provider，至少支持SR-IOV物理功能和虚拟功能的关系。</p><h3 id="6-Queens其他的工作事项"><a href="#6-Queens其他的工作事项" class="headerlink" title="6. Queens其他的工作事项"></a>6. Queens其他的工作事项</h3><p>除了上面的优先级事项，我们也将投入精力去做其他的一些事物。尽管review将专注在上述的优先级高的事物中，我们也将在下述的几个方面尽可能地进行review。</p><h4 id="1-完成trait-flavor"><a href="#1-完成trait-flavor" class="headerlink" title="(1) 完成trait-flavor"></a>(1) 完成trait-flavor</h4><p>这个是从Pike版本开始出现需要完成的工作。Placement API现在支持traits列表，简单的tags字符串来描述一个resource provider的能力。</p><p>然而，一些地方仍然需要编码完成。</p><ul><li>Flavor中需要包含需要的traits列表</li><li>Scheduler需要向Placement API过滤那些某个flavor要求的所有traits的providers</li><li>Virt drivers需要开始上报traits给计算节点的resource provider，来取代之前上报一个无结构的virt-driver-specific在virt driver的get_available_resource。</li></ul><h4 id="2-Ironic-virt-driver的traits处理"><a href="#2-Ironic-virt-driver的traits处理" class="headerlink" title="(2) Ironic virt driver的traits处理"></a>(2) Ironic virt driver的traits处理</h4><p>如上面提到的，virt driver需要开始上报traits信息给计算节点的resource provider。然而，ironic driver有点不同，因为他处理了多个计算节点的resource provider记录（有一个resource provider记录着部署的每个Ironic裸机节点）</p><p>Jhon Garbutt在主要负责Ironic API支持在virt driver中上报traits。</p><h4 id="3-在Placement-API中缓存header处理"><a href="#3-在Placement-API中缓存header处理" class="headerlink" title="(3) 在Placement API中缓存header处理"></a>(3) 在Placement API中缓存header处理</h4><p>Chris Dent提出了在Placement API中的一些资源endpoints增加”Last-Modified”和其他的HTTP头部。确保在cahcing代理下的正确行为非常重要，并且完成这项工作的工作量似乎是可以控制的。</p><h4 id="4-在Placement-API中支持POST多个allocations"><a href="#4-在Placement-API中支持POST多个allocations" class="headerlink" title="(4) 在Placement API中支持POST多个allocations"></a>(4) 在Placement API中支持POST多个allocations</h4><p>这个spec实际上是为了move操作的清理而开启的。Chris提出允许PORST /allocations调用（我们目前支持PUT /allocations/{consumer_uuid}调用）来支持在一个请求中写入多个consumers的多条allocation记录。这个将允许我们完成allocation从instance到migrations UUID的转换，这个是Dan Smith做move操作资源跟踪方案的一部分。</p><h4 id="5-初步支持vGPU"><a href="#5-初步支持vGPU" class="headerlink" title="(5) 初步支持vGPU"></a>(5) 初步支持vGPU</h4><p>尽管这个不像从Citrix的Jianghua Wang提出的spec来完全实现vGPU，在Queens版本，我们仍将尝试至少完成vGPU资源的基本支持。</p><p>基础的支持意味着可能不会支持多GPU类型或者pGPU池（换句话说，仅支持每个计算节点的VGPU有一个单一的inventory记录）。</p><h3 id="7-Beyond-Queens"><a href="#7-Beyond-Queens" class="headerlink" title="7. Beyond Queens"></a>7. Beyond Queens</h3><h4 id="1-一个通用的设备管理"><a href="#1-一个通用的设备管理" class="headerlink" title="(1) 一个通用的设备管理"></a>(1) 一个通用的设备管理</h4><p>Eric Fried和我正在讨论一个generic device manager，将会在已存在的nova/pci模块中替换很多代码。我们可能最早在Rocky版本完成。</p><h4 id="2-支持NUMA"><a href="#2-支持NUMA" class="headerlink" title="(2) 支持NUMA"></a>(2) 支持NUMA</h4><p>尽管嵌套的resource provider是为NUMA拓扑设计的，实际上，想要能够通过Placment API同等功能的把NUMATopologyFilter在Nova scheduler取代，仍然还有很长时间，可能在Rokcy版本吧。</p><p>在Nova支持NUMA的实现与支持大页内存、CPU pining、模拟IO线程pinning甚至是PCI设备管理（比如PCI设备的NUMA亲和性）是强耦合的。</p><p>似乎在可以看到的将来，NUMATopologyFilter仍然在Nova Scheduler保留，作为一个复杂自定义的调度failer/weigher，我们会慢慢的修改virt driver接口和resource tracker在nova-compute节点向Placement API上报NUMA cells信息作为resource provider。渐渐地通过查询Plament database来替换一些NUMATopologyFilter的功能。</p><h4 id="3-共享的resource-provider"><a href="#3-共享的resource-provider" class="headerlink" title="(3) 共享的resource provider"></a>(3) 共享的resource provider</h4><p>Placement API允许resource provider通过aggregate关联来和其他provider来共享资源。这些reousrce provider我们称之为”shared resource providers”，尽管使用”sharing resource providers”更能合适地表达其目标。</p><p>我们需要为共享存储和路由网络IP池的用力完成和增加一些功能测试，确保资源上报和跟踪正确的完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接：&lt;a href=&quot;https://github.com/jaypipes/articles/blob/master/openstack/placement-queens-update.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jaypipes/articles/blob/master/openstack/placement-queens-update.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章主要讲了在过去几个版本中，OpenStack社区对于Nova调度及Placement服务相关工作的更新进展。我也会着重介绍一些我们在Q版本中主要处理的几个BP，同时也介绍了未来重点工作的路标，我们会在未来的几个release中完成它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Nova虚拟机冷迁移流程解析</title>
    <link href="http://yikun.github.io/2017/10/11/OpenStack-Nova%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%B7%E8%BF%81%E7%A7%BB%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yikun.github.io/2017/10/11/OpenStack-Nova虚拟机冷迁移流程解析/</id>
    <published>2017-10-11T08:36:09.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>虚拟机冷迁移由于当用户想把虚拟机从一个计算节点移动到其他节点。主要涉及的命令如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> nova migrate server_id</span><br><span class="line"><span class="meta">$</span> nova resize-confirm server_id</span><br></pre></td></tr></table></figure></p><p>看到后是不是觉得有点奇怪为啥migrate之后，还要resize-confirm？resize操作其实和migrate操作比较类似，不同的是迁移前后的flavor不一样。一般情况下resize的场景是，对虚拟机进行扩容，把flavor调大之类的。所以，在代码级别，nova也将两个流程合一了。migrate就是一个没有flavor变化的resize。</p><a id="more"></a><h3 id="2-核心流程"><a href="#2-核心流程" class="headerlink" title="2. 核心流程"></a>2. 核心流程</h3><p>下图是虚拟机冷迁移时，涉及的组件交互：<br><img src="https://user-images.githubusercontent.com/1736354/31429902-dd65687a-aea1-11e7-9209-06c37a09fe4b.png" alt="instance migrate overview"><br>我们可以看到，在迁移时，主要流程包括调度、迁移准备、迁移、完成迁移。</p><ol><li>调度。conducotr通过select_destination访问Scheduler进行<strong>调度</strong>，最终选择一个可用的目的节点；</li><li>prep_resize阶段，迁移准备。在目的主机上进行一些检查，比如是否支持相同节点迁移、虚拟机的主机等检查。然后，生成了一个resize claim（不是真正的claim，目前看这个只是刷新的resource tracker的一些数据），并在Placment刷新了inventory信息。</li><li>resize_instance阶段，在源节点把网络、磁盘之类的断掉，并且将数据复制到目的节点；</li><li>迁移结束。在目的节点配置网络、挂卷，启动虚拟机；</li><li>(resize-confirm)确认迁移。使用nova resize-confirm确认删除，把原来网络断掉，并完成源虚拟机数据及中间虚拟机数据的清空。</li></ol><p>具体细节，包括迁移的状态变化，如下图所示：<br><img src="https://user-images.githubusercontent.com/1736354/31435001-ace4c0a6-aeb0-11e7-99b9-c414411b7eaa.png" alt="2 instance migrate"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;虚拟机冷迁移由于当用户想把虚拟机从一个计算节点移动到其他节点。主要涉及的命令如下：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; nova migrate server_id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; nova resize-confirm server_id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看到后是不是觉得有点奇怪为啥migrate之后，还要resize-confirm？resize操作其实和migrate操作比较类似，不同的是迁移前后的flavor不一样。一般情况下resize的场景是，对虚拟机进行扩容，把flavor调大之类的。所以，在代码级别，nova也将两个流程合一了。migrate就是一个没有flavor变化的resize。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Nova虚拟机创建流程解析</title>
    <link href="http://yikun.github.io/2017/09/27/OpenStack-Nova%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yikun.github.io/2017/09/27/OpenStack-Nova虚拟机创建流程解析/</id>
    <published>2017-09-27T03:15:15.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Nova是OpenStack中处理计算业务（虚拟机、裸机、容器）的组件，整体的虚拟机创建流程自然是学习和熟悉Nova组件的第一步。本篇文章主要基于OpenStack Pike版本，基于最新的Cell v2架构部署为例，来介绍虚拟机的创建流程，并分析了Pike等最近几个版本中，虚拟机创建流程的关键变化。</p><a id="more"></a><h2 id="2-虚拟机创建流程"><a href="#2-虚拟机创建流程" class="headerlink" title="2. 虚拟机创建流程"></a>2. 虚拟机创建流程</h2><p><img src="https://user-images.githubusercontent.com/1736354/31421492-36a84bdc-ae7a-11e7-94b3-d85fab04762c.png" alt="instance create pike"></p><p>上图是虚拟机创建流程的整体流程，可以看到整体虚拟机创建流程一次经过了API、Conductor、Scheduler、Placement、Compute等主要服务，下面我们逐步介绍下虚拟机创建时，这些服务做的一些事情以及在Pike版本新引入的部分：</p><h3 id="2-1-Nova-API"><a href="#2-1-Nova-API" class="headerlink" title="2.1 Nova-API"></a>2.1 Nova-API</h3><p>在OpenStack的组件中，基本每个组件都会有一个API服务，对于Nova来说API服务主要的作用就是接收由用户通过Client或者一些其他REST请求工具（比如 curl、postman）发送的请求。一般来说会包含一些虚拟机创建的参数，比如虚拟机的规格、可用域之类的信息。</p><p>在虚拟机创建的流程中，API就是Nova的入口，当API接收到请求后，主要会处理一些关于参数校验、配额检测等事务。</p><h4 id="1-参数校验"><a href="#1-参数校验" class="headerlink" title="1. 参数校验"></a>1. 参数校验</h4><p>例如，我们指定镜像和规格来创建一个虚拟机时，通常会使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nova --debug boot --image 81e58b1a-4732-4255-b4f8-c844430485d2 --flavor 1 yikun</span><br></pre></td></tr></table></figure></p><p>我们通过<code>--debug</code>来开启debug模式，来看看命令行究竟做了什么事，可以从回显中，看到一个关键的信息：</p><blockquote><p>curl -g -i -X POST <a href="http://xxx.xxx.xxx.xxx/compute/v2.1/servers" target="_blank" rel="noopener">http://xxx.xxx.xxx.xxx/compute/v2.1/servers</a> -H “Accept: application/json” -H “User-Agent: python-novaclient” -H “OpenStack-API-Version: compute 2.53” -H “X-OpenStack-Nova-API-Version: 2.53” -H “X-Auth-Token: $token” -H “Content-Type: application/json” -d <strong>‘{“server”: {“name”: “yikun”, “imageRef”: “81e58b1a-4732-4255-b4f8-c844430485d2”, “flavorRef”: “1”, “max_count”: 1, “min_count”: 1, “networks”: “auto”}}’</strong></p></blockquote><p>我们可以看到虚拟机创建时，传入了一些诸如虚拟机名称、镜像、规格、个数、网络等基本信息。在API中，首先就会对这些参数进行校验，比如镜像ID是否合法、网络是否正确等。</p><h4 id="2-配额检测"><a href="#2-配额检测" class="headerlink" title="2. 配额检测"></a>2. 配额检测</h4><p>值得一提的是，在Pike版本的虚拟机创建开始时，对配额检测进行了优化。</p><p>我先看看之前的实现，在之前版本的Nova中，Quota检测过程相对来说比较复杂，首先会进行reserve操作，对资源进行预占，然后预占成功，并且创建成功后，最终会进行commit操作。然而，为了保证在并发的场景下，不会对超过用户配额（这都是钱啊！），因此在reserve和commit进行资源更新的时候都会quota相关的数据表的用户相关行加把锁，也就是说更新quota记录的时候，一个用户去更新时，其他用户再想刷新只能等着，直到前一个用户完成数据库记录刷新为止，这样就大大降低的效率，并发的性能也就不是很客观了。</p><p>另外，由于需要对cell v2进行支持，目前所有的quota表均已移动到API的数据库了可以参考BP<a href="https://specs.openstack.org/openstack/nova-specs/specs/ocata/approved/cells-quota-api-db.html" target="_blank" rel="noopener">CellsV2 - Move quota tables to API database</a>。Cell V2的设计思想是，由API、Super Conductor去访问上层的全局数据库（nova_api数据库），而底下的cell中的组件，只需要关心cell中的逻辑即可。因此，为了彻底的解耦，让cell中的compute无需再访问api数据库进行诸如commit操作，在Pike版本，社区对quota机制进行了优化，详情可以参考<a href="https://specs.openstack.org/openstack/nova-specs/specs/pike/approved/cells-count-resources-to-check-quota-in-api.html" target="_blank" rel="noopener">Count resources to check quota in API for cells</a>这个BP。</p><p>因此Pike版本之后，配额检测变成了这样：</p><ol><li>首先，api中进行第一次Quota检测，主要方法就是收集地下各个cell数据库中的资源信息，然后和api数据库中的quota上限进行对比。例如，一个用户可以创建10个虚拟机，在cell1中有2个，cell2中有7个，再创建一个虚拟机时，会搜集cell1和cell2中的虚拟机个数之和（9个），然后加上变化（新增一个），与总配额进行比较。</li><li>二次检测（cell v2在super conductor里做）。由于在并发场景下，可能出现同时检测发现满足，之后进行创建，就会造成配额的超分，针对这个问题，社区目前给出的方案是，在创建虚拟机记录之后，再进行recheck，如果发现超额了，会将超额分配的虚拟机标记为ERROR，不再继续往下走了。</li></ol><p>每次检测的逻辑都调用相同的函数，具体逻辑如下图所示：<br><img src="https://user-images.githubusercontent.com/1736354/30894282-6c4a59c0-a375-11e7-8396-c3faad0a683d.png" alt="quota check"></p><h3 id="2-2-Nova-Super-Conductor"><a href="#2-2-Nova-Super-Conductor" class="headerlink" title="2.2 Nova Super Conductor"></a>2.2 Nova Super Conductor</h3><p>Super Conductor在创建虚拟机的流程其实和之前差不多，选个合适的节点（调度），然后，写入虚拟机相关的记录，然后，投递消息到选定的Compute节点进行虚拟机的创建。</p><p>在Cell v2场景，虚拟机的创建记录已经需要写入的子cell中，因此，conductor需要做的事，包括一下几个步骤：</p><ol><li>进行调度，选出host。</li><li>根据host，通过<strong>host_mappings</strong>找到对应的cell</li><li>在对应的cell db中创建虚拟机记录，并且记录<strong>instances_mappings</strong>信息</li><li>通过cell_mappings来查找对应的cell的mq，然后投递到对应的cell中的compute</li></ol><p>完成这些操作时，需要牵扯到3个关键的数据结构，我们来简单的看一下：</p><ul><li>host_mappings：记录了host和cell的映射信息</li><li>instances_mappings：记录了虚拟机和cell的映射信息</li><li>cell_mappings：记录了cell和cell对应的mq的映射信息</li></ul><p>与Cell v1不太相同，在目前的设计中，认为scheduler能看到的应该是底下能够提供资源的具体的所有的Resource Provider（对于计算资源来说，就是所有的计算节点），而不是整个cell，也就是说所有cell中的资源scheduler都可以看到，而子cell就负责创建就好了。因此，在super conductor中，需要做一些transfer的事情，这样也就不必在像cell v1那样，在子cell里还得搞个scheduler去做调度。</p><h3 id="2-3-Nova-Scheduler"><a href="#2-3-Nova-Scheduler" class="headerlink" title="2.3 Nova-Scheduler"></a>2.3 Nova-Scheduler</h3><p>刚才我们在conductor中，已经介绍了，在选择具体哪个节点来创建虚拟机时，调用了Scheduler的select_destination方法，在之前的版本的调度中，就是OpenStack最经典的Filter&amp;Weight的调度，已经有大量的资料介绍过具体的实现和用法。可以参考官方文档<a href="https://docs.openstack.org/nova/latest/user/filter-scheduler.html" target="_blank" rel="noopener">Filter Scheduler</a>。</p><p>在Pike版本中，在调度这部分还是做了比较大的调度，主要就是2个相关变动。</p><ol><li><p>通过Placement获取可用的备选资源，参考<a href="https://specs.openstack.org/openstack/nova-specs/specs/pike/approved/placement-allocation-requests.html" target="_blank" rel="noopener">Placement Allocation Requests</a>的实现。<br>在Ocata版本时，<a href="https://specs.openstack.org/openstack/nova-specs/specs/ocata/implemented/resource-providers-scheduler-db-filters.html" target="_blank" rel="noopener">Resource Providers - Scheduler Filters in DB</a>这个BP就已经在调度前加了一步，获取备选节点。从BP的标题就可以看出，设计者想通过Placement服务提供的新的一套机制，来做过滤。原因是之前的调度需要在scheduler维护每一个compute节点的hoststate信息，然后调度的时候，再一个个去查，这太低效了，尤其是在计算节点数目比较多的时候。因此，增加了一个“预过滤”的流程，通过向Placement查询，Placement服务直接通过SQL去查一把，把满足条件（比如CPU充足、RAM充足等）先获取到。<br>而原来获取备选节点的时候，只支持获取单一的Resource Provider，这个BP增强了获取备选资源的能力，用于后续支持更复杂的请求，比如共享资源、嵌套资源的Provider查询。后面，Placement还会陆续支持更多的请求，比如对一些非存量不可计数的资源的支持。这样留给后面Filter&amp;Weight的压力就小一些了，再往后，会不会完全取代Filter呢？我想，现有的各种过滤都可以通过Placement支持后，完全有可能的。</p></li><li><p>Scheduler通过Placement来claim资源。参考<a href="https://blueprints.launchpad.net/nova/+spec/placement-claims" target="_blank" rel="noopener">Scheduler claiming resources to the Placement API</a>的实现。<br>在最早的时候，claim资源是由compute来做的，现在相当于提前到scheduler去搞了。有什么好处呢？我们先看看原来的问题：<br>调度时刻和真正的去compute节点去claim资源的时刻之间是由一段时间的，在资源不是那么充足的环境，就会造成在scheduler调度的时候，资源还没刷新，所以调度时候成功了，但是真正下来的时候，才发现compute实际已经没有资源了，然后又“跨越半个地球”去做重调度，无形地增加了系统的负载。<br>而且增加了创建的时长（哦，哪怕创建失败呢？），你想想，用户创了那么久的虚拟机，最后你告诉我调度失败了，用户不太能忍。<br>所以这个BP就把Claim资源放在调度处了，我上一个调度请求处理完，马上就告诉placement，这资源老子用了，其他人不要动了。OK，世界终于清净了，能拿到资源的拿到了，拿不到资源的马上也知道自己拿不到了，大大增强了调度的用户体验。</p></li></ol><h3 id="2-4-Placement"><a href="#2-4-Placement" class="headerlink" title="2.4 Placement"></a>2.4 Placement</h3><p>恩，在调度的时候，已经介绍过这个服务了，在虚拟机创建的流程中，比较常用的接口就是获取备选资源和claim资源。<br>Placement目标很宏伟，大致的作用就是：资源我来管，要资源问我要，用了资源告诉我。后面准备用一篇文章整体介绍一下Placement。（yep，这个Flag我立下了，会写的）</p><h3 id="2-5-Nova-Compute"><a href="#2-5-Nova-Compute" class="headerlink" title="2.5 Nova-Compute"></a>2.5 Nova-Compute</h3><p>好吧，到最后一个服务了，Compute。这个里面依旧还是做那么几件事，挂卷，挂网卡，调driver的接口启动一下虚拟机。至此，我们可爱的虚拟机就起来了。</p><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3. 结语"></a>3. 结语</h2><p>整体的看一下，其实在Pike版本，Nova还是有很多的变动。真的是一个版本过去了，创建虚拟机的流程已经面目全非了。</p><p>从P版本的虚拟机创建流程来看，主要的优化集中在基于Cell V2架构下的多cell支持、调度的优化、Quota的优化，而后续的发展，目前也是集中在Placement各种资源的支持以及在Cell v2场景的诸如基本流程、调度等的优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;Nova是OpenStack中处理计算业务（虚拟机、裸机、容器）的组件，整体的虚拟机创建流程自然是学习和熟悉Nova组件的第一步。本篇文章主要基于OpenStack Pike版本，基于最新的Cell v2架构部署为例，来介绍虚拟机的创建流程，并分析了Pike等最近几个版本中，虚拟机创建流程的关键变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[译] Simpler Road to Cinder Active-Active</title>
    <link href="http://yikun.github.io/2017/08/16/%E8%AF%91-Simpler-Road-to-Cinder-Active-Active/"/>
    <id>http://yikun.github.io/2017/08/16/译-Simpler-Road-to-Cinder-Active-Active/</id>
    <published>2017-08-16T12:50:32.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译注：本篇文章为作者介绍Cinder AA方案的文章，作者是gorka，是实现cinder AA BP的core，文章介绍了这哥们实现AA时的记录，算是对方案的一种解释以及设计思路的总结，核心思想为以下几点：</p><ol><li>每个volume node都增加一个<code>cluster</code>的配置项，作为集群，标记这个节点属于某个集群；</li><li>通过cluster@backend作为消息队列的topic，并且启动cluster@backend的服务；</li><li>scheduler进行调度时，投递到某个合适的集群，集群中的某个后端进行消费；</li><li>消费时，将操作记录在worker中，用来标记这个资源由某个worker来操作，这样当发生异常时，可以确保仅有某个worker进行cleanup的操作。</li></ol></blockquote><p>原文链接：<a href="https://gorka.eguileor.com/simpler-road-to-cinder-active-active/" target="_blank" rel="noopener">Simpler Road to Cinder Active-Active</a></p><a id="more"></a><p>上一周，我发了一篇文，来介绍Cinder AA配置方案，可是，让我很受伤的是，觉得那个方案有点太复杂了，所以呢，这一波又搞了个简单的方案。</p><h2 id="变更初心"><a href="#变更初心" class="headerlink" title="变更初心"></a>变更初心</h2><p>我确实很喜欢我上周发布的允许Cinder使用AA HA配置的方案，不过想起来，确实有些复杂了，没必要为了一点点的益处，就把那么复杂的机制加到组件里。（比如恢复排队任务）</p><p>这个方案从决绝到接受，没有花费我太多时间，毕竟上个方案确实留下了一些复杂，所以必须要一个更简单的方案，所以呢，我相信这一波方案是一个合理的选择。</p><p>我准备用上篇博客同样的格式，来对同样的问题给出解决方案，这样对于读上篇博客的人来说看起来比较熟悉。尽管在这我没有太多的时间来搞patch和流程图，我会在Cinder Midcycle Sprint的时候把他们准备好。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>我们应该如何在一个cluster中的不同node去做任务调度呢？</p><p>在任务调度的时候，我们仍然不想让API或者Scheduler节点太多的考虑有多少volume节点或者说操心具体集群中哪一个节点时可用的。我们将还是用原来的方法——主题队列，唯一的不同在于，我们改变了这些队列的主题，从原来的host@backend变为了cluster@backend。</p><p>cluster将成为一个新的配置——同一集群中的所有节点都使用相同的配置。如果没有配置的话，默认会使用host作为值。同时，在cinder部署时，任何一个节点的host应该是唯一的。</p><p>将host的值作为cluster的默认值有很多好处，非AA配置可以将服务视为之前的host@backend，如果一个节点或者说原来的主备配置的节点，想要变为AA模式，只需要把后面加进来的节点，把cluster都改成和第一个host的值就行了，这样就可以保证服务可以不挂掉。这样做虽然不是那么干脆利落，但这个可以帮助管理员在可以down机的时候，再去做整改。</p><h2 id="清理资源"><a href="#清理资源" class="headerlink" title="清理资源"></a>清理资源</h2><p>为了进行清理，我们需要在所有的资源表（如卷、备份、快照等）增加一个新的字段。我们称其为“worker”，它可以有3个不同的值：</p><ol><li>空值：资源无节点操作</li><li>cluster@backend：资源正在排队等待worker操作</li><li>host@backned：资源已经被一个worker选择</li></ol><p>或许，我们不需要cluester@backend这个值也可以工作的很好，不过我还是觉得应该记录现在处于什么状态了<br>我们也用到了“previous_status”这个字段，就像我们对in-used卷做备份操作那样。<br>对于已经存在的资源，正常的工作流程像下面一样：</p><ol><li>API接受请求，在RPC调用投递到指定的volume topic队列之前，需要修改status和pre_vious_status以及worker字段来匹配资源的host字段（cluster@backend）</li><li>当volume节点接受这个job，将会在DB把worker字段更改为host@backend</li><li>当完成这个操作后，将置空worker字段，然后将status恢复为previous_status字段。</li></ol><p>看起来不错，但我们如何去做清理呢？其实和目前的实现差不多，仅有一点小小的改动。<br>当节点启动时，搜寻所有worker为自己所属的host@backend的资源，然后对这个worker filed做compare-and-swap置空，确保没有其他节点来操作这个资源，也保证仅做了我们需要的改动。<br>然后对于一些资源的操作（比如deleting）我们设置worker字段为cluser@backend，然后RPC调用。这样，我们在所有集群的节点做了分发。<br>还是看起来不错吧？但是我们如何处理那些没有恢复如初，或者那些无法failover的备节点呢？这个case会通过Scheduler来处理，我们会在后面介绍。<br>另外的选择是，我们不用在每个资源表里都增加一个新的字段，我们可以为资源创建一个特殊的表来记录work。如果我们使用了这个方案，我们需在wokrer里面存储resource id，来记录这个ID那个资源的。这个方案修改量比较小，我们想知道谁操作某个特定的资源有点困难，但我们只需要访问一个表，就可以很简单的获取所有某个节点操作的所有资源。</p><h2 id="API-Nodes"><a href="#API-Nodes" class="headerlink" title="API Nodes"></a>API Nodes</h2><p>接下来，我们需要移除race，就像我上篇文章介绍的那样。但是我们也需要额外的变化依赖于我们如何处理资源的互斥。</p><h2 id="Volume-Nodes"><a href="#Volume-Nodes" class="headerlink" title="Volume Nodes"></a>Volume Nodes</h2><p>我并不想再赘述我们如何如何的需要改变目前的本地锁机制，这已经在上篇文章介绍过了。<br>在社区有一个分歧，一部分人认为应该使用DLM解决资源锁，另一部分人认为应该避免让云管理员去部署和配置更多的软件（比如，redis、zookeeper等）<br>我个人理解是使用DLM去实现AA是一个中间方案，直到我们完全的实现AA。因为我们使用Tooz可以很轻松的实现，这也是为什么我更偏向这个选择。我们可以先快速实现它，然后后面的版本再把锁从Manager和driver中移除。</p><p>附注一点，一些driver可以移除锁只要我们移除了API竞争，然后添加一些缺失的锁。<br>DLM这种方案，仅会影响AA的部署，而对初始的没有其他影响。</p><p>但是，通常思考另一种选择是好事情，这仅仅是我喜欢的而不是说是最好的，那么另外一种选择就是使用资源的状态。</p><h2 id="Service-state-reporting"><a href="#Service-state-reporting" class="headerlink" title="Service state reporting"></a>Service state reporting</h2><p>为了探测节点有没有挂掉，也为了对那些还没有就位的节点（或者还得一段时间才能恢复的节点）进行清理，每一个集群节点都会进行report，分别占用DB不同的行。</p><p>我们可以用现在的host字段，上报时使用“cluster@backend@hostend”或者使用一个新的字段backend或者cluster里面包含cluster@backend段，然后host还是放在host字段不变。</p><p>其实，这一点倒不那么重要，这只是实现细节而已。在任何一个scheduler节点，都会有个周期任务检查数据库的内容，然后创建创建一个key为cluster@backend的字典，并存在value里，如果他是不同节点的信息以及是否我们对这个节点完成了清理。节点起来后，将会把cleanup_done设置为False。</p><p>如果cluster中的任何一个节点up，那么这个服务就up。</p><p>对于那些已经down的节点，我们将进行cleanup操作，就像我们在voluem node启动时做的那样，然后把cleanup_done字段设置为True。所以我们在下一次这个task启动时不会检查这个任务。</p><p>如果多个scheduler尝试同时对一个node进行清理，或者scheduler和之前的备节点现在active了，并且同时对资源进行修复。由于我们在数据库做的是使用compare and<br>swap的原子变更，跳过失败即可，确保只有一个完成资源的清理。</p><h2 id="Capabilities-reporting"><a href="#Capabilities-reporting" class="headerlink" title="Capabilities reporting"></a>Capabilities reporting</h2><p>我们上报容量使用cluser@backend作为host即可，我们不需要作任何变动。</p><h2 id="Prevent-data-corruption"><a href="#Prevent-data-corruption" class="headerlink" title="Prevent data corruption"></a>Prevent data corruption</h2><p>与上周的方案不同，组织数据出错更简单，这也是这个方案简单的一个主要原因。</p><p>我们不需要关心我们是否和后端失去连接，也不用关心我们与消息队列失去连接</p><p>如果我们与数据库失去连接我们需要停掉一切正在进行的操作，最简单的就是在心跳周期方案做这个事情。我们可以停掉backend的一切操作。</p><p>当我们使用DLM，我们应该检查连接，连接丢失要停掉所有操作，并且停止发送心跳，因为我们做不了任何事。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;译注：本篇文章为作者介绍Cinder AA方案的文章，作者是gorka，是实现cinder AA BP的core，文章介绍了这哥们实现AA时的记录，算是对方案的一种解释以及设计思路的总结，核心思想为以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个volume node都增加一个&lt;code&gt;cluster&lt;/code&gt;的配置项，作为集群，标记这个节点属于某个集群；&lt;/li&gt;
&lt;li&gt;通过cluster@backend作为消息队列的topic，并且启动cluster@backend的服务；&lt;/li&gt;
&lt;li&gt;scheduler进行调度时，投递到某个合适的集群，集群中的某个后端进行消费；&lt;/li&gt;
&lt;li&gt;消费时，将操作记录在worker中，用来标记这个资源由某个worker来操作，这样当发生异常时，可以确保仅有某个worker进行cleanup的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://gorka.eguileor.com/simpler-road-to-cinder-active-active/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Simpler Road to Cinder Active-Active&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>一次有关OpenStack请求的性能问题分析</title>
    <link href="http://yikun.github.io/2016/07/22/%E4%B8%80%E6%AC%A1%E6%9C%89%E5%85%B3OpenStack%E8%AF%B7%E6%B1%82%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yikun.github.io/2016/07/22/一次有关OpenStack请求的性能问题分析/</id>
    <published>2016-07-22T15:09:25.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-背景介绍"><a href="#0-背景介绍" class="headerlink" title="0. 背景介绍"></a>0. 背景介绍</h3><p>目前OpenStack对外提供的北向接口是以REST接口提供的，也就是说通过HTTP（HTTPS）接口进行请求，进行虚拟机或者卷等相关的操作。OpenStack提供I层基本的能力，比如创建、查询、删除虚拟机或者卷等操作，以OpenStack作为平台，对上提供用户接口，对下操作下层Driver完成对设备的操作，其大致的架构基本如下所示：</p><a id="more"></a><p><img src="https://cloud.githubusercontent.com/assets/1736354/17061504/6b7cb7e4-5061-11e6-9adb-0337558ccc90.png" alt="openstackrest"></p><p>整个OpenStack提供的接口也都是无状态的，对外接口也非常简单，例如获取卷的详情可以通过volumes的接口，最终可以得到卷的详情信息：<br><img src="https://cloud.githubusercontent.com/assets/1736354/17061512/70953ac6-5061-11e6-82ed-47017c82ace2.png" alt="cinder show"></p><p>一般调用这些接口的上层主要是一些编排性或者提高用户体验的应用，达到“点一个按钮”完成对资源创建或者查询的应用。</p><h3 id="1-问题出现"><a href="#1-问题出现" class="headerlink" title="1. 问题出现"></a>1. 问题出现</h3><p>问题的现象是，上层对资源进行操作、查询的时候非常慢，而实际在上层应用的服务器节点通过curl命令去调OpenStack接口的时候，发现整体时延均在秒级以上，甚至一个非常简单的卷查询指令也耗费了1秒以上的时间，而通过ping指令去测OpenStack响应时，保持在200ms左右，那么中间的时间耗在了哪？</p><h3 id="2-定位结论"><a href="#2-定位结论" class="headerlink" title="2. 定位结论"></a>2. 定位结论</h3><p>好吧，我承认这篇文章写了一年了。。。不装逼了，直接说结论吧。当时遇到一个非常奇葩的问题，就是任何请求都耗时非常久，最后发现原来是https搞得鬼。</p><p>对于正常的http请求来说，请求本身耗时大致是一个RTT（TCP的三次握手），而对于https，中间增加了SSL握手的时间，大概算下来是3倍+的时延。</p><p>重点呢就是想记录一下这个指令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -w "TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\n" -so /dev/null https://www.baidu.com</span><br></pre></td></tr></table></figure></p><p>可以得到类似的结果，也告诉了用户大致请求中间的耗时花费在哪了，结果就像这样：</p><blockquote><p>TCP handshake: 0.049, SSL handshake: 0.163</p></blockquote><p>好了，就酱紫，底下参考链接是当时看的一些资料。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.semicomplete.com/blog/geekery/ssl-latency.html" target="_blank" rel="noopener">SSL handshake latency and HTTPS optimizations.</a><br><a href="http://blog.jobbole.com/86664/" target="_blank" rel="noopener">大型网站的 HTTPS 实践（2）：HTTPS 对性能的影响</a><br><a href="http://www.zhihu.com/question/21518760" target="_blank" rel="noopener">HTTPS 要比 HTTP 多用多少服务器资源？</a><br><a href="http://blog.jobbole.com/48369/" target="_blank" rel="noopener">HTTPS连接的前几毫秒发生了什么</a><br><a href="http://www.jianshu.com/p/544c0a2d47f4" target="_blank" rel="noopener"></a><br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">图解SSL/TLS协议</a><br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a><br><a href="https://blog.josephscott.org/2011/10/14/timing-details-with-curl/" target="_blank" rel="noopener"></a><br><a href="http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html" target="_blank" rel="noopener">SSL延迟有多大？</a><br><a href="http://www.jianshu.com/p/a766bbf31417" target="_blank" rel="noopener">HTTPS研究（2）—分解HTTPS连接建立过程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-背景介绍&quot;&gt;&lt;a href=&quot;#0-背景介绍&quot; class=&quot;headerlink&quot; title=&quot;0. 背景介绍&quot;&gt;&lt;/a&gt;0. 背景介绍&lt;/h3&gt;&lt;p&gt;目前OpenStack对外提供的北向接口是以REST接口提供的，也就是说通过HTTP（HTTPS）接口进行请求，进行虚拟机或者卷等相关的操作。OpenStack提供I层基本的能力，比如创建、查询、删除虚拟机或者卷等操作，以OpenStack作为平台，对上提供用户接口，对下操作下层Driver完成对设备的操作，其大致的架构基本如下所示：&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法的理解与实践</title>
    <link href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yikun.github.io/2016/06/09/一致性哈希算法的理解与实践/</id>
    <published>2016-06-09T02:43:54.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h3><p>在维基百科中，是这么定义的</p><blockquote><p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p></blockquote><h3 id="1-引出"><a href="#1-引出" class="headerlink" title="1. 引出"></a>1. 引出</h3><p>我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？<br>那么我们引出一个问题：</p><blockquote><p>假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。</p></blockquote><p>看一看普通Hash算法的原理：<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341297/fe155f98-3a5e-11e6-834d-193e6f85afcd.png" alt="normal_hash"></p><a id="more"></a><p>算法的核心计算如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    k = md5(str(item)).digest()</span><br><span class="line">    h = unpack_from(<span class="string">"&gt;I"</span>, k)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 通过取余的方式进行映射</span></span><br><span class="line">    n = h % NODES</span><br><span class="line">    node_stat[n] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>具体的完整实现请参考<a href="https://github.com/Yikun/hashes/blob/master/normal_hash.py" target="_blank" rel="noopener">normal_hash.py</a>，输出是这样的：</p><blockquote><p>Ave: 100000<br>Max: 100695 (0.69%)<br>Min: 99073  (0.93%)</p></blockquote><p>从上述结果可以发现，普通的Hash算法均匀地将这些数据项打散到了这些节点上，并且分布最少和最多的存储节点数据项数目小于1%。之所以分布均匀，主要是依赖Hash算法（实现使用的MD5算法）能够比较随机的分布。</p><p>然而，我们看看存在一个问题，由于该算法使用节点数取余的方法，强依赖node的数目，因此，当是node数发生变化的时候，item所对应的node发生剧烈变化，而发生变化的成本就是我们需要在node数发生变化的时候，数据需要迁移，这对存储产品来说显然是不能忍的，我们观察一下增加node后，数据项移动的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    k = md5(str(item)).digest()</span><br><span class="line">    h = unpack_from(<span class="string">"&gt;I"</span>, k)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 原映射结果</span></span><br><span class="line">    n = h % NODES</span><br><span class="line">    <span class="comment"># 现映射结果</span></span><br><span class="line">    n_new = h % NEW_NODES</span><br><span class="line">    <span class="keyword">if</span> n_new != n:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>详细实现代码在<a href="https://github.com/Yikun/hashes/blob/master/normal_hash_add.py" target="_blank" rel="noopener">normal_hash_add.py</a>输出是这样的：</p><blockquote><p>Change: 9900989   (99.01%)</p></blockquote><p>翻译一下就是，<strong>如果有100个item，当增加一个node，之前99%的数据都需要重新移动</strong>。</p><p>这显然是不能忍的，普通哈希算法的问题我们已经发现了，如何对其进行改进呢？没错，我们的一致性哈希算法闪亮登场。</p><h3 id="2-登场"><a href="#2-登场" class="headerlink" title="2. 登场"></a>2. 登场</h3><p>我们上节介绍了普通Hash算法的劣势，即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。</p><p>那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即<strong>当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量的降到最低</strong>。</p><p>一致性Hash算法的原理是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341311/0e8fea32-3a5f-11e6-84b5-ff101495cf49.png" alt="consist_hash"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(NODES):</span><br><span class="line">    h = _hash(n)</span><br><span class="line">    ring.append(h)</span><br><span class="line">    ring.sort()</span><br><span class="line">    hash2node[h] = n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item)</span><br><span class="line">    n = bisect_left(ring, h) % NODES</span><br><span class="line">    node_stat[hash2node[ring[n]]] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们依然对其进行了实现<a href="https://github.com/Yikun/hashes/blob/master/consist_hash_add.py" target="_blank" rel="noopener">consist_hash_add.py</a>，并且观察了数据迁移的结果：</p><blockquote><p>Change: 58897   (0.59%)</p></blockquote><p>虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据项分布的均匀性，进行了一致性Hash算法的实现<a href="https://github.com/Yikun/hashes/blob/master/consist_hash.py" target="_blank" rel="noopener">consist_hash.py</a>：</p><blockquote><p>Ave: 100000<br>Max: 596413 (496.41%)<br>Min: 103    (99.90%)</p></blockquote><p>这结果简直是简直了，确实非常结果差，分配的很不均匀。我们思考一下，一致性哈希算法分布不均匀的原因是什么？从最初的1000w个数据项经过一般的哈希算法的模拟来看，这些数据项“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据项本身的哈希值并未发生变化，变化的是判断数据项哈希应该落到哪个节点的算法变了。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341426/8c9e6caa-3a5f-11e6-87ad-fdb462b76aef.png" alt="consist_hash_1"><br>因此，主要是因为这100个节点Hash后，<strong>在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一</strong>造成的。</p><h3 id="3-改进-虚节点"><a href="#3-改进-虚节点" class="headerlink" title="3. 改进-虚节点"></a>3. 改进-虚节点</h3><p>当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341445/a0e32fde-3a5f-11e6-969d-085f64220e63.png" alt="consist_hash_virtual"></p><p>详细实现请见<a href="https://github.com/Yikun/hashes/blob/master/virtual_consist_hash.py" target="_blank" rel="noopener">virtual_consist_hash.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(NODES):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(VNODES):</span><br><span class="line">        h = _hash(str(n) + str(v))</span><br><span class="line">        <span class="comment"># 构造ring</span></span><br><span class="line">        ring.append(h)</span><br><span class="line">        <span class="comment"># 记录hash所对应节点</span></span><br><span class="line">        hash2node[h] = n</span><br><span class="line">ring.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(str(item))</span><br><span class="line">    <span class="comment"># 搜索ring上最近的hash</span></span><br><span class="line">    n = bisect_left(ring, h) % (NODES*VNODES)</span><br><span class="line">    node_stat[hash2node[ring[n]]] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出结果是这样的：</p><blockquote><p>Ave: 100000<br>Max: 116902 (16.90%)<br>Min: 9492   (90.51%)</p></blockquote><p>因此，通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。<br>同时，观察增加节点后数据变动情况，详细的代码请见<a href="https://github.com/Yikun/hashes/blob/master/virtual_consist_hash_add.py" target="_blank" rel="noopener">virtual_consist_hash_add.py</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(str(item))</span><br><span class="line">    n = bisect_left(ring, h) % (NODES*VNODES)</span><br><span class="line">    n2 = bisect_left(ring2, h) % (NODES2*VNODES)</span><br><span class="line">    <span class="keyword">if</span> hash2node[ring[n]] != hash2node2[ring2[n2]]:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>100000<br>101000<br>Change: 104871  (1.05%)</p></blockquote><h3 id="3-另一种改进"><a href="#3-另一种改进" class="headerlink" title="3. 另一种改进"></a>3. 另一种改进</h3><p>然而，虚节点这种靠数量取胜的策略增加了存储这些虚节点信息所需要的空间。在OpenStack的Swift组件中，使用了一种比较特殊的方法来解决分布不均的问题，改进了这些数据分布的算法，将环上的空间均匀的映射到一个线性空间，这样，就保证分布的均匀性。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341455/b01139ec-3a5f-11e6-965a-070f5c4c0afa.png" alt="consist_hash_ring"><br>代码实现见<a href="https://github.com/Yikun/hashes/blob/master/part_consist_hash.py" target="_blank" rel="noopener">part_consist_hash.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> range(<span class="number">2</span> ** LOG_NODE):</span><br><span class="line">    ring.append(part)</span><br><span class="line">    part2node[part] = part % NODES</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item) &gt;&gt; PARTITION</span><br><span class="line">    part = bisect_left(ring, h)</span><br><span class="line">    n = part % NODES</span><br><span class="line">    node_stat[n] += <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>Ave: 100000<br>Max: 157298 (57.30%)<br>Min: 77405  (22.59%)</p></blockquote><p>可以看到，数据分布是比较理想的。如果节点数刚好和分区数相等，理论上是可以均匀分布的。而观察下增加节点后的数据移动比例，代码实现见<a href="https://github.com/Yikun/hashes/blob/master/part_consist_hash_add.py" target="_blank" rel="noopener">part_consist_hash_add.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> range(<span class="number">2</span> ** LOG_NODE):</span><br><span class="line">    ring.append(part)</span><br><span class="line">    part2node[part] = part % NODES</span><br><span class="line">    part2node2[part] = part % NODES2</span><br><span class="line"></span><br><span class="line">change = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item) &gt;&gt; PARTITION</span><br><span class="line">    p = bisect_left(ring, h)</span><br><span class="line">    p2 = bisect_left(ring, h)</span><br><span class="line">    n = part2node[p] % NODES</span><br><span class="line">    n2 = part2node2[p] % NODES2</span><br><span class="line">    <span class="keyword">if</span> n2 != n:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>结果如下所示：</p><blockquote><p>Change: 2190208 (21.90%)</p></blockquote><p>可以看到，移动也是比较理想的。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://www.cnblogs.com/yuxc/archive/2012/06/22/2558312.html" target="_blank" rel="noopener">深入云存储系统Swift核心组件：Ring实现原理剖析</a><br><a href="https://github.com/gholt/ring/blob/master/BASIC_HASH_RING.md" target="_blank" rel="noopener">Basic Hash Ring</a><br><a href="https://github.com/gholt/ring/blob/master/PARTITION_RING_VS_HASH_RING.md" target="_blank" rel="noopener">Partition Ring vs. Hash Ring</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0. 概述&quot;&gt;&lt;/a&gt;0. 概述&lt;/h3&gt;&lt;p&gt;在维基百科中，是这么定义的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-引出&quot;&gt;&lt;a href=&quot;#1-引出&quot; class=&quot;headerlink&quot; title=&quot;1. 引出&quot;&gt;&lt;/a&gt;1. 引出&lt;/h3&gt;&lt;p&gt;我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？&lt;br&gt;那么我们引出一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一看普通Hash算法的原理：&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/16341297/fe155f98-3a5e-11e6-834d-193e6f85afcd.png&quot; alt=&quot;normal_hash&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>理解Python中的“with”</title>
    <link href="http://yikun.github.io/2016/04/15/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E2%80%9Cwith%E2%80%9D/"/>
    <id>http://yikun.github.io/2016/04/15/理解Python中的“with”/</id>
    <published>2016-04-15T15:44:15.000Z</published>
    <updated>2021-08-02T03:29:56.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-缘起"><a href="#1-缘起" class="headerlink" title="1. 缘起"></a>1. 缘起</h3><p>Python中，打开文件的操作是非常常见的，也是非常方便的，那么如何优雅的打开一个文件？大部分的同学会这样实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open( <span class="string">"a.txt"</span> ) <span class="keyword">as</span> f :</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><p>大家都知道，这样写可以自动处理资源的释放、处理异常等，化简了我们打开文件的操作，那么，<code>with</code>到底做了什么呢？</p><a id="more"></a><p>从《Python学习手册》中是这么描述的：</p><blockquote><p>简而言之，with/as语句的设计是作为常见try/finally用法模式的替代方案。就像try/finally语句，with/as语句也是用于定义必须执行的终止或“清理”行为,无论步骤中是否发生异常。不过，和try/finally不同的是，with语句支持更丰富的基于对象的协议，可以为代码块定义支持进入和离开动作。</p></blockquote><p>也就是说对于代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> varible]:</span><br><span class="line">    <span class="keyword">with</span>-block</span><br></pre></td></tr></table></figure><p>with语句的实际工作方式：</p><blockquote><p>1.计算表达式，所得到的对象是<strong>环境管理器</strong>，他必须有<strong>enter</strong>，<strong>exit</strong>两个方法。<br>2.环境管理器的<strong>enter</strong>方法会被调用。如果as存在，<strong>enter</strong>的返回值赋值给as后面的变量，否则，被丢弃。<br>3.代码块中嵌套的代码（with-block）会执行。<br>4.如果with代码块会引发异常，<strong>exit</strong>(type,value,traceback)方法就会被调用。这些也是由sys.exec_info返回相同的值。如果此方法返回为假，则异常会重新引发。否则，异常会中止。正常情况下异常是应该被重新引发，这样的话传递到with语句外。<br>5.如果with代码块没有引发异常，<strong>exit</strong>方法依然会调用，其type、value以及traceback参数会以None传递。</p></blockquote><p>with/as语句的设计，是为了让必须在程序代码块周围发生的启动和终止活动一定会发生。和try/finally语句（无论异常是否发生其离开动作都会执行）类似，但是with/as有更丰富的对象协议，可以定义进入和离开的动作。</p><h3 id="2-设计的初衷"><a href="#2-设计的初衷" class="headerlink" title="2. 设计的初衷"></a>2. 设计的初衷</h3><p>with/as语句的设计的初衷，在<a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="noopener">PEP343</a>中是这么描述的：</p><blockquote><p>This PEP adds a new statement “with” to the Python language to make it possible to factor out standard uses of try/finally statements.<br>In this PEP, context managers provide <strong>enter</strong>() and <strong>exit</strong>() methods that are invoked on entry to and exit from the body of the with statement.</p></blockquote><p>对于下面的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">            BLOCK</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mgr = (EXPR)</span><br><span class="line">exit = type(mgr).__exit__  <span class="comment"># Not calling it yet</span></span><br><span class="line">value = type(mgr).__enter__(mgr)</span><br><span class="line">exc = <span class="literal">True</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将__enter__函数调用的返回值返回给VAR</span></span><br><span class="line">        VAR = value  <span class="comment"># Only if "as VAR" is present</span></span><br><span class="line">        <span class="comment"># 执行BLOCK</span></span><br><span class="line">        BLOCK</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 异常处理，The exceptional case is handled here</span></span><br><span class="line">        exc = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(mgr, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="comment"># The exception is swallowed if exit() returns true</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理，The normal and non-local-goto cases are handled here</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(mgr, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>我们可以看到上述代码完整的处理了初始化及异常/正常场景的清理操作，这便是<code>with</code>的设计思想，化简了冗余的代码，把那些重复的工作以及异常处理操作交给写“EXPR”源码（比如open操作）的同学。</p><h3 id="3-更深入的学习"><a href="#3-更深入的学习" class="headerlink" title="3. 更深入的学习"></a>3. 更深入的学习</h3><p>我们继续深入的看下<a href="https://github.com/Yikun/Python3/blob/master/Lib/_pyio.py#L447" target="_blank" rel="noopener">Python3</a>中<strong>enter</strong>和<strong>exit</strong>的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBase</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### Context manager ###</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span>  <span class="comment"># That's a forward reference</span></span><br><span class="line">        <span class="string">"""Context management protocol.  Returns self (an instance of IOBase)."""</span></span><br><span class="line">        self._checkClosed()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">"""Context management protocol.  Calls close()"""</span></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure><p>和我们预期的一致，在<strong>enter</strong>中返回了这个IO对象，然后在<strong>exit</strong>中，进行了清理。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>《Python学习手册》 </li><li><a href="http://effbot.org/zone/python-with-statement.htm" target="_blank" rel="noopener">Understanding Python’s “with” statement</a></li><li><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="noopener">PEP 343 – The “with” Statement</a></li><li><a href="http://stackoverflow.com/questions/713794/catching-an-exception-while-using-a-python-with-statement" target="_blank" rel="noopener">Catching an exception while using a Python ‘with’ statement</a></li><li><a href="http://zhoutall.com/archives/325" target="_blank" rel="noopener">理解Python中的with…as…语法</a></li><li><a href="https://www.python.org/dev/peps/pep-3116/" target="_blank" rel="noopener">PEP 3116 – New I/O</a></li><li><a href="https://github.com/Yikun/Python3/blob/master/Lib/_pyio.py#L447" target="_blank" rel="noopener">Python 3.5.0 Code</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-缘起&quot;&gt;&lt;a href=&quot;#1-缘起&quot; class=&quot;headerlink&quot; title=&quot;1. 缘起&quot;&gt;&lt;/a&gt;1. 缘起&lt;/h3&gt;&lt;p&gt;Python中，打开文件的操作是非常常见的，也是非常方便的，那么如何优雅的打开一个文件？大部分的同学会这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open( &lt;span class=&quot;string&quot;&gt;&quot;a.txt&quot;&lt;/span&gt; ) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大家都知道，这样写可以自动处理资源的释放、处理异常等，化简了我们打开文件的操作，那么，&lt;code&gt;with&lt;/code&gt;到底做了什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>存储数据包的一生</title>
    <link href="http://yikun.github.io/2016/04/03/%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>http://yikun.github.io/2016/04/03/存储数据包的一生/</id>
    <published>2016-04-03T14:04:23.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>最近认认真真学习了一个叫<a href="https://www.brighttalk.com/webcast/663/169543" target="_blank" rel="noopener">《Life of a Storage Packet》</a>讲座，借助这个讲座将整个存储的过程理解了下，不放过任何一个有疑问的点。这篇文章算是对讲座的理解和自己收获的总结，同时也为那些对存储系统不够了解又想要了解的初学者，展现一个存储数据包的“生命”。这个演讲主要聚焦在“整体的存储”，强调存储系统中各个基本元素的关系，并且尽可能简单、清楚地用一种不同的方式可视化一些存储的概念。</p><p>先上一张大图，可以说这篇文章目的就是解释这个图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png" alt="12"></p><a id="more"></a><h3 id="1-整体视角"><a href="#1-整体视角" class="headerlink" title="1. 整体视角"></a>1. 整体视角</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232846/9c75a7a8-f9e9-11e5-8487-415e410372bf.png" alt="1"></p><p>存储系统从整体的分层一览，包括了主机/应用，存储介质，存储网络。对于存储来说就做了一件事：</p><blockquote><p>Here is a bit of data. Hold onto it. Give that same bit back to me when I ask for it.</p></blockquote><h3 id="2-Application视角"><a href="#2-Application视角" class="headerlink" title="2. Application视角"></a>2. Application视角</h3><p>每个系统都有会有很多应用程序运行在CPU上，对于这些Application来说，他们觉得自己有很多很多足够的可用内存。</p><h4 id="2-1-CPU和MMU"><a href="#2-1-CPU和MMU" class="headerlink" title="2.1 CPU和MMU"></a>2.1 CPU和MMU</h4><p>计算机系统中有一个“内存管理单元”（MMU，Memory Management Unit）的概念，MMU负责与DRAM内存直接通信，并且获得一些可用的“页”<br>多租户：内存被某个进程（比如一个应用）独享，这些内存不能被其他进程重写。<br>地址：将CPU的物理地址翻译成独有的DRAM地址或者是很多行DRAMs<br>有了MMU以后，对于每个进程来说，他们就像是一个人独占了所有的内存一样。</p><h4 id="2-2-访问内存"><a href="#2-2-访问内存" class="headerlink" title="2.2 访问内存"></a>2.2 访问内存</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232849/a28c5010-f9e9-11e5-9d03-ce555d9ca575.png" alt="2"></p><p>Application在他需要访问的时候，获取这些内存，在实际进行访问时，会发生如下事情：</p><ol><li>Application会问操作系统“Hey，我需要一些可用内存”</li><li>操作系统向MMU说，“能给我一些可以使用内存页不？”</li><li>MMU把一些可用的内存页给操作系统</li><li>操作系统把这些可用的内存页给Application。<h4 id="2-3-分配内存"><a href="#2-3-分配内存" class="headerlink" title="2.3 分配内存"></a>2.3 分配内存</h4></li></ol><p>在2.2中，获取的那些内存，实际是可以分布在内存中的任何地方的（非连续），MMU在把这些内存给应用的时候会进行初始化操作，当然，当应用不再访问这些内存页的时候，也会MMU也会负责回收这些内存。</p><h4 id="2-4-加速访问"><a href="#2-4-加速访问" class="headerlink" title="2.4 加速访问"></a>2.4 加速访问</h4><p>如果Application对内存的访问，每次都要都要从MMU获取的话，那太慢了，因此有个经验法则是：</p><blockquote><p>Always put storage/memory as close to the CPU as possible</p></blockquote><p>可以说在存储中，改善时间的限制是永恒不变的主题，然后访问DRAM的话，需要60-100ns的时间。我们需要更快的访问，甚至达到“0”时间访问。</p><h4 id="2-5-缓存的魔法"><a href="#2-5-缓存的魔法" class="headerlink" title="2.5 缓存的魔法"></a>2.5 缓存的魔法</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232850/a8f5c67a-f9e9-11e5-8d4b-bc6f819e546a.png" alt="3"></p><p>于是在CPU中增加了一些缓存，当然缓存也是分级别的，对于L1缓存大概花费1ns以内，L2缓存大概花费3-6ns，没错，这使得每次访问从60-100ns提升了几十倍！</p><h4 id="2-6-更多的空间"><a href="#2-6-更多的空间" class="headerlink" title="2.6 更多的空间"></a>2.6 更多的空间</h4><p>如果DRAM中也没有足够的空间时，这是你需要更多的持久化存储，比如说磁盘。当然直接去访问磁盘会非常的昂贵，当然这里指的是时间的花费非常昂贵。<br>在Jeff Dean大神的<a href="http://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="noopener">Software Engineering Advice from Building Large-Scale Distributed Systems</a>给出了数据：<br>L1缓存、L2缓存、主存、硬盘的访问分别是1ns、5ns、100ns、10,000,000ns级别;</p><p>举个比较形象的例子：你需要快递送个包裹，<br>快递一个1公里（L1）、5公里（L2）外的包裹，oops，可能马云爸爸保证当日达；<br>快递100公里（DRAM）的包裹，11点前下单，当日达，不能再快了！；<br>快递1000万公里（Disk）的快递，啊亲，你真的需要快递吗？这可是从地球到月球（38.4万公里）十几个来回的距离啊亲。</p><h4 id="2-7-下一站，使用存储设备"><a href="#2-7-下一站，使用存储设备" class="headerlink" title="2.7 下一站，使用存储设备"></a>2.7 下一站，使用存储设备</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232851/b26c959e-f9e9-11e5-9ab0-191778aa8f94.png" alt="4"></p><p>存储设备和RAM不太一样，不会和CPU直接进行“对话”，而是有一些其他的部分来帮助他们完成对话，我们在存储视角进一步去讲述。</p><h3 id="3-Storage视角"><a href="#3-Storage视角" class="headerlink" title="3 Storage视角"></a>3 Storage视角</h3><h4 id="3-1块设备的基本概念"><a href="#3-1块设备的基本概念" class="headerlink" title="3.1块设备的基本概念"></a>3.1块设备的基本概念</h4><p><strong>块存储的IO流</strong><br>CPU和内存通过PCI总线（目前通常是PCIe）与存储进行连接，应用会向存储请求一段数据。系统会将数据转换成地址和位置信息，并转换成某种协议的形式。</p><p><strong>数据总线</strong><br><img src="https://cloud.githubusercontent.com/assets/1736354/14232852/b983a7e6-f9e9-11e5-9343-9d9461fdfbcf.png" alt="5"></p><p>CPU的指令需要转换或者说是进行适配，以便能够与存储设备进行“交流”，比如SCSI、IDE/ATA</p><p><strong>SCSI系统</strong><br>SCSI是一个很普遍、且向后兼容的，通常主要包含的组件有：</p><ul><li>Initiator：一些服务用它发起请求，可以视为登陆或者适配的一部分</li><li>Target：物理存储设备，可以是单个磁盘或者磁阵</li><li>Service Delivery Subsystem：Initiator和Target之间的通信（通常是网线）</li></ul><p><strong>块设备</strong><br><img src="https://cloud.githubusercontent.com/assets/1736354/14232855/c052f9dc-f9e9-11e5-932f-3c7df1db0fd6.png" alt="6"></p><p>Block：块是存储介质上的物理或者逻辑单元，也是文件系统或者磁盘写入的最小单元，所有的存储（包括文件存储、对象存储）最终都是需要与block进行对话。</p><p>磁盘包括了盘面（Platter）、磁道（Track）、扇区（Sector）。盘面是一个圆，磁道是一个环，扇区是环上的一段，数据的位置影响性能。块由扇区组成，每一个块也有一个唯一的号码，文件系统的一切操作都是由对blocks操作构成。</p><h4 id="3-2-文件与块"><a href="#3-2-文件与块" class="headerlink" title="3.2 文件与块"></a>3.2 文件与块</h4><p>对于应用来说，他们看到的都是文件；而对于存储来说，看到是块。因此需要某种方式将他们联系起来。对于文件来说，应用看到的是一个连续的“空间”，然而实际上，文件是由很多块组成的，而这些块就是磁盘上的块，这些块分布在磁盘的不同区域。</p><h4 id="3-3-文件系统"><a href="#3-3-文件系统" class="headerlink" title="3.3 文件系统"></a>3.3 文件系统</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232859/c7502796-f9e9-11e5-96af-ba7d703b11b4.png" alt="7"></p><p>在操作系统中，其内核中会有一个文件系统，文件系统维护着在磁盘上的文件名，文件系统知道这些文件与磁盘上块位置的对应关系，同时还需要管理着磁盘空间、权限、所属、加密、文件缓存等等。</p><p>驱动控制：硬盘被驱动控制来操控，接收文件系统的通过某种协议（比如SCSI）下发的一些I/O命令</p><p>卷管理：文件系统和设备驱动中间存在着卷管理，卷管理负责抽象出一层“假的”磁盘供操作系统使用.</p><h4 id="3-4-文件系统与驱动"><a href="#3-4-文件系统与驱动" class="headerlink" title="3.4 文件系统与驱动"></a>3.4 文件系统与驱动</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232864/d20afa1c-f9e9-11e5-9ce6-2141048f2328.png" alt="8"><br>因此，对于文件系统来说，需要将应用程序所看到的“虚拟地址”翻译到真正的设备地址。例如访问一个文件时，文件系统会先会先在找到对应的逻辑块地址（Logical Block Adress, LBA），然后通过scsi系统进一步访问，对应到磁盘上的物理块地址。</p><h4 id="3-5-Inode"><a href="#3-5-Inode" class="headerlink" title="3.5 Inode"></a>3.5 Inode</h4><p>Inode是文件的原数据，用来记录文件的所述、权限、block信息等。一个Inode会对应一个文件或目录，通过inode就可以将文件与某些block对应起来。</p><p>也就是说通过inode信息，就可以完全的找到一个文件，包括这个文件所对应的data block。<br>对于目录而言，data block包含了目录的内容，即该目录下文件及其这些文件对应inode的列表。<br>对于文件而言，data block则包含了文件的实际内容。</p><h4 id="3-3-举个例子"><a href="#3-3-举个例子" class="headerlink" title="3.3 举个例子"></a>3.3 举个例子</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232879/210e7b70-f9ea-11e5-96aa-5f79cb5a2870.png" alt="9"></p><p>当执行<code>cat /home/foo.txt</code>命令时，会对foo.txt文件进行访问，经历了以下步骤：</p><ol><li>获取”/“内容；</li><li>查找”home”的node信息（inode 38）;</li><li>获取”home”目录内容；</li><li>查找”foo.txt”的inode信息（inode 40）；</li><li>根据inode获得block numbers；</li><li>文件系统将block number转换为真正的block number（data block 101）；</li><li>通过SCSI Controller读取block内容。</li></ol><p>至此，我们可以看到存储数据是这样走自己的路的：</p><ol><li>应用程序说我要获取/home/foo.txt的内容</li><li>操作系统依次检查L1、L2、RAM中是否存在，若均不存在则在文件系统中查找</li><li>文件系统先检查Unified Buffer Cache中是否存在该文件，如果不存在则去目录中查找“home”文件</li><li><strong>(访问磁盘)</strong>读取”home”目录的内容，并把inode信息放到buffer cache以便下次访问，最后根据目录内容查询到foo.txt的inode</li><li><strong>(访问磁盘)</strong>读取foo.txt的inode，获取到data block号</li><li><strong>(访问磁盘)</strong>文件系统读取data block，最终将数据返回给应用，并且把数据存储在L1、L2、RAM和UBC中，加速下次访问。</li></ol><p>我们可以看到，访问/home/foo.txt有3次磁盘访问：<br>第1次是读取home的inode，获取foo.txt的inode号<br>第2次是读取foo.txt的inode，获取data block号<br>第3次是读取data block，获取真正的内容</p><p>然而，我们对于机械硬盘来说，每次需要磁盘转到正确的地址才能访问到内容，尤其是这些data block若未按顺序存储，就需要“下一圈”的时候再访问，这样会很耗时，也就是说访问磁盘的时间和数据在磁盘上的位置非常相关。所以Flash技术(如flash-based SSD)就腾空出世了，可以做到任意数据的随机访问，就大大减少了数据访问时间。</p><h3 id="4-Network视角"><a href="#4-Network视角" class="headerlink" title="4. Network视角"></a>4. Network视角</h3><p>我们先回顾一下到网络这里都经历了什么：应用、操作系统、文件系统、缓冲缓存、卷管理、设备驱动、硬件控制、SCSI，一层一层递进访问。</p><h4 id="4-1-存储网络"><a href="#4-1-存储网络" class="headerlink" title="4.1 存储网络"></a>4.1 存储网络</h4><p>应用和存储视角已经可以工作了，而在应用和存储之间加一层网络，因此目前的玩法主要包括以下几种形式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232884/329592ca-f9ea-11e5-858a-d51abd697d94.png" alt="10"></p><p>这些知识在之前的<a href="http://yikun.github.io/2016/02/03/%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/">存储基础知识学习</a>中有大概的涉及过。</p><p>对于文件存储，常常使用NAS的架构，更灵活；而基于块的存储则常使用SAN的方式，保证性能。</p><h4 id="4-2-存储区域网络"><a href="#4-2-存储区域网络" class="headerlink" title="4.2 存储区域网络"></a>4.2 存储区域网络</h4><p>下面是存储区域网络(SAN)常见的几种网络协议格式以及组网方式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232886/381735dc-f9ea-11e5-8155-ed14516287ab.png" alt="11"></p><h3 id="5-最后的大招"><a href="#5-最后的大招" class="headerlink" title="5. 最后的大招"></a>5. 最后的大招</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png" alt="12"></p><p>至此，我们已经将整个数据存储相关的部分都进行了解析，这下对存储数据包的一生有所了解了吧。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li>登州知府的微博</li><li>Jeff Dean <a href="https://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener">Designs, Lessons and Advice from Building Large Distributed Systems</a></li><li>淘宝杨传辉：分布式系统工程实践</li><li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="noopener">理解inode</a></li><li><a href="https://cseweb.ucsd.edu/classes/su09/cse120/lectures/Lecture10.pdf" target="_blank" rel="noopener">CSE 120: Principles of Computer Operating Systems, Lecture 10-Disks and File Systems</a></li><li><a href="https://www.brighttalk.com/webcast/663/169543" target="_blank" rel="noopener">“Life of a Storage Packet”</a></li><li><a href="http://www.snia.org/sites/default/files/ESF/Life_of_a_Storage_Packet_%28Walk%29_Final.pdf" target="_blank" rel="noopener">Life of a Storage Packet.ppt</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近认认真真学习了一个叫&lt;a href=&quot;https://www.brighttalk.com/webcast/663/169543&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Life of a Storage Packet》&lt;/a&gt;讲座，借助这个讲座将整个存储的过程理解了下，不放过任何一个有疑问的点。这篇文章算是对讲座的理解和自己收获的总结，同时也为那些对存储系统不够了解又想要了解的初学者，展现一个存储数据包的“生命”。这个演讲主要聚焦在“整体的存储”，强调存储系统中各个基本元素的关系，并且尽可能简单、清楚地用一种不同的方式可视化一些存储的概念。&lt;/p&gt;
&lt;p&gt;先上一张大图，可以说这篇文章目的就是解释这个图：&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png&quot; alt=&quot;12&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码分析-Cinder中的调度机制</title>
    <link href="http://yikun.github.io/2016/03/04/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yikun.github.io/2016/03/04/OpenStack源码分析-Cinder中的调度机制/</id>
    <published>2016-03-04T16:45:44.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一下目前cinder中支持的调度的Filter和Weigher：<br><img src="https://cloud.githubusercontent.com/assets/1736354/15445332/29c1730c-1f2f-11e6-8706-4b38f5fc9e0d.png" alt="scheduler"><br>后面结合源码看下实现，留坑~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理了一下目前cinder中支持的调度的Filter和Weigher：&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/15445332/29c1730c-1f2f-11e6-8706-4b38
      
    
    </summary>
    
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码分析-Service启动流程</title>
    <link href="http://yikun.github.io/2016/03/04/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/03/04/OpenStack源码分析-Service启动流程/</id>
    <published>2016-03-04T16:38:21.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/1736354/13372372/d42f0c0a-dd7b-11e5-9656-1f2ff817e53a.png" alt="cinder service launcher"></p><a id="more"></a><p>如图所示，主要流程分为两大部分：</p><ol><li>创建Service<br>service.Service.create方法实现了这个过程。在创建服务的过程中，会根据host、binary、manager来创建服务，对于cinder-volume，则为cinder.service。</li><li>启动Service<br>launcher.launch_service会将第一步创建的服务启动起来，然后调用_start_child方法。<br>在_start_child方法中，会调用os.fork接口创建子进程，创建的进程数由launch_service的workers参数确定，目前默认为1个进程。<br>在子进程启动后，调用_child_process进行服务启动，调用common中的launch_service，此过程主要将service添加到线程池中，并启动。在启动时，会回调run_service进而调用Service.start方法。<br>Service正是cinder.service在此步中，会调用manager的init_host完成卷状态的检查。</li></ol><p>参考资料：<br><a href="http://blog.csdn.net/hackerain/article/details/7888686" target="_blank" rel="noopener">http://blog.csdn.net/hackerain/article/details/7888686</a><br><a href="http://www.openstack.cn/?p=437" target="_blank" rel="noopener">http://www.openstack.cn/?p=437</a><br><a href="http://lynnkong.iteye.com/blog/1829960" target="_blank" rel="noopener">http://lynnkong.iteye.com/blog/1829960</a><br><a href="http://docs.openstack.org/developer/nova/services.html" target="_blank" rel="noopener">http://docs.openstack.org/developer/nova/services.html</a><br><a href="http://www.cnblogs.com/sammyliu/p/4272611.html" target="_blank" rel="noopener">http://www.cnblogs.com/sammyliu/p/4272611.html</a><br><a href="http://www.cnblogs.com/littlebugfish/p/4022907.html" target="_blank" rel="noopener">http://www.cnblogs.com/littlebugfish/p/4022907.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/13372372/d42f0c0a-dd7b-11e5-9656-1f2ff817e53a.png&quot; alt=&quot;cinder service launcher&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码分析-挂载卷流程</title>
    <link href="http://yikun.github.io/2016/03/04/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8C%82%E8%BD%BD%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/03/04/OpenStack源码分析-挂载卷流程/</id>
    <published>2016-03-04T16:32:58.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-挂卷流程"><a href="#1-挂卷流程" class="headerlink" title="1. 挂卷流程"></a>1. 挂卷流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13493796/5a1fda3a-e17b-11e5-98be-2bca8a26e0bb.png" alt="volume attach"><br>    当Nova volume-attach server volume执行后，主要经过以下几步：<br>a.  Nova Client解析指令，通过RESTFUL接口访问nova-api；<br>b.  Nova API解析响应请求获取虚拟机的基本信息，然后向cinder-api发出请求保留，并向nova-compute发送RPC异步调用请求卷挂载；<br>c.  Nova-compute向cinder-api初始化信息，并根据初始化连接调用Libvirt的接口完成挂卷流程；<br>d.  进而调用cinder-volume获取连接，获取了连接后，通过RESTFUL请求cinder-api进行数据库更新操作。</p><a id="more"></a><h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13482134/b76e1680-e125-11e5-80d6-1e0f925fca48.png" alt="nova volume attach"></p><h4 id="1-Nova-Client"><a href="#1-Nova-Client" class="headerlink" title="1. Nova Client"></a>1. Nova Client</h4><p>(1) \nova\nova\api\openstack\compute\contrib\volumes.py<br>在Nova Client进程中，由VolumeAttachmentController接受挂载请求</p><h4 id="2-Nova-API"><a href="#2-Nova-API" class="headerlink" title="2. Nova API"></a>2. Nova API</h4><p>(1) \nova\nova\compute\api.py<br>VolumeAttachmentController的create函数用于响应卷挂载的请求。<br>(2) \nova\nova\volume\cinder.py<br>compute.API调用attach_volume函数，分别获取卷信息、检查状态并做保留盘操作<br>(3) \nova\nova\compute\rpcapi.py<br>通过attach_colume发送rpc调用Compute中的_attach_volume函数</p><h4 id="3-Nova-Compute"><a href="#3-Nova-Compute" class="headerlink" title="3. Nova Compute"></a>3. Nova Compute</h4><p>(1) \nova\nova\compute\manager.py<br>ComputeManager进行核心调用，首先获取initiator，然后初始化连接。<br>(2) \nova\nova\virt\block_device.py<br>DriverVolumeBlockDevice初始化连接后调用connect_volume函数进行卷的挂载<br>(3) \nova\nova\virt\libvirt\volume.py<br>LibvirtISCSIVolumeDriver的connect_volume是调用最核心流程，分为多路径和单路径两种情况，在单路径的调用中会执行login、检查session、设置自启动等操作，如果一次未连接成功则还会每tries <em>\</em> 2秒重复调用，直到达到调用的限制。其中牵扯到的指令有：<br>a. 尝试连接<br>iscsiadm -m node -T target_iqn -p target_protal<br>b. 连接失败重新建立连接<br>iscsiadm -m node -T target_iqn -p target_protal -op new<br>iscsiadm -m node -T target_iqn -p target_protal –op update -n node.session.auth.authmethod -v auth_method<br>iscsiadm -m node -T target_iqn -p target_protal –op update -n node.session.auth.username -v auth_username<br>iscsiadm -m node -T target_iqn -p target_protal –op update -n node.session.auth.password -v auth_password<br>c. 检查session，登陆<br>iscsiadm -m session检查是否登录成功<br>iscsiadm –m node –T targetname –p ip –login 登陆建立session<br>d. 设置为随机器启动而启动<br>iscsiadm -m node -T target_iqn -p target_protal –op update -n node.startup -v automatic<br>iscsiadm -m node -T target_iqn -p target_protal –rescan</p><h4 id="4-Cinder-API"><a href="#4-Cinder-API" class="headerlink" title="4. Cinder API"></a>4. Cinder API</h4><p>(1) \cinder\cinder\volume\api.py<br>volume.API会继续调用VolumeAPI进行挂卷的数据库更新<br>(2) \cinder\cinder\volume\rpcapi.py<br>VolumeAPI通过rpc调用VolumeManager</p><h4 id="5-Cinder-Volume"><a href="#5-Cinder-Volume" class="headerlink" title="5. Cinder Volume"></a>5. Cinder Volume</h4><p>\cinder\cinder\volume\manager.py<br>VolumeManager会完成更新数据库的操作。</p><p><a href="http://aspirer.wang/?p=164" target="_blank" rel="noopener">http://aspirer.wang/?p=164</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-挂卷流程&quot;&gt;&lt;a href=&quot;#1-挂卷流程&quot; class=&quot;headerlink&quot; title=&quot;1. 挂卷流程&quot;&gt;&lt;/a&gt;1. 挂卷流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/13493796/5a1fda3a-e17b-11e5-98be-2bca8a26e0bb.png&quot; alt=&quot;volume attach&quot;&gt;&lt;br&gt;    当Nova volume-attach server volume执行后，主要经过以下几步：&lt;br&gt;a.  Nova Client解析指令，通过RESTFUL接口访问nova-api；&lt;br&gt;b.  Nova API解析响应请求获取虚拟机的基本信息，然后向cinder-api发出请求保留，并向nova-compute发送RPC异步调用请求卷挂载；&lt;br&gt;c.  Nova-compute向cinder-api初始化信息，并根据初始化连接调用Libvirt的接口完成挂卷流程；&lt;br&gt;d.  进而调用cinder-volume获取连接，获取了连接后，通过RESTFUL请求cinder-api进行数据库更新操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>优雅地调试OpenStack</title>
    <link href="http://yikun.github.io/2016/02/22/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%B0%83%E8%AF%95OpenStack/"/>
    <id>http://yikun.github.io/2016/02/22/优雅地调试OpenStack/</id>
    <published>2016-02-22T16:00:52.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>恩，题目首先要起的高逼格一些。2333。</p><p>在前面学习代码的过程中，主要通过源码来学习，开始学起来确实有点费劲，因为欠缺对OpenStack的整体的意识，于是<a href="http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/">搭建OpenStack开发环境</a>对OpenStack的运行环境和使用有了初步认知。也看到了启动OpenStack后的一些相关进程，那么这些进程是如何与源码对应起来的呢？如何去调试OpenStack呢？本篇文章就讲下我的探索。</p><a id="more"></a><h3 id="1-初识Python调试"><a href="#1-初识Python调试" class="headerlink" title="1. 初识Python调试"></a>1. 初识Python调试</h3><p>在<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/" target="_blank" rel="noopener">Python 代码调试技巧</a>一文中提到了pdb、PyCharm、PyDev、日志等几种常见的调试方法。具体可以看看这篇文章，写的很详细，不赘述。</p><p>因为PyCharm出色的用户体验（那写代码就是要开心嘛），所以决定使用PyCharm进行调试，但是问题来了，在远端（如虚拟机或者服务器）服务已经启动起来了，我们如何进行调试呢？答案就是Remote Debug。</p><h3 id="2-启动OpenStack服务"><a href="#2-启动OpenStack服务" class="headerlink" title="2. 启动OpenStack服务"></a>2. 启动OpenStack服务</h3><p>在<a href="http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/">搭建OpenStack开发环境</a>一文中，我们介绍了使用devstack启动开发环境，我们通过DevStack启动各个服务后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ... ...</span><br><span class="line">This is your host IP address: 192.168.56.101</span><br><span class="line">This is your host IPv6 address: ::1</span><br><span class="line">Horizon is now available at http://192.168.56.101/dashboard</span><br><span class="line">Keystone is serving at http://192.168.56.101:5000/</span><br><span class="line">The default users are: admin and demo</span><br><span class="line">The password: 1</span><br></pre></td></tr></table></figure><p>使用screen来查看：</p><blockquote><p><strong>Note(2018.01.18)</strong>: 目前社区已经废弃了screen这种方式来启动进程了（参考<a href="https://review.openstack.org/#/c/499186/" target="_blank" rel="noopener">Remove screen support from devstack completely</a>），原因是OpenStack需要管理的进程太多了，screen已没有“能力”去管理。</p><p>社区已经切换到systemd来进行进程管理，可以参考官方提供的<a href="https://docs.openstack.org/devstack/latest/systemd.html" target="_blank" rel="noopener">Using Systemd in DevStack</a>一文来入门。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -x stack</span><br></pre></td></tr></table></figure><p>不得不说screen真是神器，虚拟了多个Terminal的Tab，使用”Ctrl+A+P”和”Ctrl+A+N”可以切换tab，使用”Ctrl+A+D”可以断开连接，在每个tab中可以使用“Ctrl+C”来中断进程：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224079/e3309ca4-d9c1-11e5-897a-04ed2b6c8e82.png" alt="qq20160223-0 2x"><br>我们看到在图中，有Nova和Cinder相关的进程，并且停在了cinder-api的进程上，每个tab中的进程都在运行着。</p><h3 id="3-编辑代码"><a href="#3-编辑代码" class="headerlink" title="3. 编辑代码"></a>3. 编辑代码</h3><p>因为代码大部分都在远端的运行（比如虚拟机），而开发环境则在近端（比如宿主机），如果在远端和近端都维护一套代码，不可避免的会拷来拷去，有时拷错了还得找半天原因。所以得想办法把远端的代码“共享”到近端。因此，我们使用sshfs共享文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  sshfs stack@192.168.56.101:/opt/stack /Users/jiangyikun/development/openstack/code</span><br><span class="line">➜  ~  ls /Users/jiangyikun/development/openstack/code</span><br><span class="line">cinder            heat              logs              noVNC             requirements</span><br><span class="line">data              heat-cfntools     neutron           nova              status</span><br><span class="line">devstack.subunit  heat-templates    neutron-fwaas     os-apply-config   swift</span><br><span class="line">dib-utils         horizon           neutron-lbaas     os-collect-config tempest</span><br><span class="line">glance            keystone          neutron-vpnaas    os-refresh-config</span><br></pre></td></tr></table></figure><p>达到的目的就是，我们编辑<code>/Users/jiangyikun/development/openstack/code</code>的时候，就相当于在远端编辑<code>/opt/stack</code>。在Windows下，也有win-sshfs工具。</p><h3 id="4-启动调试服务器"><a href="#4-启动调试服务器" class="headerlink" title="4. 启动调试服务器"></a>4. 启动调试服务器</h3><p>当我们修改好代码后，就可以进行调试了。调试的原理大致是在近端启动一个debug server，然后，在代码中添加连接服务器的动作，这样，当代码运行到那段调试代码时，便会和调试服务器建立连接。在我的实验环境中，调试环境是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13257974/1042affa-da8c-11e5-99a0-882e5b229354.png" alt="openstack"><br>可以看到在宿主机和虚拟机有2条通路，一条是NAT，作用是让虚拟机通过宿主机的公网IP上网，从而保证Devstack能够顺利启动OpenStack，第二条是Host Only，保证在宿主机内可以对虚拟机进行SSH访问、sshfs文件挂载以及调试。</p><p>因此我们先配置一下远程调试的配置：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224336/fab25a06-d9c2-11e5-8547-b284fe7df997.png" alt="qq20160223-1 2x"></p><p>然后，我们就可以把由于几个调试的服务都启动起来了，例如，我们要调试跟踪Cinder的创建过程，我们就首先建立三个远程调试，其次将调试代码添加到入口处并保存，最后增加断点：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224668/8e9949e0-d9c4-11e5-850f-357b0eaa41c1.png" alt="qq20160223-2 2x"><br>使用Ctrl+c把修改过代码的进程都结束，然后按“上”重新执行指令：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224732/db14a4ea-d9c4-11e5-8e83-706b35f507f5.png" alt="qq20160223-3 2x"><br>重启服务后，代码就生效了，当代码运行到我们需要连接到调试服务的代码后，就会进入断点了：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224833/4a55fed0-d9c5-11e5-8f60-38589e40c34c.png" alt="qq20160223-4 2x"><br>接下来就随心所欲的进行调试吧！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://bingotree.cn/?p=687" target="_blank" rel="noopener">使用DEVSTACK搭建OPENSTACK可remote debug的开发测试环境</a><br><a href="http://kiwik.github.io/openstack/2013/12/21/DevStack-install-in-China/" target="_blank" rel="noopener">DevStack-install-in-China</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恩，题目首先要起的高逼格一些。2333。&lt;/p&gt;
&lt;p&gt;在前面学习代码的过程中，主要通过源码来学习，开始学起来确实有点费劲，因为欠缺对OpenStack的整体的意识，于是&lt;a href=&quot;http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/&quot;&gt;搭建OpenStack开发环境&lt;/a&gt;对OpenStack的运行环境和使用有了初步认知。也看到了启动OpenStack后的一些相关进程，那么这些进程是如何与源码对应起来的呢？如何去调试OpenStack呢？本篇文章就讲下我的探索。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码分析-Cinder删除卷流程</title>
    <link href="http://yikun.github.io/2016/02/21/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E5%88%A0%E9%99%A4%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/02/21/OpenStack源码分析-Cinder删除卷流程/</id>
    <published>2016-02-21T11:56:59.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Cinder删除卷整体流程"><a href="#1-Cinder删除卷整体流程" class="headerlink" title="1. Cinder删除卷整体流程"></a>1. Cinder删除卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130440/f8979c4c-d61e-11e5-8665-84b9d2f928f9.png" alt="delete"></p><p>删除卷流程比较简单，主要就是cinder-api解析Cilent的指令，并响应，发送RPC调用cinder-volume的delete操作，详细流程如下：<br>a. Client发送删除指令，通过RESTful接口访问cinder-api；<br>b. Cinder-api解析响应请求，通过RPC调用cinder-volume；<br>c. Cinder-volume通过调用Driver的delete函数进行删除。</p><h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p> <img src="https://cloud.githubusercontent.com/assets/1736354/13130451/0e77ce74-d61f-11e5-91e9-9b63918beef1.png" alt="cinder delete"></p><h4 id="2-1-Cinder-API"><a href="#2-1-Cinder-API" class="headerlink" title="2.1 Cinder API"></a>2.1 Cinder API</h4><p>(1) Cinder\api\v2\volumes.py<br>VolumeController的delete函数响应请求，首先从API获取Volume对象信息，然后，调用API的delete对对象进行删除；<br>(2) Cinder\volume\api.py<br>API.delete的对卷的状态进行检查，并更新状态为“deleting”，然后调用rpcapi的delete_volume函数</p><h4 id="2-2-Cinder-Volume"><a href="#2-2-Cinder-Volume" class="headerlink" title="2.2 Cinder Volume"></a>2.2 Cinder Volume</h4><p>(1) Cinder\volume\rpcapi.py<br>VolumeAPI函数投递一个远程消息，通过消息队列远程调用cinder volume的delete_volume函数。<br>(2) Cinder\volume\manager<br>最终通过VolumeManager调用dirver的delete_volume对卷进行删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Cinder删除卷整体流程&quot;&gt;&lt;a href=&quot;#1-Cinder删除卷整体流程&quot; class=&quot;headerlink&quot; title=&quot;1. Cinder删除卷整体流程&quot;&gt;&lt;/a&gt;1. Cinder删除卷整体流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack源码分析-Cinder创建卷流程</title>
    <link href="http://yikun.github.io/2016/02/14/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E5%88%9B%E5%BB%BA%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/02/14/OpenStack源码分析-Cinder创建卷流程/</id>
    <published>2016-02-14T09:43:30.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Cinder创卷整体流程"><a href="#1-Cinder创卷整体流程" class="headerlink" title="1. Cinder创卷整体流程"></a>1. Cinder创卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130372/71de5178-d61e-11e5-8d7c-6b9f0a244e41.png" alt="create"></p><p>如整体架构图所示，创建卷涉及的答题步骤主要有以下几步：<br>a. Client发送请求，通过RESTFUL接口访问cinder-api。<br>b. Api解析响应请求，api解析由Client发送来的请求，并通过rpc进一步调用cinder-scheduler。<br>c. Scheduler对资源进行调度，scheduler选择合适的节点进行。<br>d. Volume调用Driver创建卷，volume通过指定Driver进行卷的创建。</p><h3 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h3><p>代码的整体流程如下所示：<br> <img src="https://cloud.githubusercontent.com/assets/1736354/13033012/82f1e54e-d342-11e5-835c-e8f6d3baff40.png" alt="cinder seq"><br>从上图可以看出，整体处理流程包括三大部分，分别是API、Scheduler、Volume三部分。</p><h4 id="2-1-Cinder-API部分"><a href="#2-1-Cinder-API部分" class="headerlink" title="2.1 Cinder API部分"></a>2.1 Cinder API部分</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130422/b4a5c3b0-d61e-11e5-8781-52c9586b9c7d.png" alt="create_api"></p><p>(1) cinder\api\v2\volumes.py<br>VolumeController. create函数对创建请求进行响应，首先函数对volume_type、metadata、snapshot等信息进行检查，然后调用Volume API的create进行创建。<br>(2) cinder\volume\api.py<br>API.create函数对source_volume、volume_type等参数进行进一步检查，并调用cinder.volume.flows.api.get_flow来创建。<br>(3) cinder\volume\flows\api\create_volume.py<br>get_flow函数检查Quata，最后创建EntryCreateTask及VolumeCastTask等任务，<br>其中EntryCreateTask会将卷的创建过程写入数据库，此时卷的状态为”creating”。<br>VolumeCastTask.excute函数会调用VoumeCastTask._cast_create_volume<br>VolumeCastTask._cast_create_volume函数，如果未传入host，则会经过调度进行创建卷，通过scheduler_rpcapi.create_volume创建卷；如果未传入host则直接交由Volume Manager去创建卷。</p><p>至此为止，Cinder API部分完成了自己的工作。</p><h4 id="2-2-Cinder-Scheduler"><a href="#2-2-Cinder-Scheduler" class="headerlink" title="2.2 Cinder Scheduler"></a>2.2 Cinder Scheduler</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130398/8ceff976-d61e-11e5-8ea7-08661eebb7af.png" alt="create_sche"></p><p>(1) cinder\scheduler\rpcapi.py（此步还属于cinder-api）<br>SchedulerAPI.create_volume函数会通过消息异步调用SchedulerManager.create_volume函数。<br>(2) cinder\scheduler\manager.py<br>SchedulerManager.create_volume函数，使用自己的flow来创建volume，其中还传入了Driver。<br>(3) cinder\scheduler\flows\create_volume.py<br>get_flow函数，创建ScheduleCreateVolumeTask<br>ScheduleCreateVolumeTask.execute函数，会调用driver_api.schedule_create_volume<br>(4) cinder\scheduler\filter_scheduler.py<br>FilterScheduler. schedule_create_volume函数，更新数据库，最后通过消息队列请求调用volume_rpcapi.create_volume。</p><h4 id="2-3-Cinder-Volume"><a href="#2-3-Cinder-Volume" class="headerlink" title="2.3    Cinder Volume"></a>2.3    Cinder Volume</h4><p> <img src="https://cloud.githubusercontent.com/assets/1736354/13130404/93c802e8-d61e-11e5-87e7-a01a64765a3b.png" alt="create_volume"><br>(1) /cinder/volume/rpcapi.py（此步还属于cinder-scheduler）<br>VolumeAPI.create_volume会通过消息队列远程调用VolumeManager.create_volume<br>(2) /cinder/volume/manager.py<br>VolumeManager函数也使用flow来创建volume，执行CreateVolumeFromSpecTask这个任务<br>(3) /cinder/volume/flows/manager/create_volume.py<br>CreateVolumeFromSpecTask.excute，这个函数会根据创建的不同类别，去创建卷，例如调用create_raw_volume，最终会调用具体的driver进行卷的创建。<br>在完成创卷后，CreateVolumeOnFinishTask这个任务，启动更新数据库，将卷更新为available状态。</p><p>我们可以看到在创建卷的过程中盘的状态会从“creating”状态变为“available”状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Cinder创卷整体流程&quot;&gt;&lt;a href=&quot;#1-Cinder创卷整体流程&quot; class=&quot;headerlink&quot; title=&quot;1. Cinder创卷整体流程&quot;&gt;&lt;/a&gt;1. Cinder创卷整体流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cl
      
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>搭建OpenStack开发环境</title>
    <link href="http://yikun.github.io/2016/02/09/%E6%90%AD%E5%BB%BAOpenStack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yikun.github.io/2016/02/09/搭建OpenStack开发环境/</id>
    <published>2016-02-09T16:10:09.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间主要了解了一些OpenStack相关的基础性东西，现在希望通过安装使用来增强一下对系统整体的认识，最近也读了一篇文章<a href="http://www.csdn.net/article/2014-04-10/2819247-how-to-learn-opensouce-project-&amp;-ceph" target="_blank" rel="noopener">如何学习开源项目</a>，基本和我的想法很类似，所以基本上也就是按照这个节奏来的。不说废话了，开始。</p><a id="more"></a><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>整体的环境安装是基于[devstack]来搭建，本来就是一个脚本一个配置文件就可以了，不过因为部分网络环境比较“艰苦”，所以需要做一些优化，所以需要做一些准备工作。</p><h4 id="1-1-安装系统"><a href="#1-1-安装系统" class="headerlink" title="1.1 安装系统"></a>1.1 安装系统</h4><p>Virtual Box，<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">下载</a><br>Ubuntu 14.04，<a href="http://www.ubuntu.com/download/desktop/install-ubuntu-desktop" target="_blank" rel="noopener">下载</a><br>网络的话，我是选择了NAT模式，保证虚拟机能够通过宿主机来上网，然后另设了一个Host Only网卡做SSH访问，最近突然发现还可以用NAT端口转发的方式（把22端口转发到主机）完成类似功能，这样就只需要一个网卡了。</p><h4 id="1-2-基本工具"><a href="#1-2-基本工具" class="headerlink" title="1.2 基本工具"></a>1.2 基本工具</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装Git</span></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="1-3-加速Python源"><a href="#1-3-加速Python源" class="headerlink" title="1.3 加速Python源"></a>1.3 加速Python源</h4><p>为了加速下载速度，对Python源进行优化，这里用豆瓣的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.pip/pip.conf</span><br><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br><span class="line">trusted-host = pypi.douban.com</span><br><span class="line">index-url = http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><h4 id="1-4-加速Ubuntu源"><a href="#1-4-加速Ubuntu源" class="headerlink" title="1.4 加速Ubuntu源"></a>1.4 加速Ubuntu源</h4><p>为了加速下载速度，对Ubuntu源进行优化，这里用网易的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/apt/sources.list</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><h3 id="2-下载Devstack"><a href="#2-下载Devstack" class="headerlink" title="2. 下载Devstack"></a>2. 下载Devstack</h3><p>使用Git安装脚本切换到自己需要的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载devstack</span><br><span class="line">git clone https://git.openstack.org/openstack-dev/devstack</span><br><span class="line"># 切换版本</span><br><span class="line">git checkout stable/liberty</span><br></pre></td></tr></table></figure><h3 id="3-创建Stack用户"><a href="#3-创建Stack用户" class="headerlink" title="3. 创建Stack用户"></a>3. 创建Stack用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devstack/tools/create-stack-user.sh; su stack</span><br></pre></td></tr></table></figure><h4 id="4-创建local-conf"><a href="#4-创建local-conf" class="headerlink" title="4. 创建local.conf"></a>4. 创建local.conf</h4><p>创建local.conf文件，并且写入自己的配置，可以参考官方的<a href="http://docs.openstack.org/developer/devstack/configuration.html#minimal-configuration" target="_blank" rel="noopener">Minimal configuration</a>，我的配置如下所示，参考<a href="http://www.chenshake.com/install-ubuntu-14-04-devstack/" target="_blank" rel="noopener">链接</a>做的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/devstack/local.conf</span><br><span class="line">[local|localrc]]</span><br><span class="line">GIT_BASE=https://github.com</span><br><span class="line"># Define images to be automatically downloaded during the DevStack built process.</span><br><span class="line">IMAGE_URLS=&quot;http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img&quot;</span><br><span class="line"># Credentials</span><br><span class="line">DATABASE_PASSWORD=1</span><br><span class="line">ADMIN_PASSWORD=1</span><br><span class="line">SERVICE_PASSWORD=1</span><br><span class="line">SERVICE_TOKEN=1</span><br><span class="line">RABBIT_PASSWORD=1</span><br><span class="line"></span><br><span class="line">HOST_IP=192.168.56.102</span><br><span class="line">SERVICE_HOST=192.168.56.102</span><br><span class="line">MYSQL_HOST=192.168.56.102</span><br><span class="line">RABBIT_HOST=192.168.56.102</span><br><span class="line">GLANCE_HOSTPORT=192.168.56.102:9292</span><br><span class="line"></span><br><span class="line"># Work offline(不需要更新时打开)</span><br><span class="line"># OFFLINE=True</span><br><span class="line"># Reclone each time(需要更新时打开)</span><br><span class="line">RECLONE=yes</span><br><span class="line"></span><br><span class="line"># Logging</span><br><span class="line"># -------</span><br><span class="line"># By default ``stack.sh`` output only goes to the terminal where it runs. It can</span><br><span class="line"># be configured to additionally log to a file by setting ``LOGFILE`` to the full</span><br><span class="line"># path of the destination log file. A timestamp will be appended to the given name.</span><br><span class="line">LOGFILE=/opt/stack/logs/stack.sh.log</span><br><span class="line">VERBOSE=True</span><br><span class="line">LOG_COLOR=True</span><br><span class="line">SCREEN_LOGDIR=/opt/stack/logs</span><br><span class="line"></span><br><span class="line"># the number of days by setting ``LOGDAYS``.</span><br><span class="line">LOGDAYS=1</span><br><span class="line"></span><br><span class="line"># Database Backend MySQL</span><br><span class="line">enable_service mysql</span><br><span class="line"></span><br><span class="line"># RPC Backend RabbitMQ</span><br><span class="line">enable_service rabbit</span><br><span class="line"></span><br><span class="line"># Enable Keystone - OpenStack Identity Service</span><br><span class="line">enable_service key</span><br><span class="line"></span><br><span class="line"># Horizon - OpenStack Dashboard Service</span><br><span class="line">enable_service horizon</span><br><span class="line"></span><br><span class="line"># Enable Swift - Object Storage Service without replication.</span><br><span class="line">enable_service s-proxy s-object s-container s-account</span><br><span class="line">SWIFT_HASH=66a3d6b56c1f479c8b4e70ab5c2000f5</span><br><span class="line">SWIFT_REPLICAS=1</span><br><span class="line"></span><br><span class="line"># Enable Glance - OpenStack Image service</span><br><span class="line">enable_service g-api g-reg</span><br><span class="line"></span><br><span class="line"># Enable Cinder - Block Storage service for OpenStack</span><br><span class="line">enable_service cinder c-api c-vol c-sch c-bak</span><br><span class="line"></span><br><span class="line"># Branches</span><br><span class="line">KEYSTONE_BRANCH=stable/liberty</span><br><span class="line">NOVA_BRANCH=stable/liberty</span><br><span class="line">NEUTRON_BRANCH=stable/liberty</span><br><span class="line">SWIFT_BRANCH=stable/liberty</span><br><span class="line">GLANCE_BRANCH=stable/liberty</span><br><span class="line">CINDER_BRANCH=stable/liberty</span><br><span class="line">HEAT_BRANCH=stable/liberty</span><br><span class="line">TROVE_BRANCH=stable/liberty</span><br><span class="line">HORIZON_BRANCH=stable/liberty</span><br><span class="line">SAHARA_BRANCH=stable/liberty</span><br><span class="line">CEILOMETER_BRANCH=stable/liberty</span><br><span class="line">TROVE_BRANCH=stable/liberty</span><br></pre></td></tr></table></figure><h3 id="5-开始安装"><a href="#5-开始安装" class="headerlink" title="5. 开始安装"></a>5. 开始安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd devstack; ./stack.sh</span><br></pre></td></tr></table></figure><p>最终安装完毕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#... ...</span><br><span class="line">This is your host IP address: 192.168.56.102</span><br><span class="line">This is your host IPv6 address: ::1</span><br><span class="line">Horizon is now available at http://192.168.56.102/dashboard</span><br><span class="line">Keystone is serving at http://192.168.56.102:5000/</span><br><span class="line">The default users are: admin and demo</span><br><span class="line">The password: 1</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>问题： InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately [duplicate] 参考<a href="http://stackoverflow.com/questions/29134512/insecureplatformwarning-a-true-sslcontext-object-is-not-available-this-prevent" target="_blank" rel="noopener">链接</a>解决的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libffi-dev libssl-dev</span><br><span class="line">sudo pip install requests[security]</span><br><span class="line">sudo pip install --upgrade pyopenssl ndg-httpsclient pyasn1 pip</span><br></pre></td></tr></table></figure><p>问题： ERROR: tox version is 2.1.1, required is at least 2.3.1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sudo pip install <span class="string">'tox==2.3.1'</span></span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.chenshake.com/install-ubuntu-14-04-devstack/" target="_blank" rel="noopener">Ubuntu 14.04 Devstack安装Liberty</a><br><a href="http://bingotree.cn/?p=687" target="_blank" rel="noopener">使用DEVSTACK搭建OPENSTACK可remote debug的开发测试环境</a><br><a href="http://docs.openstack.org/developer/devstack/" target="_blank" rel="noopener">DevStack - an OpenStack Community Production</a><br><a href="http://docs.openstack.org/developer/devstack/stack.sh.html" target="_blank" rel="noopener">stack.sh</a><br><a href="http://docs.openstack.org/developer/devstack/configuration.html#minimal-configuration" target="_blank" rel="noopener">Minimal Configuration</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间主要了解了一些OpenStack相关的基础性东西，现在希望通过安装使用来增强一下对系统整体的认识，最近也读了一篇文章&lt;a href=&quot;http://www.csdn.net/article/2014-04-10/2819247-how-to-learn-opensouce-project-&amp;amp;-ceph&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何学习开源项目&lt;/a&gt;，基本和我的想法很类似，所以基本上也就是按照这个节奏来的。不说废话了，开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>存储知识学习</title>
    <link href="http://yikun.github.io/2016/02/03/%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yikun.github.io/2016/02/03/存储知识学习/</id>
    <published>2016-02-03T14:46:58.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-磁盘基本知识"><a href="#1-磁盘基本知识" class="headerlink" title="1. 磁盘基本知识"></a>1. 磁盘基本知识</h2><p>磁盘大致由盘片、磁头、步进电机等几部分组成组成。<br>盘面：硬盘一般含有一个或多个盘片，一个盘片包含两个盘面。<br>磁道：每个盘面被划成多个狭窄的同心圆环，这样的圆环叫做磁道。<br>扇区：每个磁道的每段圆弧叫做一个扇区，是读写的最小单位。<br>柱面：所有盘面上的同一磁道，在竖直方向构成一个圆柱，称为柱面。<br>    读写过程：硬盘读取数据时，磁头先移动到读取扇区所在磁道的上方，这个过程耗时叫做磁盘寻道时间，平均时间为10ms。之后，通过盘片的旋转，使得扇区转到磁头的下方，这个过程耗时叫做旋转延迟时间，对于7200转/min的硬盘转一周为60*1000/7200=8.33ms，平均旋转延迟为4.17ms（半圈）。</p><h3 id="2-RAID基本知识"><a href="#2-RAID基本知识" class="headerlink" title="2. RAID基本知识"></a>2. RAID基本知识</h3><p>RAID（Redundant Array of Independent Disks），即由独立的磁盘组成的具有冗余特性的阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。<br>RAID 0，条带化存储，容量增加，并行化，但无冗余，容易单点故障。</p><p>RAID 1，镜像存储，写入速率慢，读取速率快，有冗余备份，优点是高可靠、高可用，缺点是高花费。</p><p>RAID 2，RAID 0的改进版，使用汉明码进行检测和纠错，适用于连续IO、大块IO（如视频流）。</p><p>RAID 3，RAID 3和RAID 2的思路比较相似，使用奇偶校验进行错误检测和纠错，但校验盘单点故障。</p><p>RAID 4，RAID 4和RAID 3思路一样，只不过是使用BLOCK进行存储。</p><p>RAID 5，校验信息交叉的存储在所有数据盘上，高冗余，高数据传输率，实现复杂。</p><p>RAID 6，相比RAID5增加块内的校验，允许同时坏2块硬盘而不丢失数据。</p><p>RAID 01，先做条带（0），再做镜像（1）。读写速度快，数据保护能力强，空间利用率50%。<br>RAID 10，先做镜像（1），再做条带（0）。</p><h3 id="3-存储方式"><a href="#3-存储方式" class="headerlink" title="3. 存储方式"></a>3. 存储方式</h3><p>根据网上的资料和理解，用Visio整理了一张图对比了下几种方式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/12811291/7906961c-cb66-11e5-89da-3f2bc2f00108.png" alt="das_nas_san"></p><p>DAS全称为Direct Attached Storage，即服务器直连存储。如图所示，文件系统直接通过RAID完成对硬件访问。优点是操作简便，经济，缺点是分散式存储，不可集中管理。<br>NAS全称为Network Attached Storage，即网络存储服务。如图所示，文件系统通过网络暴露出来给应用服务。优点是结构简单。配置使用管理非常方便，可实现跨平台的数据共享。缺点是需要占用网络资源、应用局限性大。<br>SAN全称为Storage Aera Network，即存储区域网络，如图所示，RAID接口通过网络暴露出来。优点是扩展性强，集中管理，缺点是成本较高，管理维护难度大。</p><h3 id="4-IP-SAN与FC-SAN"><a href="#4-IP-SAN与FC-SAN" class="headerlink" title="4. IP SAN与FC SAN"></a>4. IP SAN与FC SAN</h3><p>FC SAN指基于光纤通道（Fiber Channel）的存储区域网，在FC SAN中存在两张网，一张面向应用的网（IP网），另一张中则是存储网（FC网）。而IP SAN的出现则是为了寻求一种新的方式，用与应用网相同的体系架构来构造存储网，使用通用的IP网络及设备。<br>FC SAN性能好，价格高，但与主流的IP网络异构。适用于关键应用的几种存储、备份及容灾。<br>IP SAN则由于以太网MTU（1518字节）的限制，性能稍差，但基于通用的IP协议。适用于异地间的数据交换、备份容灾，非关键应用的集中存储。</p><h3 id="5-LVM基本知识"><a href="#5-LVM基本知识" class="headerlink" title="5. LVM基本知识"></a>5. LVM基本知识</h3><p>LVM的全称是Logical Volume Manager，逻辑卷轴管理，主要解决的问题是，弹性调整文件系统的容量。</p><p><img src="https://cloud.githubusercontent.com/assets/1736354/12811308/9e2cf4e0-cb66-11e5-91e4-5d375b576ae7.png" alt="lvm"></p><p>与传统的磁盘与分区相比，LVM为计算机提供了更高层次的存储，通过在磁盘分区和文件系统之间增加一个逻辑层，提供一个抽象的逻辑盘卷。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>《大话存储》</li><li>RAID技术介绍和总结<a href="http://blog.jobbole.com/83808/" target="_blank" rel="noopener">http://blog.jobbole.com/83808/</a></li><li>基于OpenStack的NAS服务<a href="https://www.ustack.com/blog/openstack-nas/" target="_blank" rel="noopener">https://www.ustack.com/blog/openstack-nas/</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-磁盘基本知识&quot;&gt;&lt;a href=&quot;#1-磁盘基本知识&quot; class=&quot;headerlink&quot; title=&quot;1. 磁盘基本知识&quot;&gt;&lt;/a&gt;1. 磁盘基本知识&lt;/h2&gt;&lt;p&gt;磁盘大致由盘片、磁头、步进电机等几部分组成组成。&lt;br&gt;盘面：硬盘一般含有一个或多个盘片
      
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title>[译]Internationalization</title>
    <link href="http://yikun.github.io/2016/01/22/%E8%AF%91-Internationalization/"/>
    <id>http://yikun.github.io/2016/01/22/译-Internationalization/</id>
    <published>2016-01-22T16:43:37.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nova uses the <strong>oslo.i18n library</strong> to <strong>support internationalization</strong>. The oslo.i18n library is built on top of <strong>gettext</strong> and provides functions that are used to enable user-facing strings such as log messages to appear in the <strong>appropriate language in different locales</strong>.</p><p>Nova exposes the oslo.i18n library support via the nova/i18n.py integration module. This module provides the functions needed to wrap translatable strings. It provides the _() wrapper for general user-facing messages and specific wrappers for messages used only for logging. DEBUG level messages do not need translation but CRITICAL, ERROR, WARNING and INFO messages should be wrapped with _LC(), _LE(), _LW() or _LI() respectively.</p></blockquote><p>理解：Nova是通过oslo.i18n来支持国际化的，oslo.i18n是基于getnext做的，这个库可以把面向用户的字符（比如日志）翻译成指定的语言。其中DEBUG信息不翻译，其他的信息会被翻译。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug log</span></span><br><span class="line">LOG.debug(<span class="string">"block_device_mapping %(mapping)s"</span>,</span><br><span class="line">          &#123;<span class="string">'mapping'</span>: block_device_mapping&#125;)</span><br><span class="line"><span class="comment"># warn log</span></span><br><span class="line">LOG.warn(_LW(<span class="string">'Unknown base file %(img)s'</span>), &#123;<span class="string">'img'</span>: img&#125;)</span><br><span class="line"><span class="comment"># not log</span></span><br><span class="line"><span class="keyword">raise</span> nova.SomeException(_(<span class="string">'Invalid service catalogue'</span>))</span><br></pre></td></tr></table></figure><blockquote><p>Do not use locals() for formatting messages because: 1. It is not as clear as using explicit dicts. 2. It could produce hidden errors during refactoring. 3. Changing the name of a variable causes a change in the message. 4. It creates a lot of otherwise unused variables.</p><p>If you do not follow the project conventions, your code may cause hacking checks to fail.</p></blockquote><p>另外，文中提到了不要使用<code>locals()</code>去格式化消息主要4点原因：1.不清楚是否有关键字. 2.重构时会有潜在的出错可能. 3.变量名变了消息就变. 4.创建很多无用的变量。</p><p>这些函数_(), _LC(), _LE(), _LW() and _LI()可以通过以下方法导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LC</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LE</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LW</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LI</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Nova uses the &lt;strong&gt;oslo.i18n library&lt;/strong&gt; to &lt;strong&gt;support internationalization&lt;/strong&gt;. The oslo.i18n library is 
      
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>[译]Virtual Machine States and Transitions</title>
    <link href="http://yikun.github.io/2016/01/20/%E8%AF%91-Virtual-Machine-States-and-Transitions/"/>
    <id>http://yikun.github.io/2016/01/20/译-Virtual-Machine-States-and-Transitions/</id>
    <published>2016-01-20T15:46:59.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机的状态及其转移，主要讲了一些虚拟机的状态以及在创建虚拟机时的状态转移情况，目前理解不够深刻，需要在后面看代码时，进一步深入理解。</p><a id="more"></a><h3 id="Allowed-State-Transitions"><a href="#Allowed-State-Transitions" class="headerlink" title="Allowed State Transitions"></a>Allowed State Transitions</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/12451522/ee92a928-bfc4-11e5-89cf-cc39c09a7fea.png" alt="Allowed State Transitions"></p><h3 id="Create-Instance-States"><a href="#Create-Instance-States" class="headerlink" title="Create Instance States"></a>Create Instance States</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/12451543/0a1f8fc6-bfc5-11e5-8f30-c893782b278e.png" alt="Create Instance States"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机的状态及其转移，主要讲了一些虚拟机的状态以及在创建虚拟机时的状态转移情况，目前理解不够深刻，需要在后面看代码时，进一步深入理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title>2015，再见</title>
    <link href="http://yikun.github.io/2016/01/01/2015%EF%BC%8C%E5%86%8D%E8%A7%81/"/>
    <id>http://yikun.github.io/2016/01/01/2015，再见/</id>
    <published>2016-01-01T16:05:42.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>2015年是很特殊的一年，是长达快20年的学生时代的终结。从年初最开始的时候，就对今年的会发生的事情做好了准备，也基本上按照自己的想法发生了。之前，也有一些计划，基本达到预期，现在想起这些目标都算是一些学生时代的梦想吧，这篇总结也大致的从这些方面展开。</p><a id="more"></a><h3 id="一个实习"><a href="#一个实习" class="headerlink" title="一个实习"></a>一个实习</h3><p>年初的计划是百度，腾讯，阿里的任何一个地方实习。当时心中最想去的是腾讯或者阿里，对百度不感兴趣的原因主要是在北京呆了太久了，新鲜感没了：）。</p><p>对于实习整体对自己比较满意，算是把一个目标分解到执行实施的一个完整过程。从面试准备到拿到offer，从开始实习到实习转正，都有条不紊按照自己的计划一步一步地实施。有预判，有变化，提前准备，未雨绸缪，占据主动，值得再接再厉。</p><p>实习面试准备得还算充分，从过年那会儿就开始准备了，补Java的基础，看Collection的源码，刷leetcode。在三月，实习的提前批就拿到了蚂蚁金服支付宝研发的offer。</p><p>实习的过程中，也看到了一个互联网企业中人们的生活状态：苦逼而快乐。加班是常态，不过抱怨的人不多，大概是大家都有一颗为了自己或者阿里付出的心吧。组内的氛围很好，没有主管，组员什么的分别。总得来说，真的是开开心心地上班，每个人都有存在感，每个人都有机会，牛人有更大的舞台。和主管，师兄，师傅学到了很多做人处事的方法或者态度，谦逊努力，积极思考，善于沟通。</p><p>实习结束后的转正答辩也比较顺利，当时是拿到了HR的口头offer，不过预估自己可能不会留下，在走的时候，也没给主管一个确定的回复，感觉挺抱歉的，找完工作后也和师兄，师傅他们聊了一些，也得到了很多的发展和工作的建议，也算是解了自己的心结。</p><p>花名不改，江湖犹在，后悔有期，就像一弦哥说的那样：世界很小的，有心的话很快就会再见面。</p><h3 id="一台Macbook-Pro"><a href="#一台Macbook-Pro" class="headerlink" title="一台Macbook Pro"></a>一台Macbook Pro</h3><p>今年新添了个设备，13寸的Macbook Pro，惯例的，还是花自己的钱。</p><p>首先是自己对mac的印象比较好，促使我买mac主要有几点吧，一是大家都说mac是程序员的神器，买的人都说谁用谁知道；二是大致预料到可能今年不买以后会更犹豫。最后一点是，真的有买mac的钱了，是的，没错这才是最重要的一点。</p><p>于是，在北京的时候，用学生价在西单大悦城的实体店买的，从决定买到买到手大概就是一个早上。总体来说，比较满意，和预想的差不多，最开始的时候只有对command键不太适应，其他基本顺畅，基本平滑过度。现在的日用，技术博客，编码基本都适应了。最近配合着新买不久的数位板，也用漫画的形式了记录了一下研究生的生活，目前线稿基本搞定，该上色了。：）</p><p>总觉得年轻时应该有一些“意气用事”的决定，因为我们年轻，有承担失败的试错资本，也可以尽情地享受意外的惊喜，想到什么就去做吧，开心就好。</p><h3 id="一份工作"><a href="#一份工作" class="headerlink" title="一份工作"></a>一份工作</h3><p>其实对于找工作来说，和其他大多数同学来说，不算太艰辛， 算下来面试过腾讯，百度，阿里，头条，华为，小米，IBM一共7家。</p><p>在实习的时候，有个周末去深圳参加了腾讯提前批的TST面试，顺利拿到offer，好的开始也奠定了后期找工作的心态，后面阿里这边也顺利转正拿到口头offer，因为觉得留在杭州的可能不大，所以走的时候就没和部门说定，发生了拥抱变化的故事后，也便不了了之。在随后的面试中，也拿到了北京小米的sp offer，比较意外的是居然还有北京户口，然后就是华为的sp offer。其中，百度和头条挂掉的原因总结一下也是因为算法面试准备的不充分，想想没有集齐BAT召唤神龙，有点可惜。然后IBM面试都搞定了，流程比较慢，有缘再会。最终，综合考虑各种因素，选择了西安华为作为工作开始的地方。</p><p>单从工作性质来讲，华为并不是最优选择， 其实拿到offer的这些在我心中都是很好的选择，都有很多诱惑的地方，留西安确实是一个很重要的因素，对于这个选择，原因只有三个字：不辜负。现在描述这些的时候真的很平静，也许是因为很早就想通的原因，也一定会既来之，则安之，化那些不甘为努力奋斗。</p><p>每个阶段都有自己的选择，也希望以后再做选择时，能够想清楚自己真正想要的是什么，选择自己最珍视的东西，不被诱惑，不被干扰，相信自己的感觉，自己满意就好。</p><h3 id="读书与博客"><a href="#读书与博客" class="headerlink" title="读书与博客"></a>读书与博客</h3><p>计划是每月大概一本的样子，为了记录一下读书的过程，写了个<a href="https://github.com/Yikun/hexo-generator-douban" target="_blank" rel="noopener">插件</a>把豆瓣的读书记录同步到自己的<a href="http://yikun.github.io/douban/">博客</a>了。</p><p>今年读了7本书，不过每本都是认认真真的读。今天还和室友聊起了读书数目的问题，大致达成的结论是：读书要有质量，要有感受，不要太盲目。</p><p>另外，自己的技术博客也慢慢积累起来了，期望在未来能够学有所思，不断积累。</p><p>2015，这一年<br>前面依着自己的计划，算是把2015这一年基本覆盖了，2015这一年待过不少城市，在北京科研，去芭提雅玩，去曼谷参加姐姐的婚礼，在杭州阿里实习，去上海找兄弟聚，去深圳腾讯面试，去三亚Outing，到成都和银川毕业旅行，总得来说是在忙碌中四处穿行。</p><p>2015对自己比较满意的是能够按照自己的思考一步一步地把一些事情做好，而这些事情主要归功于提前的计划和不断的思考，不过还是有些地方没有思考全面。2015对自己不太满意的是在一些有压力的时候会有些不知所措，遇到未知的事情不够淡定，犹豫不决，决策能力需要提升。 以后肯定会越来越忙的，希望自己能够不断思考总结，迎接变化，更重要的是在任何时候都不要迷失了自己。</p><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>未来一年对自己的期望是：技术更加专注有深度，做人更加靠谱有内涵，生活更加丰富有惊喜。</p><p>最后，2015，再见，2016，你好！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015年是很特殊的一年，是长达快20年的学生时代的终结。从年初最开始的时候，就对今年的会发生的事情做好了准备，也基本上按照自己的想法发生了。之前，也有一些计划，基本达到预期，现在想起这些目标都算是一些学生时代的梦想吧，这篇总结也大致的从这些方面展开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Python3源码学习-整型</title>
    <link href="http://yikun.github.io/2015/12/21/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%95%B4%E5%9E%8B/"/>
    <id>http://yikun.github.io/2015/12/21/Python3源码学习-整型/</id>
    <published>2015-12-21T13:48:29.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>我们先看看对整型变量i进行赋值，并对i进行显示的过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>在之前已经了解到对象是如何存储、组织的了，那么，整型是如何存储的呢？在Python 2中，整型是分Int和Long的，稍小一点的数直接用C语言中的long去存储，稍大一点的数（超过long的承受范围）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.10</span> (default, Jul <span class="number">14</span> <span class="number">2015</span>, <span class="number">19</span>:<span class="number">46</span>:<span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.maxsize</span><br><span class="line"><span class="comment">#2**63-1</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(sys.maxsize)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(sys.maxsize+<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'long'</span>&gt;</span><br></pre></td></tr></table></figure><p>而在Python 3中，我们进行相同的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.5</span><span class="number">.0</span> (default, Dec <span class="number">20</span> <span class="number">2015</span>, <span class="number">21</span>:<span class="number">24</span>:<span class="number">49</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.maxsize</span><br><span class="line"><span class="comment">#2**63-1</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">1</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(sys.maxsize)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(sys.maxsize+<span class="number">1</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>我们发现不论这个数是“大”是“小”，都无差别的显示为“int”了。那么，在Python3中做了哪些变动呢？Python3如何“一统天下”大小，存储整型数据呢？在Python 2中，分别使用intobject和longobject去存储整型，而在Python 3中，则使用longobject统一的表示整型，并且将type也设为“int”，在<a href="https://www.python.org/dev/peps/pep-0237/" target="_blank" rel="noopener">PEP 237 – Unifying Long Integers and Integers</a>中，详细的阐述了这个改变，下面让我们详细看看Python 3中整型的实现。</p><h3 id="2-整型的实现"><a href="#2-整型的实现" class="headerlink" title="2. 整型的实现"></a>2. 整型的实现</h3><p>我们先看看longobject.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> <span class="title">PyLongObject</span>;</span> <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure><p>按着注释解释，发现了整型的庐山真面目在longintrepr.h中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Long integer representation.</span></span><br><span class="line"><span class="comment">   The absolute value of a number is equal to</span></span><br><span class="line"><span class="comment">    SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</span></span><br><span class="line"><span class="comment">   Negative numbers are represented with ob_size &lt; 0;</span></span><br><span class="line"><span class="comment">   zero is represented by ob_size == 0.</span></span><br><span class="line"><span class="comment">   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant</span></span><br><span class="line"><span class="comment">   digit) is never zero.  Also, in all cases, for all valid i,</span></span><br><span class="line"><span class="comment">    0 &lt;= ob_digit[i] &lt;= MASK.</span></span><br><span class="line"><span class="comment">   The allocation function takes care of allocating extra memory</span></span><br><span class="line"><span class="comment">   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   CAUTION:  Generic code manipulating subtypes of PyVarObject has to</span></span><br><span class="line"><span class="comment">   aware that ints abuse  ob_size's sign bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释非常清楚，我们得到以下信息：</p><ol><li>整数的绝对值为<code>SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</code>。</li><li>0值用<code>obsize==0</code>来表示。</li><li>对于正常的数，<code>ob_digit[abs(ob_size)-1]</code>非0。</li><li>对于有效的<code>i</code>，<code>ob_digit[i]</code>的范围在<code>[0, MASK]</code>。</li></ol><p>可以看到整型是借助柔性数组来实现的，柔性数组较指针来说，分配内存和释放内存时更为方便，且数组名本身不占用空间（指针需要占用1个int型的控件），柔性数组相关内容可以参考<a href="http://blog.csdn.net/fengbingchun/article/details/24185217" target="_blank" rel="noopener">链接</a>。</p><p>光看描述可能有点抽象，我们看一个具体的例子，在我的环境中，SHIFT为30，MASK则为2的30次方-1，<code>1152921506754330628</code>这个数字在代码中是这样存储的，ob_size为3，ob_digit为4-2-1，我们来看看具体的表示含义：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11933249/af84fe30-a835-11e5-8a09-257bb08b3c12.png" alt="int"><br>很熟悉吧，其实就是个进制转换过程：2的30次方进制转换为10进制！没错，就是这么简单。</p><h3 id="3-常用整数的优化"><a href="#3-常用整数的优化" class="headerlink" title="3. 常用整数的优化"></a>3. 常用整数的优化</h3><p>我们再观察一个现象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j=<span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i <span class="keyword">is</span> j</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i=<span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j=<span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i <span class="keyword">is</span> j</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>我们发现对于第一个来说，i和j是一个对象，而第二个例子i和j是不同的对象。<br>可以想象的，如果每个整型都需要使用对象来表示，那么每创建一个整型就需要创建一个对象，这显然是不合理的，因此设计者将[-5, 257)范围内的整型数据进行了特殊处理，即在初始化的时候就将这些对象产生好，以后需要这些对象时直接从对象池取就好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NSMALLPOSINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NSMALLNEGINTS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Small integers are preallocated in this array so that they</span></span><br><span class="line"><span class="comment">   can be shared.</span></span><br><span class="line"><span class="comment">   The integers that are preallocated are those in the range</span></span><br><span class="line"><span class="comment">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="keyword">if</span> (ival &gt;= <span class="number">0</span>)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_SMALL_INT(ival) \</span></span><br><span class="line">    <span class="function"><span class="keyword">do</span> <span class="title">if</span> <span class="params">(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS)</span> </span>&#123; \</span><br><span class="line">        <span class="keyword">return</span> get_small_int((sdigit)ival); \</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="4-Hack一下"><a href="#4-Hack一下" class="headerlink" title="4. Hack一下"></a>4. Hack一下</h3><p>为了验证我们对整型实现理解的正确性，我们修改<code>long_to_decimal_string_internal</code>中加入一些代码，打印出整型变量的详情：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">long_to_decimal_string_internal(PyObject *aa,</span><br><span class="line">                                PyObject **p_output,</span><br><span class="line">                                _PyUnicodeWriter *writer)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *scratch, *a;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    Py_ssize_t size, <span class="built_in">strlen</span>, size_a, i, j;</span><br><span class="line">    digit *pout, *pin, rem, tenpow;</span><br><span class="line">    <span class="keyword">int</span> negative;</span><br><span class="line">    <span class="keyword">enum</span> PyUnicode_Kind kind;</span><br><span class="line"></span><br><span class="line">    a = (PyLongObject *)aa;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"==== Hack Code ====\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ob_size     = %d\n"</span>, Py_SIZE(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ob_i = <span class="number">0</span>; ob_i &lt; Py_SIZE(a); ++ob_i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ob_digit[%d] = %d\n"</span>, ob_i, a-&gt;ob_digit[ob_i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"====    End    ====\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后，我们看到结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">60</span>+<span class="number">2</span>*<span class="number">2</span>**<span class="number">30</span>+<span class="number">4</span></span><br><span class="line">==== Hack Code ====</span><br><span class="line">ob_size     = <span class="number">3</span></span><br><span class="line">ob_digit[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">ob_digit[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">ob_digit[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">====    End    ====</span><br><span class="line"><span class="number">1152921506754330628</span></span><br></pre></td></tr></table></figure><p>我们看到，结果与我们预期的一样，ob_size为3，代表ob_digit的数组大小为3，ob_digit表述的数值为(2^60) x <code>1</code> + (2^30) x <code>2</code> + (2^0) x <code>4</code>。完整代码工程请见<a href="https://github.com/Yikun/Python3/commit/b816507f56ee14b730b7ab52a61eb17f9eb9d815" target="_blank" rel="noopener">链接</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.python.org/dev/peps/pep-0237/" target="_blank" rel="noopener">PEP 237 – Unifying Long Integers and Integers</a><br><a href="http://stackoverflow.com/questions/2104884/how-does-python-manage-int-and-long" target="_blank" rel="noopener">How does Python manage int and long?</a><br><a href="http://stackoverflow.com/questions/22875067/how-does-python-represent-such-large-integers" target="_blank" rel="noopener">How does python represent such large integers?</a><br><a href="http://www.itsprite.com/pythonhow-does-c-implements-the-python-assignment-of-large-numbers/" target="_blank" rel="noopener">Python:How does C implements the Python assignment of large numbers</a><br><a href="https://ep2013.europython.eu/conference/talks/hacking-pylongobject-on-python-32" target="_blank" rel="noopener">HACKING PYLONGOBJECT ON PYTHON 3.2</a><br><a href="https://interma.wordpress.com/2012/10/11/py3_integral/" target="_blank" rel="noopener">py3源码-2-整数</a><br><a href="http://foofish.net/blog/89/python_int_implement" target="_blank" rel="noopener">Python 整数对象实现原理</a><br><a href="http://blog.csdn.net/fengbingchun/article/details/24185217" target="_blank" rel="noopener">结构体中最后一个成员为[0]或[1]长度数组(柔性数组成员)的用法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-引入&quot;&gt;&lt;a href=&quot;#1-引入&quot; class=&quot;headerlink&quot; title=&quot;1. 引入&quot;&gt;&lt;/a&gt;1. 引入&lt;/h3&gt;&lt;p&gt;我们先看看对整型变量i进行赋值，并对i进行显示的过程：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python3源码学习-类型</title>
    <link href="http://yikun.github.io/2015/12/20/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yikun.github.io/2015/12/20/Python3源码学习-类型/</id>
    <published>2015-12-20T15:03:21.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p>我们在《Python3源码学习-对象》中提到了每个对象都含有一个type的属性，我们看看type是个什么东西，目光移到object.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure><a id="more"></a><p>可以看到，PyTypeObject就是类型对象的定义了。其中，包含了一些和类型相关的重要信息：</p><ul><li><strong>类型名</strong>： <code>const char *tp_name</code>，例如对于整型对象，他的这个name就是“int”。</li><li><strong>开辟空间大小</strong>：<code>tp_basicsize</code>和<code>tp_itemsize</code>包含了创建该类型的对象所需要分配的控件大小。</li><li><strong>一些与对象相关联的操作</strong>：比如<code>tp_dealloc</code>用于销毁对象，<code>tp_hash</code>用于计算hash值，<code>tp_str</code>用于将对象转换为str。<h3 id="2-类型的类型"><a href="#2-类型的类型" class="headerlink" title="2. 类型的类型"></a>2. 类型的类型</h3></li></ul><p>另外可以看到，由该类的属性<code>PyObject_VAR_HEAD</code>看出，类型也是一个对象。我们知道每个对象都会有一个类型，那么思考一个问题，类型对象的类型又是什么呢？这个问题在typeobject.c的文件中给出了答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"type"</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到类型对象的类型就是<code>PyType_Type</code>，而PyType_Type的类型则执行它本身。</p><h3 id="3-对象图示"><a href="#3-对象图示" class="headerlink" title="3. 对象图示"></a>3. 对象图示</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11918443/66f1c2c6-a76c-11e5-8838-f742ec215af2.png" alt="type object"></p><p>如上图所示，是一个简单的整型对象的例子，我们可以看出：</p><ol><li>整型对象的类型是PyLong_Type。</li><li>PyLong_Type是一个类型对象，其类型为PyType_Type。</li><li>PyType_Type也是一个类型对象，其类型为它本身。</li></ol><p>我们也可以看出因为“万物皆对象”，不同的object虽然type不同，但是都有一个类型指针，通过类型指针ob_type即可完成对应方法的访问，Python也正是利用了指针的特性，从而实现了多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-类型&quot;&gt;&lt;a href=&quot;#1-类型&quot; class=&quot;headerlink&quot; title=&quot;1. 类型&quot;&gt;&lt;/a&gt;1. 类型&lt;/h3&gt;&lt;p&gt;我们在《Python3源码学习-对象》中提到了每个对象都含有一个type的属性，我们看看type是个什么东西，目光移到object.h：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; _&lt;span class=&quot;title&quot;&gt;typeobject&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    PyObject_VAR_HEAD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *tp_name; &lt;span class=&quot;comment&quot;&gt;/* For printing, in format &quot;&amp;lt;module&amp;gt;.&amp;lt;name&amp;gt;&quot; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Py_ssize_t tp_basicsize, tp_itemsize; &lt;span class=&quot;comment&quot;&gt;/* For allocation */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Methods to implement standard operations */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    destructor tp_dealloc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//... ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* More standard operations (here for binary compatibility) */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    hashfunc tp_hash;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ternaryfunc tp_call;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reprfunc tp_str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getattrofunc tp_getattro;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setattrofunc tp_setattro;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//... ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; PyTypeObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python3源码学习-编译Python源码</title>
    <link href="http://yikun.github.io/2015/12/20/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%BC%96%E8%AF%91Python%E6%BA%90%E7%A0%81/"/>
    <id>http://yikun.github.io/2015/12/20/Python3源码学习-编译Python源码/</id>
    <published>2015-12-20T12:36:58.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>在进行源码学习的时候，“实践出真知”。因此，在进行源码学习的过程中，我们首先需要对源码进行编译，然后，对我们感兴趣的点进行log，甚至debug。本篇文章记录了我在进行Python 3.5.0源码编译时的一些过程。</p><a id="more"></a><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h3><p>在官网<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">下载</a>最新源码，为了方便跟踪源码的修改，借助git来管理Python源码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -am "Python 3.5.0 source."</span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>在编译前需要使用configure对源码进行配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>配置完源码后，使用git status观察一下变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  Python-3.5.0 git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">    Makefile</span><br><span class="line">    Makefile.pre</span><br><span class="line">    Misc/python-config.sh</span><br><span class="line">    Misc/python.pc</span><br><span class="line">    Modules/Setup</span><br><span class="line">    Modules/Setup.config</span><br><span class="line">    Modules/Setup.local</span><br><span class="line">    Modules/config.c</span><br><span class="line">    Modules/ld_so_aix</span><br><span class="line">    config.log</span><br><span class="line">    config.status</span><br><span class="line">    pyconfig.h</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>我们看到产生了一些和make相关的配置文件，用来适配当前的环境。<br>用git提交一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am &quot;After ./configure .&quot;</span><br></pre></td></tr></table></figure><h3 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h3><p>编译Python时，使用make进行编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成后，产生了一个python.exe文件，便是我们编译所得的执行文件。</p><blockquote><p>注<br>我是在OSX下进行编译的，在编译过程中遇到了<code>fatal error: &#39;lzma.h&#39; file not found</code>问题，把lzma包安上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; brew install xz</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./python.exe</span><br></pre></td></tr></table></figure><p>以上便完成了整个Python源码的编译。以后，在修改完代码以后，只需要<code>make;./python.exe</code>就好~那么，享受Hack python code的乐趣吧。：）</p><p>代码已上传，并根据学习过程不断更新：<a href="https://github.com/Yikun/Python3" target="_blank" rel="noopener">https://github.com/Yikun/Python3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行源码学习的时候，“实践出真知”。因此，在进行源码学习的过程中，我们首先需要对源码进行编译，然后，对我们感兴趣的点进行log，甚至debug。本篇文章记录了我在进行Python 3.5.0源码编译时的一些过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python3源码学习-对象</title>
    <link href="http://yikun.github.io/2015/12/03/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yikun.github.io/2015/12/03/Python3源码学习-对象/</id>
    <published>2015-12-03T07:07:19.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始看Python源码，大致看了看，发现Py2和Py3的部分实现差别挺大，《Python源码剖析》是根据Python 2写的。不过为了能激发主动性，便直接从Python 3（3.5.0）源码看起了，然后也会结合Python 2（2.7.10）的代码看看之前的实现，来对比学习~：）</p><h3 id="1-万物皆对象"><a href="#1-万物皆对象" class="headerlink" title="1. 万物皆对象"></a>1. 万物皆对象</h3><p>在Python中，万物皆对象，那么对象又是什么结构，如何组织，怎样实现的呢？</p><a id="more"></a><blockquote><p>Objects are structures allocated on the heap.  Special rules apply to the use of objects to ensure they are properly garbage-collected. Objects are never allocated statically or on the stack; they must be accessed through special macros and functions only.(Type objects are exceptions to the first rule; the standard types are represented by statically initialized type objects, although work on type/class unification for Python 2.2 made it possible to have heap-allocated type objects too).</p></blockquote><p>从Python的源码注释可以得到以下信息点：</p><ul><li>对象一般就是开辟在堆上的结构体；</li><li>一些特殊的规则运用在对象上，以保证他们被正确的GC；</li><li>对象永远不会静态开辟或者在栈上；</li></ul><p>然后，还补充说，Type对象除外，标准的type对象是静态初始化的，Python 2.2把在堆上初始化type对象变成了现实。</p><h3 id="2-对象的结构"><a href="#2-对象的结构" class="headerlink" title="2. 对象的结构"></a>2. 对象的结构</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11553779/03a14ebe-99cd-11e5-8640-dde569539e9d.png" alt="object"></p><p>Python中的对象，主要分为一般对象和变长对象（list、dict之类），一般的对象就是PyObject，然后变长对象其实就是给PyObject加了个size成为了PyVarObject。</p><p>对于所有对象来说，均有2个重要的元素：</p><ul><li>引用计数（reference count），对象中的引用计数用来记录引用对象的数目，会在指针指向或删除对该对象的引用时，相应的增加或者减少，当引用计数达到0，就代表这没有指针指向这个对象了，这个对象便会在堆中移除。从名字就可以看出来，这个域是为了支持垃圾回收而定义的。</li><li>类型（type），对象的类型表示对象包含数据的类型，每个对象中都有一个指向类型的指针。比较有意思的是，type也是一个对象，type对象的类型是它本身，所以type对象的类型指针就指向它自己了。</li></ul><p>对于可变长的对象（比如list，dict），会多一个域：</p><ul><li>大小（size），这个大小表示这个变长变量中元素的个数。注意，是元素的个数，不是字节个数。</li></ul><p>另外头部还有<code>_PyObject_HEAD_EXTRA</code>，这个宏定义了next和prev指针，用来支持用一个双链表把所有堆中的对象串起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_next</span>;</span>           \</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> *_<span class="title">ob_prev</span>;</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>Python-3.5.0源码<br><a href="http://www.wklken.me/posts/2014/08/05/python-source-object.html#pyobject_head" target="_blank" rel="noopener">PYTHON 源码阅读 - 对象</a><br><a href="http://book.douban.com/subject/3117898/" target="_blank" rel="noopener">Python源码剖析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始看Python源码，大致看了看，发现Py2和Py3的部分实现差别挺大，《Python源码剖析》是根据Python 2写的。不过为了能激发主动性，便直接从Python 3（3.5.0）源码看起了，然后也会结合Python 2（2.7.10）的代码看看之前的实现，来对比学习~：）&lt;/p&gt;
&lt;h3 id=&quot;1-万物皆对象&quot;&gt;&lt;a href=&quot;#1-万物皆对象&quot; class=&quot;headerlink&quot; title=&quot;1. 万物皆对象&quot;&gt;&lt;/a&gt;1. 万物皆对象&lt;/h3&gt;&lt;p&gt;在Python中，万物皆对象，那么对象又是什么结构，如何组织，怎样实现的呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>网络知识拾遗</title>
    <link href="http://yikun.github.io/2015/11/23/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"/>
    <id>http://yikun.github.io/2015/11/23/网络知识拾遗/</id>
    <published>2015-11-23T13:19:23.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。</p><a id="more"></a><h2 id="1-二层交换"><a href="#1-二层交换" class="headerlink" title="1. 二层交换"></a>1. 二层交换</h2><p>二层交换指的是传统的二层交换机实现的功能，主要的功能就是将以太网帧从一个端口接收，并从合适的端口发送出去。</p><h3 id="1-1-以太网帧"><a href="#1-1-以太网帧" class="headerlink" title="1.1 以太网帧"></a>1.1 以太网帧</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11339369/29e0977e-9234-11e5-880f-8c03596d1246.png" alt="emac"></p><!--more--><p>以太网帧如上图所示，如此构造主要是为了表达这个帧：到哪去（目的MAC，6字节）、从哪来（源MAC，6字节）、什么帧（长度/类型，2字节）、有什么（数据，40~1500字节）、错没错（FCS，CRC，4字节）。</p><p>用户数据的长度不同，以太网帧的长度也不同，范围为64-1518字节。</p><h3 id="1-2-存储转发与地址学习"><a href="#1-2-存储转发与地址学习" class="headerlink" title="1.2 存储转发与地址学习"></a>1.2 存储转发与地址学习</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11361099/a014666e-92c5-11e5-88b6-7aad7ff694f0.png" alt="l2 switch"></p><p><strong>存储转发</strong>：转发时，常用的方式为存储转发方式（store forward），即数据帧先入<strong>存储队列</strong>再根据<strong>转发表</strong>进行转发。使用存储转发，一来可以为多种速率端口的数据进行缓冲，二来也可以将残损、CRC错误等异常帧进行丢弃。小科普：除了存储转发外，还有直通转发（cut through，只读到DA后就转发，无法处理冲突帧、CRC错帧）、碎片隔离（fragment free，读一个slot共64字节，无冲突再转发，无法处理CRC帧）。</p><p><strong>地址学习</strong>：在完成存储转发时，需要查询转发表，从而得知数据帧应该从哪个端口发出，因此，转发表存的就是目的MAC地址与端口的映射，转发表生成的过程就是地址学习。大致过程就是，来一个帧，读他的源MAC，然后把源MAC和接收的端口号存下来。这样，交换机就知道了，从X端口来过MAC地址为Y的数据，当下次Y需要转发时，就可以把他转发到X端口了。从而，完成“从哪来去回哪去”的任务</p><h3 id="1-3-广播风暴"><a href="#1-3-广播风暴" class="headerlink" title="1.3 广播风暴"></a>1.3 广播风暴</h3><p>在几个交换机构成环时，会产生广播风暴，造成广播风暴的根本原因是交换机之间不能感知到互相的存在，导致地址学习时，一个交换将某个MAC的转发端口学习成了另一个交换机的端口。可以通过STP协议进行抑制，从逻辑上“断开”环。</p><h3 id="1-4-VLAN"><a href="#1-4-VLAN" class="headerlink" title="1.4 VLAN"></a>1.4 VLAN</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11356544/b0e3196c-9299-11e5-9bac-105198e8c31f.png" alt="vlan change"></p><p>VLAN可以将广播域分隔为多个逻辑网段。从帧格式上来看，增加了VLAN相关的域，VLAN相关域包括0x8100标志位，然后3bit的优先级，1bit的丢帧优先级，12bit的VLANID。在做转发学习时，通过SA+VLAN来学习转发端口。值得注意的是：当某个DA+VLAN查不到表时，仅在VLAN域广播。</p><p>换一种思想来看，可以认为VLAN是一种网络的虚拟化，将一个端口虚拟化成多个端口。</p><h2 id="2-三层路由"><a href="#2-三层路由" class="headerlink" title="2. 三层路由"></a>2. 三层路由</h2><p>路由的主要功能是根据目的IP转发到相应的网络中。和二层中的转发表类似，三层路由也存在一个类似的表，叫做路由表。</p><p>也就是说如果一个LAN希望连接另一个LAN，那么需要借助路由完成。另外，在大型的LAN中，由于连接设备多，导致MAC多，导致广播负担大，因此切分子网来避免这一问题，而子网之间所属不同LAN所以也需要借助路由完成通信。</p><p><img src="https://cloud.githubusercontent.com/assets/1736354/11361093/8aff2fac-92c5-11e5-851b-d7aa866c73cf.png" alt="router"></p><p>在进行路由的时候，路由首先根据<strong>最长匹配原则</strong>在路由表中查找下一跳IP地址，之后，根据ARP表，获取下一跳的MAC信息，便进入ARP流程，最后，根据下一跳MAC地址生成以太网数据帧，并将该数据帧从接口转发至网络。</p><p>路由与三层交换有类似的地方，L3交换虽具有路由功能，但其核心功能主要在于数据交换上，而路由仅具有路由转发功能。</p><h3 id="2-1-NAT"><a href="#2-1-NAT" class="headerlink" title="2.1 NAT"></a>2.1 NAT</h3><p>Network Adress Translator，网络地址转换。<br><img src="https://cloud.githubusercontent.com/assets/1736354/11362678/3f059748-92d0-11e5-8c13-2dec089260e3.png" alt="nat"></p><p>对于源地址NAT，主要用于内网访问外网，源地址进行转换；<br>对于目的地址NAT，一般用于外网访问内网，目的地址进行转换。</p><h2 id="3-Linux网络"><a href="#3-Linux网络" class="headerlink" title="3. Linux网络"></a>3. Linux网络</h2><p>由于目前大部分云计算服务器、网络设备都是运行在Linux上的，因此，学习一些和Linux网络底层相关的实现，有助于我们理解。如<a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="noopener">Linux 上的基础网络设备详解</a>一文中所述：</p><blockquote><p>Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，既通用的 Linux 网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。</p></blockquote><p>另外，对于Linux网络中的数据流在<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/kernel_flow" target="_blank" rel="noopener">kernel  flow</a>中有所描述，文中更有一张<a href="http://www.linuxfoundation.org/images/1/1c/Network_data_flow_through_kernel.png" target="_blank" rel="noopener">神图</a>。</p><h3 id="3-1-网络驱动"><a href="#3-1-网络驱动" class="headerlink" title="3.1 网络驱动"></a>3.1 网络驱动</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11388055/783c4f74-936c-11e5-800f-ca51da63f23d.png" alt="linux driver"></p><p>之前，有做过网络驱动，其实回想起来，核心的实现就2个：发送函数和接收函数。</p><p><strong>1. 发送函数（回调）</strong></p><p>核心功能是将上层网络传来的帧，写入到网卡中；</p><p>在网络驱动初始化时，会通过注册的方式对网络驱动进行初始化，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">netdev_ops</span> = &#123;</span></span><br><span class="line">    .ndo_open         = driver_open,</span><br><span class="line">    .ndo_stop         = driver_close,</span><br><span class="line">    .ndo_start_xmit   = driver_xmit,</span><br><span class="line">    .ndo_get_stats    = get_stats,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当上层有帧传来时，就会回调driver_xmit函数，因此，在driver_xmit函数中，就应当实现将帧写入到硬件，一般硬件会提供插入帧的接口，完成插入时帧会进入网卡硬件的插入队列中。</p><p><strong>2. 接收函数（中断）</strong><br>核心功能是将网卡中的帧，传送到上层协议栈中。</p><p>对于接收函数，则需要依靠硬件的中断，数据帧到达网卡，硬件以中断的方式告知系统，然后，接收函数回调，回调时，需通过硬件的接口读取数据帧，然后将其上传值上层接口。一般调用<code>netif_rx()</code>进行传输。</p><h3 id="3-2-Linux-Bridge"><a href="#3-2-Linux-Bridge" class="headerlink" title="3.2 Linux Bridge"></a>3.2 Linux Bridge</h3><p>Linux Bridge名释其意，像一个桥梁一样把网络设备桥接起来。Linux bridge是802.1D的实现，可以参考<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge" target="_blank" rel="noopener">链接</a>。</p><p><img src="https://cloud.githubusercontent.com/assets/1736354/11388062/8bd8b0b8-936c-11e5-86db-ac0d3db82f25.png" alt="linux bridge"></p><p>如上图所示是eth0和eth1加入到br0后的实现，可以看出，网桥向上屏蔽了桥下的网卡设备，从上层协议上来看，仅能看到网桥设备br0。</p><p>在<a href="http://book.douban.com/subject/1475839/" target="_blank" rel="noopener">《Understanding Linux Network Internals》</a>一书中，分析了Linux Bridge的实现：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11390343/3db29684-9384-11e5-9fb6-8791d5a56535.png" alt="linux br"></p><p>在br中有个链表来链net_device，每个net_device也反向链着br。在br中有个hash结构叫做fdb_entry，存储着转发表（forward databse），若某个MAC地址在fdb中，那么就直接发到某个net_device，如果没在的话，就广播给链接到该br的所有设备。</p><h3 id="3-3-Linux-VLAN"><a href="#3-3-Linux-VLAN" class="headerlink" title="3.3 Linux VLAN"></a>3.3 Linux VLAN</h3><p>交换与隔离是VLAN的两大功能，现实世界中的802.1q交换机存在多个VLAN，每个VLAN拥有多个端口，同一VLAN的端口可数据交换，不同VLAN的端口之间隔离。而Linux VLAN实现的是隔离，需要交换的话，需要在Linux Bridge上attach一个VLAN。即Linux Bridge加VLAN device能在功能层面完整模拟现实世界里的802.1.q交换机。</p><p>在<a href="http://www.kernelchina.org/node/214" target="_blank" rel="noopener">关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考</a>一文中，举了个例子，觉得很不错，画了个图加深理解：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11397203/a6d78704-93b2-11e5-92dc-dfbd9ae07365.png" alt="br vlan"></p><blockquote><p>一个盒子有6个物理interface, eth0,eth1,eth2,eth3,eth4,eth5,eth6.<br>bridge0 { eth0, eth1, eth2 }, vlan id 是2<br>bridge1 { eth3, eth4, eth5 }, vlan id 是3<br>eth0,eth1,eth2,eth3,eth4,eth5都在混杂模式，并且没有ip地址，它们是bridge的port.<br>创建vlan interface, bridge0.2, bridge1.3。在bridge0.2和bridge1.3上配置ip地址。vlan 2的机器，把bridge0.2的地址设置为缺省网关；vlan 3的机器，把bridge1.3设置为缺省网关。当有包要从vlan 2发往vlan 3是，它将送到bridge0.2，然后，通过路由，找到bridge1.3，然后由bridge1.3发出去。这个过程中，packet里面的vlan id会发生改变。这个例子里面，要求从bridge port上收到的包都必须是打tag的，在bridge里面，并不能识别和处理tag，只有到三层的vlan interface才能识别并处理这些tag.</p></blockquote><p>另外，Linux VLAN则是802.1Q的实现，可以参考<a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="noopener">链接</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://book.douban.com/subject/26333234/" target="_blank" rel="noopener">《云计算网络珠玑》</a><br><a href="http://book.douban.com/subject/25919428/" target="_blank" rel="noopener">《 图解网络硬件》</a><br><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/kernel_flow" target="_blank" rel="noopener">kernel  flow</a><br><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge" target="_blank" rel="noopener">linux bridge</a><br><a href="http://book.douban.com/subject/1475839/" target="_blank" rel="noopener">《Understanding Linux Network Internals》</a><br><a href="http://www.kernelchina.org/node/214" target="_blank" rel="noopener">关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考</a><br><a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="noopener">802.1Q VLAN implementation for Linux</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yikun.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[译]Threading model</title>
    <link href="http://yikun.github.io/2015/11/19/%E8%AF%91-Threading-model/"/>
    <id>http://yikun.github.io/2015/11/19/译-Threading-model/</id>
    <published>2015-11-19T13:34:04.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Threading-model"><a href="#Threading-model" class="headerlink" title="Threading model"></a>Threading model</h1><blockquote><p>All OpenStack services use green thread model of threading, implemented through using the Python eventlet and greenlet libraries.</p><p>Green threads use a cooperative model of threading: thread context switches can only occur when specific eventlet or greenlet library calls are made (e.g., sleep, certain I/O calls). From the operating system’s point of view, each OpenStack service runs in a single thread.</p><p>The use of green threads reduces the likelihood of race conditions, but does not completely eliminate them. In some cases, you may need to use the @lockutils.synchronized(…) decorator to avoid races.</p><p>In addition, since there is only one operating system thread, a call that blocks that main thread will block the entire process.</p></blockquote><p>理解：OpenStack的所有服务都使用Green thread，使用eventlet和greenlet库，绿色线程使用协作并发模型，线程的切换只在eventlet或greenlet库调用一些切换时发生。从操作系统角度上来看，每个OpenStack运行在一个单一线程。用Green Thread的好处是能够减少race conditions，当然有些时候我们也必须使用@lockutils.synchronized(…)来完全避免。因为只用一个系统级别的单线程，所以调用一旦阻塞就会阻塞整个进程。</p><p>关于Python中的并发模型，可以参考<a href="http://www.oschina.net/translate/python-concurrency-model" target="_blank" rel="noopener">Python并发模型</a>一文，把Thread（线程切换耗资源）、MicroThread（依靠解释器调度）、Green thread（协作并发）的特点对比了下。</p><p>还有<a href="http://www.cnblogs.com/sevenyuan/archive/2010/12/08/1900386.html" target="_blank" rel="noopener">Python几种并发实现方案的性能比较</a>将Python中的集中并发方案进行了对比和说明。</p><h2 id="Yielding-the-thread-in-long-running-tasks"><a href="#Yielding-the-thread-in-long-running-tasks" class="headerlink" title="Yielding the thread in long-running tasks"></a>Yielding the thread in long-running tasks</h2><blockquote><p>If a code path takes a long time to execute and does not contain any methods that trigger an eventlet context switch, the long-running thread will block any pending threads.</p><p>This scenario can be avoided by adding calls to the eventlet sleep method in the long-running code path. The sleep call will trigger a context switch if there are pending threads, and using an argument of 0 will avoid introducing delays in the case that there is only a single green thread:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eventlet <span class="keyword">import</span> greenthread</span><br><span class="line">...</span><br><span class="line">greenthread.sleep(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>理解：对于那些耗时很长的任务，需要我们添加一些yield方法，来避免在单个的调用中阻塞很久。</p><h2 id="MySQL-access-and-eventlet"><a href="#MySQL-access-and-eventlet" class="headerlink" title="MySQL access and eventlet"></a>MySQL access and eventlet</h2><blockquote><p>Queries to the MySQL database will block the main thread of a service. This is because OpenStack services use an external C library for accessing the MySQL database. Since eventlet cannot use monkey-patching to intercept blocking calls in a C library, the resulting database query blocks the thread.</p><p>The Diablo release contained a thread-pooling implementation that did not block, but this implementation resulted in a bug and was removed.</p></blockquote><p>理解：对于MySQL数据的查询会阻塞服务，因为eventlet对C库的调用是无法去做monkey-patching的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Threading-model&quot;&gt;&lt;a href=&quot;#Threading-model&quot; class=&quot;headerlink&quot; title=&quot;Threading model&quot;&gt;&lt;/a&gt;Threading model&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;All O
      
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[译]Host Aggregates</title>
    <link href="http://yikun.github.io/2015/10/17/%E8%AF%91-Host-Aggregates/"/>
    <id>http://yikun.github.io/2015/10/17/译-Host-Aggregates/</id>
    <published>2015-10-17T03:15:40.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>先上一个自己画的图，非常有助于理解Host Aggregates:<br><img src="https://cloud.githubusercontent.com/assets/1736354/10556767/3a9f3156-74c0-11e5-94f2-1b8befff9aff.png" alt="host aggregates"></p><a id="more"></a><h1 id="Host-Aggregates"><a href="#Host-Aggregates" class="headerlink" title="Host Aggregates"></a>Host Aggregates</h1><blockquote><p>Host aggregates can be regarded as a mechanism to further partition an availability zone; while availability zones are visible to users, host aggregates are only visible to administrators. Host aggregates started out as a way to use Xen hypervisor resource pools, but has been generalized to provide a mechanism to allow administrators to assign key-value pairs to groups of machines. Each node can have multiple aggregates, each aggregate can have multiple key-value pairs, and the same key-value pair can be assigned to multiple aggregate. This information can be used in the scheduler to enable advanced scheduling, to set up xen hypervisor resources pools or to define logical groups for migration.</p></blockquote><p>理解：Host Aggregates可以视为是AZ(Avaliability Zone)的更进一步的划分，是对管理员可见的。每一个节点都可以属于多个Aggregates，这些Aggregates可以用作更高级的调度、配置Xen的资源池、或者定义用于升级的逻辑分组。可以理解为aggregate是一组具有相同属性主机的分组。</p><h2 id="Availability-Zones-AZs"><a href="#Availability-Zones-AZs" class="headerlink" title="Availability Zones (AZs)"></a>Availability Zones (AZs)</h2><blockquote><p>Availability Zones are the end-user visible logical abstraction for partitioning a cloud without knowing the physical infrastructure. That abstraction doesn’t come up in Nova with an actual database model since the availability zone is actually a specific metadata information attached to an aggregate. Adding that specific metadata to an aggregate makes the aggregate visible from an end-user perspective and consequently allows to schedule upon a specific set of hosts (the ones belonging to the aggregate).</p><p>That said, there are a few rules to know that diverge from an API perspective between aggregates and availability zones:</p><ul><li>one host can be in multiple aggregates, but it can only be in one availability zone</li><li>by default a host is part of a default availability zone even if it doesn’t belong to an aggregate (the configuration option is named default_availability_zone)</li></ul></blockquote><p>理解：Availability Zones可以理解为将一个aggregate加了一些metadata信息，使得对用户可见。他和Aggregate最主要的区别是，一个节点只能属于一个AZ，默认一个主机属于一个默认的AZ。</p><h2 id="Xen-Pool-Host-Aggregates"><a href="#Xen-Pool-Host-Aggregates" class="headerlink" title="Xen Pool Host Aggregates"></a>Xen Pool Host Aggregates</h2><blockquote><p>Originally all aggregates were Xen resource pools, now an aggregate can be set up as a resource pool by giving the aggregate the correct key-value pair.</p><p>You can use aggregates for XenServer resource pools when you have multiple compute nodes installed (only XenServer/XCP via xenapi driver is currently supported), and you want to leverage the capabilities of the underlying hypervisor resource pools. For example, you want to enable VM live migration (i.e. VM migration within the pool) or enable host maintenance with zero-downtime for guest instances. Please, note that VM migration across pools (i.e. storage migration) is not yet supported in XenServer/XCP, but will be added when available. Bear in mind that the two migration techniques are not mutually exclusive and can be used in combination for a higher level of flexibility in your cloud management.</p></blockquote><p>理解：可以将Xen的划分到一个Aggregate，来支持Xen资源池的一些特性。</p><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><blockquote><p>The OSAPI Admin API is extended to support the following operations:</p><ul><li>Aggregates</li></ul><p>list aggregates: returns a list of all the host-aggregates (optionally filtered by availability zone)<br>create aggregate: creates an aggregate, takes a friendly name, etc. returns an id<br>show aggregate: shows the details of an aggregate (id, name, availability_zone, hosts and metadata)<br>update aggregate: updates the name and availability zone of an aggregate<br>set metadata: sets the metadata on an aggregate to the values supplied<br>delete aggregate: deletes an aggregate, it fails if the aggregate is not empty<br>add host: adds a host to the aggregate<br>remove host: removes a host from the aggregate</p><ul><li>Hosts</li></ul><p>start host maintenance (or evacuate-host): disallow a host to serve API requests and migrate instances to other hosts of the aggregate<br>stop host maintenance: (or rebalance-host): put the host back into operational mode, migrating instances back onto that host</p></blockquote><p>理解：对于Aggregate操作有：列出、创建、显示信息、更新、设置metadaa、删除、添加主机、移除主机。对于host的操作有：开启维护主机、停止维护主机。</p><p>参考资料：<br><a href="http://www.cnblogs.com/xingyun/p/4703325.html" target="_blank" rel="noopener">openstack中region、az、host aggregate、cell 概念</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先上一个自己画的图，非常有助于理解Host Aggregates:&lt;br&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/10556767/3a9f3156-74c0-11e5-94f2-1b8befff9aff.png&quot; alt=&quot;host aggregates&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[译]Scope of the Nova project</title>
    <link href="http://yikun.github.io/2015/10/16/%E8%AF%91-Scope-of-the-Nova-project/"/>
    <id>http://yikun.github.io/2015/10/16/译-Scope-of-the-Nova-project/</id>
    <published>2015-10-16T12:02:54.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scope-of-the-Nova-project"><a href="#Scope-of-the-Nova-project" class="headerlink" title="Scope of the Nova project"></a>Scope of the Nova project</h1><blockquote><p>Nova is focusing on doing an awesome job of its core mission. This document aims to clarify that core mission.</p><p>This is a living document to help record where we agree about what Nova should and should not be doing, and why. Please treat this as a discussion of interesting, and hopefully useful, examples. It is not intended to be an exhaustive policy statement.</p></blockquote><p>理解：文档的主要内容是，理清Nova的核心使命。</p><a id="more"></a><h2 id="Misson"><a href="#Misson" class="headerlink" title="Misson"></a>Misson</h2><blockquote><p>Our mission statement starts with:<br>To implement services and associated libraries to provide massively scalable, on demand, self service access to compute resources.</p><p>Our official mission statement also includes the following examples of compute resources: bare metal, virtual machines, and containers. For the full official mission statement see: <a href="http://governance.openstack.org/reference/projects/nova.html#mission" target="_blank" rel="noopener">http://governance.openstack.org/reference/projects/nova.html#mission</a></p><p>This document aims to help clarify what the mission statement means.</p></blockquote><p>理解：Nova的核心任务是：实现大规模可扩展地、按需地、自助地访问计算资源的服务和相关库。</p><h3 id="Compute-Resource"><a href="#Compute-Resource" class="headerlink" title="Compute Resource"></a>Compute Resource</h3><blockquote><p>Nova is all about access to compute resources. This section looks at the types of compute resource Nova works with.</p></blockquote><p>理解：Nova的一切都是和访问计算资源相关的。这节讲讲Nova主要能够在哪些计算资源上工作。</p><h3 id="Virtual-Servers"><a href="#Virtual-Servers" class="headerlink" title="Virtual Servers"></a>Virtual Servers</h3><blockquote><p>Nova was originally focused purely on providing access to virtual servers running on a variety of different hypervisors. The majority of users use Nova only to provide access to virtual servers from a single hypervisor, however, its possible to have a Nova deployment include multiple different types of hypervisors, while at the same time offering containers and bare metal servers.</p></blockquote><p>理解：Nova支持在不同hypervisor的虚拟服务器的访问，同时，也支持容器和裸金属服务器</p><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><blockquote><p>The Nova API is not a good fit for a lot of container use cases. The Magnum project intends to deliver a good container experience built on top of Nova.</p><p>Nova allows you to use containers in a similar way to how you would use on demand virtual machines. We want to maintain this distinction, so we maintain the integrity and usefulness of the existing Nova API.</p><p>For example, Nova is not designed to spin up new containers for every apache request, nor do we plan to control what goes on inside containers. They get the same metadata provided to them as virtual machines, to do with as they see fit.</p></blockquote><p>理解：</p><ul><li>Magnum项目用来统一容器访问接口。</li><li>Nova API提供统一的抽象层：用同样的方式去按需使用容器。<h3 id="Bare-Metal-Servers"><a href="#Bare-Metal-Servers" class="headerlink" title="Bare Metal Servers"></a>Bare Metal Servers</h3></li></ul><blockquote><p>Ironic project has been pioneering the idea of treating physical machines in a similar way to on demand virtual machines.</p><p>Nova’s driver is able to allow a multi-tenant cloud style use of Ironic controlled resources.</p><p>While currently there are operations that are a fundamental part of our virtual machine abstraction that are not currently available in ironic, such as attaching iSCSI volumes, it does not fundamentally change the semantics of our API, and as such is a suitable Nova driver. Moreover, it is expected that gap with shrink over time.</p></blockquote><p>理解：Ironic项目项目用来统一不同物理机器的访问接口。</p><h3 id="Driver-Parity"><a href="#Driver-Parity" class="headerlink" title="Driver Parity"></a>Driver Parity</h3><blockquote><p>Our goal for the Nova API to provide a consistent abstraction to access on demand compute resources. We are not aiming to expose all features of all hypervisors. Where the details of the underlying hypervisor leak through our APIs, we have failed in this goal, and we must work towards better abstractions that are more interoperable. This is one reason why we put so much emphasis on the use of Tempest in third party CI systems.</p><p>The key tenant of driver parity is that if a feature is supported in a driver, it must feel the same to users, as if they where using any of the other drivers that also support that feature. The exception is that, if possible for widely different performance characteristics, but the effect of that API call must be identical.</p><p>Following on from that, should a feature only be added to one of the drivers, we must make every effort to ensure another driver could be implemented to match that behavior.</p><p>Its important that drivers support enough features, so the API actually provides a consistent abstraction. For example, being unable to create a server or delete a server, would severely undermine that goal. In fact, Nova only ever manages resources it creates.</p></blockquote><p>理解：</p><ul><li>Nova API的目标是提供一个一致的抽象来访问那些按需提供的计算资源。</li><li>支持一个驱动就要支持其他驱动，允许性能有差异<h2 id="Upgrades"><a href="#Upgrades" class="headerlink" title="Upgrades"></a>Upgrades</h2></li></ul><blockquote><p>Nova is widely used in production. As such we need to respect the needs of our existing users. At the same time we need evolve the current code base, including both adding and removing features.</p><p>This section outlines how we expect people to upgrade, and what we do to help existing users that upgrade in the way we expect.</p></blockquote><p>理解：升级权衡兼容性和新功能增删</p><h3 id="Upgrade-expectations"><a href="#Upgrade-expectations" class="headerlink" title="Upgrade expectations"></a>Upgrade expectations</h3><blockquote><p>Our upgrade plan is to concentrate on upgrades from N-1 to the Nth release. So for someone running juno, they would have to upgrade to kilo before upgrading to liberty. This is designed to balance the need for a smooth upgrade, against having to keep maintaining the compatibility code to make that upgrade possible. We talk about this approach as users consuming the stable branch.</p><p>In addition, we also support users upgrading from the master branch. Technically, between any two between any two commits within the same release cycle. In certain cases, when crossing release boundaries, you must upgrade to the stable branch, before then upgrading to the tip of master. This is to support those that are doing some level of “Continuous Deployment” from the tip of master into production. Many of the public cloud provides running OpenStack use this approach so they are able to get access to bug fixes and features they work on into production sooner.</p><p>This becomes important when you consider reverting a commit that turns out to have been bad idea. We have to assume any public API change may have already been deployed into production, and as such cannot be reverted. In a similar way, a database migration may have been deployed.</p><p>Any commit that will affect an upgrade gets the UpgradeImpact tag added to the commit message, so there is no requirement to wait for release notes.</p></blockquote><p>理解：</p><ul><li>OpenStack的升级只支持N-1到N版本，主要考虑，一是平滑升级，二是节省时间。</li><li>支持master版本升级，保证bug和功能快速生效</li><li>同一版本，两个commit之间可以升；跨越版本，就得先升stable。</li><li>不能回退</li><li>影响升级需要打<code>UpgradeImpack</code>的标签<h3 id="Don’t-break-existing-users"><a href="#Don’t-break-existing-users" class="headerlink" title="Don’t break existing users"></a>Don’t break existing users</h3></li></ul><p>As a community we are aiming towards a smooth upgrade process, where users must be unaware you have just upgraded your deployment, except that there might be additional feature available and improved stability and performance of some existing features.</p><p>We don’t ever want to remove features our users rely on. Sometimes we need to migrate users to a new implementation of that feature, which may require extra steps by the deployer, but the end users must be unaffected by such changes. However there are times when some features become a problem to maintain, and fall into disrepair. We aim to be honest with our users and highlight the issues we have, so we are in a position to find help to fix that situation. Ideally we are able to rework the feature so it can be maintained, but in some rare cases, the feature no longer works, is not tested, and no one is stepping forward to maintain that feature, the best option can be to remove that feature.</p><p>When we remove features, we need warn users by first marking those features as deprecated, before we finally remove the feature. The idea is to get feedback on how important the feature is to our user base. Where a feature is important we work with the whole community to find a path forward for those users.</p><p>理解：</p><ul><li>不要干扰到已有用户的使用</li><li>如果一些功能，实在不能工作，而且确实没人维护了，就删掉它</li><li>删功能的时候，先deprecated，然后最终删除<h2 id="API-Scope"><a href="#API-Scope" class="headerlink" title="API Scope"></a>API Scope</h2></li></ul><blockquote><p>Nova aims to provide a highly interoperable and stable REST API for our users to get self-service access to compute resources.</p></blockquote><p>理解：Nova提供一个可操作性强、稳定的REST API</p><h3 id="No-more-API-Proxies"><a href="#No-more-API-Proxies" class="headerlink" title="No more API Proxies"></a>No more API Proxies</h3><blockquote><p>Nova API current has some APIs that are now (in kilo) mostly just a proxy to other OpenStack services. If it were possible to remove a public API, these are some we might start with. As such, we don’t want to add any more.</p><p>The first example is the API that is a proxy to the Glance v1 API. As Glance moves to deprecate its v1 API, we need to translate calls from the old v1 API we expose, to Glance’s v2 API.</p><p>The next API to mention is the networking APIs, in particular the security groups API. If you are using nova-network, Nova is still the only way to perform these network operations. But if you use Neutron, security groups has a much richer Neutron API, and if you use both Nova API and Neutron API, the miss match can lead to some very unexpected results, in certain cases.</p><p>Our intention is to avoid adding to the problems we already have in this area.</p></blockquote><p>理解：目前Nova API中有一些API只是其他服务的代理，以后不会再添加类似的代理服务了。</p><h3 id="No-more-Orchestration"><a href="#No-more-Orchestration" class="headerlink" title="No more Orchestration"></a>No more Orchestration</h3><blockquote><p>Nova is a low level infrastructure API. It is plumbing upon which richer ideas can be built. Heat and Magnum being great examples of that.</p><p>While we have some APIs that could be considered orchestration, and we must continue to maintain those, we do not intend to add any more APIs that do orchestration.</p></blockquote><p>理解：Nova是一个低层次基础设施的API，不会有过多的编排的内容。</p><h3 id="Third-Party-APIs"><a href="#Third-Party-APIs" class="headerlink" title="Third Party APIs"></a>Third Party APIs</h3><blockquote><p>Nova aims to focus on making a great API that is highly interoperable across all Nova deployments.</p><p>We have historically done a very poor job of implementing and maintaining compatibility with third party APIs inside the Nova tree.</p><p>As such, all new efforts should instead focus on external projects that provide third party compatibility on top of the Nova API. Where needed, we will work this those projects to extending the Nova API such that its possible to add that functionality on top of the Nova API. However, we do not intend to add API calls for those services to persist third party API specific information in the Nova database. Instead we want to focus on additions that enhance the existing Nova API.</p></blockquote><p>理解：Nova正在重视第三方API，尤其重视可以提高现有API的第三方API。</p><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>Our mission includes the text “massively scalable”. Lets discuss what that means.</p><p>Nova has three main axises of scale: Number of API requests, number of compute nodes and number of active instances. In many cases the number of compute nodes and active instances are so closely related, you rarely need to consider those separately. There are other items, such at the number of tenants, and the number of instances per tenant. But, again, these are very rarely the key scale issue. Its possible to have a small cloud with lots of requests for very short lived VMs, or a large cloud with lots of longer lived VMs. These need to scale out different components of the Nova system to reach their required level of scale.</p><p>Ideally all Nova components are either scaled out to match the number of API requests and build requests, or scaled out to match the number of running servers. If we create components that have their load increased relative to both of these items, we can run into inefficiencies or resource contention. Although it is possible to make that work in some cases, this should always be considered.</p><p>We intend Nova to be usable for both small and massive deployments. Where small involves 1-10 hypervisors and massive deployments are single regions with greater than 10,000 hypervisors. That should be seen as our current goal not an upper limit.</p><p>There are some features that would not scale well for either the small scale or the very large scale. Ideally we would not accept these features, but if there is a strong case to add such features, we must work hard to ensure you can run without that feature at the scale you are required to run.</p><p>理解：</p><ul><li>可扩展性在Nova中非常看重，Nova系统要适用小规模和大规模的部署。</li><li>对于Nova的扩展包括：API请求数的扩展或者服务器运行数量，或者两者均有</li><li>目前需求（比如大于10000的hypervisor）是目前的目标，但不是上限</li><li>新增功能要考虑可扩展性<h2 id="IaaS-not-Batch-Processing"><a href="#IaaS-not-Batch-Processing" class="headerlink" title="IaaS not Batch Processing"></a>IaaS not Batch Processing</h2></li></ul><blockquote><p>Currently Nova focuses on providing on-demand compute resources in the style of classic Infrastructure-as-a-service clouds. A large pool of compute resources that people can consume in a self-service way.</p><p>Nova is not currently optimized for dealing with a larger number of requests for compute resources compared with the amount of compute resource thats currently available. We generally assume a level of spare capacity is maintained for future requests. This is needed for users that want to quickly scale out, and extra capacity becomes available again as users scale in. While spare capacity is also not required, we are not optimizing for a system that aims to run at 100% capacity at all times. As such our quota system is more focused on limiting the current level of resource usage, rather than ensuring a fair balance of resources between all incoming requests. This doesn’t exclude adding features to support making a better use of spare capacity, such as “spot instances”.</p><p>There have been discussions around how to change Nova to work better for batch job processing. But the current focus is on how to layer such an abstraction on top of the basic primitives Nova currently provides, possibly adding additional APIs where that makes good sense. Should this turn out to be impractical, we may have to revise our approach.</p></blockquote><p>理解：Nova重视现有水平的资源利用，目前比较重视作为Iaas的API。</p><h2 id="Deployment-and-Packaging"><a href="#Deployment-and-Packaging" class="headerlink" title="Deployment and Packaging"></a>Deployment and Packaging</h2><blockquote><p>Nova does not plan on creating its own packaging or deployment systems.</p><p>Our CI infrastructure is powered by Devstack. This can also be used by developers to test their work on a full deployment of Nova.</p><p>We do not develop any deployment or packaging for production deployments. Being widely adopted by many distributions and commercial products, we instead choose to work with all those parties to ensure they are able to effectively package and deploy Nova.</p></blockquote><p>理解：</p><ul><li>无计划创建独立的打包和部署</li><li>用Devstack持续集成</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Scope-of-the-Nova-project&quot;&gt;&lt;a href=&quot;#Scope-of-the-Nova-project&quot; class=&quot;headerlink&quot; title=&quot;Scope of the Nova project&quot;&gt;&lt;/a&gt;Scope of the Nova project&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Nova is focusing on doing an awesome job of its core mission. This document aims to clarify that core mission.&lt;/p&gt;
&lt;p&gt;This is a living document to help record where we agree about what Nova should and should not be doing, and why. Please treat this as a discussion of interesting, and hopefully useful, examples. It is not intended to be an exhaustive policy statement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解：文档的主要内容是，理清Nova的核心使命。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>[译]Nova System Architecture</title>
    <link href="http://yikun.github.io/2015/10/15/%E8%AF%91-Nova-System-Architecture/"/>
    <id>http://yikun.github.io/2015/10/15/译-Nova-System-Architecture/</id>
    <published>2015-10-15T02:04:44.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nova系统架构"><a href="#Nova系统架构" class="headerlink" title="Nova系统架构"></a>Nova系统架构</h3><blockquote><p>Nova is built on a <strong>shared-nothing</strong>, <strong>messaging-based</strong> architecture. All of the major nova components can be run on <strong>multiple servers</strong>. This means that most component to component communication must go via <strong>message queue</strong>. In order to <strong>avoid blocking</strong> each component while waiting for a response, we use <strong>deferred objects</strong>, with a <strong>callback</strong> that gets triggered when a response is received.</p></blockquote><p>Nova建立在一个无共享，基于消息的架构。所有的nova主要组件都可以运行在不同的服务器。这就意味着大多数组件之间的通信必须通过消息队列。为了避免每个组件在等待响应时的阻塞，我们是用deferred对象，当一个响应接收时会触发相应的回调。</p><a id="more"></a><blockquote><p>Nova recently moved to using a sql-based central database that is shared by all components in the system. The amount and depth of the data fits into a sql database quite well. For small deployments this seems like an optimal solution. For larger deployments, and especially if security is a concern, nova will be moving towards multiple data stores with some kind of aggregation system.</p></blockquote><p>Nova最近正在迁移到一个基于SQL的中心数据库，系统中所有组件都共享一个数据库。大量的深度的数据非常适合存放在SQL数据库中。对于小型部署，这是一个最佳方案。对于大型部署，特别是非常看重安全的话，nova也将会进一步搬到不同集成系统中的多种数据库。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>下面将看到两种不同的架构：<br><img src="https://cloud.githubusercontent.com/assets/1736354/10502572/14066a24-7320-11e5-9552-e230cd8fa5cb.png" alt="qq20151015-0 2x"></p><p><img src="https://cloud.githubusercontent.com/assets/1736354/10502582/2c4de97c-7320-11e5-9b33-2defabd49a7d.png" alt="qq20151015-1 2x"></p><ul><li>DB: 基于SQL的数据存储</li><li>API: 组件接收HTTP请求，可以通过osl.messaging和HTTP来转换指令和通信</li><li>Scheduler: 决定哪个host获得某个instance</li><li>Network: 管理IP转发、网桥、vlans</li><li>Compute: 管理hypervisor和virtual machines的通信</li><li>Conductor: 处理需要调整(build/resize)的请求，作为数据库代理，或者处理对象的转换</li></ul><blockquote><p>While all services are designed to be <strong>horizontally scalable</strong>, you should have significantly more computes then anything else.</p></blockquote><p>由于所有的服务都被设计为横向扩展的，你只需要更多的计算机就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Nova系统架构&quot;&gt;&lt;a href=&quot;#Nova系统架构&quot; class=&quot;headerlink&quot; title=&quot;Nova系统架构&quot;&gt;&lt;/a&gt;Nova系统架构&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Nova is built on a &lt;strong&gt;shared-nothing&lt;/strong&gt;, &lt;strong&gt;messaging-based&lt;/strong&gt; architecture. All of the major nova components can be run on &lt;strong&gt;multiple servers&lt;/strong&gt;. This means that most component to component communication must go via &lt;strong&gt;message queue&lt;/strong&gt;. In order to &lt;strong&gt;avoid blocking&lt;/strong&gt; each component while waiting for a response, we use &lt;strong&gt;deferred objects&lt;/strong&gt;, with a &lt;strong&gt;callback&lt;/strong&gt; that gets triggered when a response is received.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nova建立在一个无共享，基于消息的架构。所有的nova主要组件都可以运行在不同的服务器。这就意味着大多数组件之间的通信必须通过消息队列。为了避免每个组件在等待响应时的阻塞，我们是用deferred对象，当一个响应接收时会触发相应的回调。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>读《OpenStack设计与实现》</title>
    <link href="http://yikun.github.io/2015/10/08/%E8%AF%BB%E3%80%8AOpenStack%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    <id>http://yikun.github.io/2015/10/08/读《OpenStack设计与实现》/</id>
    <published>2015-10-08T13:52:35.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初始OpenStack和开发基础"><a href="#初始OpenStack和开发基础" class="headerlink" title="初始OpenStack和开发基础"></a>初始OpenStack和开发基础</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10370055/daf455b2-6e0f-11e5-98c3-d3e17ee7d97d.PNG" alt="openstack_ch1ch2"></p><p>OpenStack起于RakeSpace和NASA的合作，相关知识涉及到了云计算和虚拟化，体系结构上来看OpenStack是处于Iaas层，目前来看，还是处于追随AWS的阶段。OpenStack的子项目从新项目、孵化项目最终发展成为核心及集成项目。</p><a id="more"></a><p>作者比较文艺，对于文档的重要性是这么描述的：</p><blockquote><p>每一个项目，每一个模块，甚至每一行代码都有着自己的故事，这些故事都应该被留存在自己的历史档案里，而我们大部分的时间都只是他们的过客而已。</p></blockquote><p>另外，还有一个重要的东西就是Code Review，核心思想：</p><blockquote><p>一旦一个问题被充分地描述了他的细节，那么解决方法也是显而易见的。</p></blockquote><p>OpenStack的代码质量保证体系大概就是以下几点：</p><ul><li>编码规范：编码规范遵循着PEP-8，使用Flake8进行代码静态检测；</li><li>代码评审：使用Gerrit进行代码评审，保证所有代码都Code Review后才能Merge；</li><li>单元测试：位于tests目录，使用tox执行；</li><li>持续集成：使用Jenkins来做自动化测试，测试例则用Tempest框架</li></ul><p>其实，整个过程还是比较清晰的，现在只是大致了解一下过程，后面真正开发的时候亲身体验一下再深入理解。最后，又介绍了一些关于贡献代码、文档、Review之类的一些说明，其中，Feature的贡献，需要先在Blueprint提出来一些想法和设计，然后通过后再在spec里详细描述一些细节。</p><p>对于阅读代码，也给了一个基本的思路，因为代码的脉络比较复杂，所以推荐先阅读setup.cfg，然后从entry point入手，逐个功能、服务去突破。OpenStack牵扯到的背景知识，主要有Python、Linux、网络基础、虚拟化、Git，除了虚拟化外，其他掌握的还行。所以，后面多看看虚拟化方面的内容。</p><h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10417118/0f341a10-7063-11e5-8e1d-63e13f5eadb4.png" alt="default"></p><p>对于OpenStack来说，虚拟化相关内容是非常核心的内容，自然本书的第三章独立出来介绍虚拟化的知识。<br>虚拟化的按照实现方式来说，主要分为Hypervisior模型和Hosted模型。</p><ul><li>Hypervisior模型，VMM直接运行在硬件平台上，控制所有硬件并管理客户操作系统。操作系统运行在VMM之上；</li><li>Hosted模型，VMM则是在操作系统之上，就想是操作系统的一个软件层。</li></ul><p>按照平台类型来说，则大致分为完全虚拟化和类虚拟化。</p><ul><li>完全虚拟化，最初是使用二进制翻译实现的，后期硬件支持后，也可以通过硬件辅助支持；</li><li>类虚拟化，通过修改系统内核来实现，通用性较差。<br>虚拟化包括了CPU虚拟化、内存虚拟化、I/O虚拟化、网络虚拟化，引入虚拟化后主要的特性为：动态迁移、快照、克隆，这些新特性对于目前对需要长时间稳定运行的系统来说，有非常重要的意义。</li></ul><p>对于虚拟化相关知识，有参考了一些其他资料：<br><a href="http://book.douban.com/subject/19986436/" target="_blank" rel="noopener">《虚拟化技术原理与实现》</a><br><a href="http://book.douban.com/subject/3619896/" target="_blank" rel="noopener">《系统虚拟化原理与实现》</a><br><a href="http://www.vmware.com/files/pdf/VMware_paravirtualization.pdf" target="_blank" rel="noopener">Understanding Full Virtualization, Paravirtualization, and Hardware Assist</a>(<a href="http://blog.csdn.net/flyforfreedom2008/article/details/45113635" target="_blank" rel="noopener">翻译</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初始OpenStack和开发基础&quot;&gt;&lt;a href=&quot;#初始OpenStack和开发基础&quot; class=&quot;headerlink&quot; title=&quot;初始OpenStack和开发基础&quot;&gt;&lt;/a&gt;初始OpenStack和开发基础&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/10370055/daf455b2-6e0f-11e5-98c3-d3e17ee7d97d.PNG&quot; alt=&quot;openstack_ch1ch2&quot;&gt;&lt;/p&gt;
&lt;p&gt;OpenStack起于RakeSpace和NASA的合作，相关知识涉及到了云计算和虚拟化，体系结构上来看OpenStack是处于Iaas层，目前来看，还是处于追随AWS的阶段。OpenStack的子项目从新项目、孵化项目最终发展成为核心及集成项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack概览</title>
    <link href="http://yikun.github.io/2015/10/04/OpenStack%E6%A6%82%E8%A7%88/"/>
    <id>http://yikun.github.io/2015/10/04/OpenStack概览/</id>
    <published>2015-10-04T11:33:16.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10267380/3f2d8b74-6ac4-11e5-9372-6bc21c57f11f.png" alt="openstack-software-diagram"></p><blockquote><p>OpenStack is a <strong>cloud operating system</strong> that controls large pools of <strong>compute</strong>, <strong>storage</strong>, and <strong>networking</strong> resources throughout a datacenter, all managed through a <strong>dashboard</strong> that gives administrators control while empowering their users to provision resources through a web interface.</p></blockquote><a id="more"></a><p>正如OpenStack官方定义的那样，OpenStack是一个云操作系统，他管理这大量的计算、存储、网络资源，也提供了一个dashborad让管理员通过Web接口方便的管理资源。目前的版本已经是K版了，在看了<a href="https://www.youtube.com/v/y39CAXJAW3M" target="_blank" rel="noopener">OpenStack Kilo Overview Demo</a>的视频后，对OpenStack有了最初的了解。</p><h3 id="2-核心功能"><a href="#2-核心功能" class="headerlink" title="2. 核心功能"></a>2. 核心功能</h3><p><strong>Compute</strong></p><blockquote><p><strong>Provision and manage large networks of virtual machines.</strong></p><p>The OpenStack cloud operating system enables enterprises and service providers to <strong>offer on-demand computing resources</strong>, by provisioning and managing large networks of virtual machines. Compute resources are accessible via <strong>APIs</strong> for developers building cloud applications and via <strong>web interfaces</strong> for administrators and users. The compute architecture is designed to <strong>scale horizontally</strong> on standard hardware, enabling the cloud economics companies have come to expect.</p></blockquote><p>几个关键信息：按需提供计算资源、提供API给开发者、提供Web接口给用户、横向扩展。然后又专门介绍了OpenStack的灵活的架构，它支持各种不同的硬件，比如普通的计算机可以，高性能计算机也可以；也支持不同的软件，比如支持各种不同的虚拟化技术，比如KVM、XEN、LXC等等。</p><p><strong>Storage</strong></p><blockquote><p>Object and block storage for use with servers and applications.</p><p>In addition to traditional enterprise-class storage technology, many organizations now have a variety of storage needs with varying performance and price requirements. OpenStack has support for both <strong>Object Storage</strong> and <strong>Block Storage</strong>, with many deployment options for each depending on the use case. </p><p>Object Storage is ideal for <strong>cost effective, scale-out</strong> storage. It provides a fully distributed, API-accessible storage platform that can be integrated directly into applications or used for backup, archiving and data retention. Block Storage allows block devices to be exposed and connected to compute instances for <strong>expanded storage, better performance and integration</strong> with enterprise storage platforms, such as NetApp, Nexenta and SolidFire.</p></blockquote><p>几个关键信息，提供了对象存储和块存储，对象存储有高效的成本，横向扩展性，块存储则为了更好的扩容、更好的性能以及和企业其他存储平台的集成。</p><p><strong>Network</strong></p><blockquote><p>Pluggable, scalable, API-driven network and ip management.</p><p>Today’s datacenter networks contain more devices than ever before servers, network equipment, storage systems and security appliances — many of which are further divided into virtual machines and virtual networks. The number of IP addresses, routing configurations and security rules can quickly grow into the millions. Traditional network management techniques fall short of providing a <strong>truly scalable, automated approach to managing these next-generation networks</strong>. At the same time, <strong>users expect more control and flexibility with quicker provisioning</strong>.</p><p>OpenStack Networking is a <strong>pluggable</strong>, <strong>scalable</strong> and <strong>API-driven</strong> system for managing networks and IP addresses. Like other aspects of the cloud operating system, it can be used by administrators and users to increase the value of existing datacenter assets. OpenStack Networking ensures the network will not be the bottleneck or limiting factor in a cloud deployment and gives users real self service, even over their network configurations.</p></blockquote><p>关键信息：现今数据中心的设备越来越多，配置也非常多，需要一个可扩展、自动化的管理下一代网络，同时用户也希望仅通过快速配置，掌控更多，更灵活。所以就有OpenStack Networking了，一个用于管理网络和IP的可插拔、可扩展、API驱动的系统。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.openstack.org/software/" target="_blank" rel="noopener">OpenStack官方介绍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概览&quot;&gt;&lt;a href=&quot;#1-概览&quot; class=&quot;headerlink&quot; title=&quot;1. 概览&quot;&gt;&lt;/a&gt;1. 概览&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/10267380/3f2d8b74-6ac4-11e5-9372-6bc21c57f11f.png&quot; alt=&quot;openstack-software-diagram&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OpenStack is a &lt;strong&gt;cloud operating system&lt;/strong&gt; that controls large pools of &lt;strong&gt;compute&lt;/strong&gt;, &lt;strong&gt;storage&lt;/strong&gt;, and &lt;strong&gt;networking&lt;/strong&gt; resources throughout a datacenter, all managed through a &lt;strong&gt;dashboard&lt;/strong&gt; that gives administrators control while empowering their users to provision resources through a web interface.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>再见，北京</title>
    <link href="http://yikun.github.io/2015/06/18/%E5%86%8D%E8%A7%81%EF%BC%8C%E5%8C%97%E4%BA%AC/"/>
    <id>http://yikun.github.io/2015/06/18/再见，北京/</id>
    <published>2015-06-18T08:10:00.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在北大"><a href="#在北大" class="headerlink" title="在北大"></a>在北大</h2><p>一年多的时间，基本都在中国第一学府——北京大学。这里有未名湖畔的波光粼粼，也有博雅塔下的春风垂柳；有艺园吃腻很久的炒菜米饭，也有小白房冒菜不限量的芝麻酱和鳕鱼培根夹馍；有农园清淡爽口的菜肴和炸酱面，也有畅春园改善伙食的麻辣香锅。总之一切都还美好，只是有老校医院实验室中永远调不完的bug后，其他的一切又稍显黯淡。</p><a id="more"></a><p><img src="https://cloud.githubusercontent.com/assets/1736354/8226649/080762dc-15d3-11e5-84da-82fbe052541f.jpg" alt="img_20150407_144120"></p><h2 id="在古迹"><a href="#在古迹" class="headerlink" title="在古迹"></a>在古迹</h2><p>周末的闲暇时光，也会去各个古迹去探索一番，从长城的一砖一瓦中，猜得出北京千年的文化的底蕴；故宫里的金瓦红墙，看得到旧朝的兴盛衰亡；圆明园的断壁残垣，见证着过往苍白的历史。这些古迹除了斑驳的历史以外，还有一个共同点，那就是人多。有时候想想也会觉得惊讶，北京的各个景点在任何的时候都充斥着络绎不绝的游客。</p><p>静静地坐落在京西的古刹龙泉寺，却又是以另一种沉静展现出新的世界。听说，行走在寺中的任何一个僧人都可能清华北大拿到全奖留美offer的才俊，也有人戏称这里是清华北大的分校。 一叶一菩提，一沙一世界，在这新的世界里，真的会让人有种沉寂身心，潜学求知的心境。</p><p>￼<img src="https://cloud.githubusercontent.com/assets/1736354/8226648/08050492-15d3-11e5-9393-3a723df17352.jpg" alt="img_20150406_121939"></p><h2 id="在四季"><a href="#在四季" class="headerlink" title="在四季"></a>在四季</h2><p>一直觉得，来到一个城市，只有见过了她的四季才算来过。当我真真切切地感受到北京的春夏秋冬后，这座城的全部已经烙入我的心中：春天凌乱纷飞的迷乱柳絮，夏日说来就来的疯狂暴雨，秋季萧瑟苍凉的香山红叶，冬夜刺骨冻人的凛冽大风。当你在这时，她分明的四季演绎出这座城池的精彩，当你不在时，她同样会把更精彩的四季展示给其他千千万万的北漂人。</p><h2 id="在苏州街"><a href="#在苏州街" class="headerlink" title="在苏州街"></a>在苏州街</h2><p>最开始的几个月，住在苏州街，这个有几分诗意的名字，却和她的忙碌一点儿也不相符。每天早上，看着疾步似飞的北漂人在梦想路上暴走。从酒店到北大的路也是分外的熟悉。晴好的夜晚，也会在中关村这片跑个几公里。相信明朝的太监们怎么也想不到，如今他们的故里已经成为中国IT的中心。中关村的环形天桥矗立在密密麻麻的互联网公司之上，下面也永远是车水马龙。行人满脸匆忙地在桥上穿梭，好像整个世界都按了快进。当你夜晚静静的驻足桥上，零星的装点竟然有种豪华的感觉。看着底下走走停停的车辆，别有一番说不出的滋味。</p><p>￼<img src="https://cloud.githubusercontent.com/assets/1736354/8226647/07ef1f6a-15d3-11e5-951b-47a5ea96913d.jpg" alt="img_20150425_230259"></p><h2 id="在“漂”"><a href="#在“漂”" class="headerlink" title="在“漂”"></a>在“漂”</h2><p>转眼间已经在北京待了一年时间，渐渐地体会到了“漂”的内涵。不是在风中飘摇的飘，而是在水上漂泊的漂，而北京浑厚丰富地资源就像浩瀚无边的海洋。这座古韵十足而深藏活力的城池，永远都在这里等待着成千上万的创业者，成功失败都在这里发生。有的时候，你需要在让人喘不过气的雾霾中，奋力的挣扎去呼吸，去成长，当然了，让人喘不过气的东西也不仅仅是雾霾。北京承载了太多人的期望，或为生计，或为梦想。他们在这里，生根发芽，这里有太多太多的竞争者，也有太多太多的机会。</p><h2 id="再见"><a href="#再见" class="headerlink" title="再见"></a>再见</h2><p>晚上，就要离开北京了，那么：再见，北京！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在北大&quot;&gt;&lt;a href=&quot;#在北大&quot; class=&quot;headerlink&quot; title=&quot;在北大&quot;&gt;&lt;/a&gt;在北大&lt;/h2&gt;&lt;p&gt;一年多的时间，基本都在中国第一学府——北京大学。这里有未名湖畔的波光粼粼，也有博雅塔下的春风垂柳；有艺园吃腻很久的炒菜米饭，也有小白房冒菜不限量的芝麻酱和鳕鱼培根夹馍；有农园清淡爽口的菜肴和炸酱面，也有畅春园改善伙食的麻辣香锅。总之一切都还美好，只是有老校医院实验室中永远调不完的bug后，其他的一切又稍显黯淡。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的网络数据包工具——Packet Assistant</title>
    <link href="http://yikun.github.io/2015/06/15/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Packet-Assistant/"/>
    <id>http://yikun.github.io/2015/06/15/一个简单的网络数据包工具——Packet-Assistant/</id>
    <published>2015-06-15T11:11:00.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-起因"><a href="#1-起因" class="headerlink" title="1. 起因"></a>1. 起因</h3><p>最近一段时间，总是有一些<strong>发数据包、抓数据包</strong>之类的需求，主要是需要定制以太网MAC层的源MAC地址、目的MAC地址、协议类型之类的东西。</p><p>之前实现这些都是用Winpcap实现的，然后用某基础类库去实现界面，实在是受不了“某基础类库”庞大冗余的结构了。这时，看到了PyQt，整个人一下清爽起来。所以，Packet Assistant就诞生了。</p><p>总而言之，言而总之：</p><blockquote><p>Packet Assistant是一个简单的发包、抓包工具。</p></blockquote><a id="more"></a><h3 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2. 依赖"></a>2. 依赖</h3><ul><li><a href="http://www.riverbankcomputing.com/software/pyqt/download" target="_blank" rel="noopener">PyQt 4</a></li></ul><p>Python底下其实有很多的GUI库，比如<a href="http://www.zhihu.com/question/27159913" target="_blank" rel="noopener">这里</a>提到的一些，因为之前对C++的Qt比较熟，所以，比较能够理解Qt的设计思想，用PyQt的时候，也觉得还好，和原生Qt没什么差，主要是考虑了需要一个类似Qt Designer的东西快速搭界面。所以就选了PyQt了。</p><ul><li><a href="https://github.com/CoreSecurity/pcapy/wiki/Compiling-Pcapy-on-Windows-Guide" target="_blank" rel="noopener">Pcapy</a></li></ul><p>Python网络抓包的库，Winpcap官网的<a href="https://www.winpcap.org/misc/links.htm" target="_blank" rel="noopener">友情链接</a>提到了这个库，比起<a href="https://github.com/dugsong/pypcap" target="_blank" rel="noopener">PyPcap</a>，Pcapy的例子、支持感觉更好些。</p><h3 id="3-截图"><a href="#3-截图" class="headerlink" title="3. 截图"></a>3. 截图</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/8158460/d367be9a-138f-11e5-84ae-346611f8aa59.png" alt="packetassist"></p><h3 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h3><p>Enjoy it! :+1: </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-起因&quot;&gt;&lt;a href=&quot;#1-起因&quot; class=&quot;headerlink&quot; title=&quot;1. 起因&quot;&gt;&lt;/a&gt;1. 起因&lt;/h3&gt;&lt;p&gt;最近一段时间，总是有一些&lt;strong&gt;发数据包、抓数据包&lt;/strong&gt;之类的需求，主要是需要定制以太网MAC层的源MAC地址、目的MAC地址、协议类型之类的东西。&lt;/p&gt;
&lt;p&gt;之前实现这些都是用Winpcap实现的，然后用某基础类库去实现界面，实在是受不了“某基础类库”庞大冗余的结构了。这时，看到了PyQt，整个人一下清爽起来。所以，Packet Assistant就诞生了。&lt;/p&gt;
&lt;p&gt;总而言之，言而总之：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Packet Assistant是一个简单的发包、抓包工具。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
      <category term="网络" scheme="http://yikun.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC核心源码学习</title>
    <link href="http://yikun.github.io/2015/05/28/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yikun.github.io/2015/05/28/Spring-IOC核心源码学习/</id>
    <published>2015-05-28T16:34:39.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p>大致单步跟了下Spring IOC的初始化过程，整个脉络很庞大，初始化的过程主要就是<strong>读取XML资源，并解析，最终注册到Bean Factory中</strong>：</p><p><img src="https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png" alt="flow"></p><a id="more"></a><p>在完成初始化的过程后，Bean们就在BeanFactory中蓄势以待地等调用了。下面通过一个具体的例子，来详细地学习一下初始化过程，例如当加载下面一个bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"XiaoWang"</span> <span class="attr">class</span>=<span class="string">"com.springstudy.talentshow.SuperInstrumentalist"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instruments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"piano"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"saxophone"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加载时需要读取、解析、注册bean，这个过程具体的调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7896285/8a488060-06e6-11e5-9ad9-4ddd3375984f.png" alt="load"></p><p>下面对每一步的关键的代码进行详细分析：</p><h4 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h4><p><strong>保存配置位置，并刷新</strong><br>在调用ClassPathXmlApplicationContext后，先会将配置位置信息保存到configLocations，供后面解析使用，之后，会调用<code>AbstractApplicationContext</code>的refresh方法进行刷新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, </span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 保存位置信息，比如`com/springstudy/talentshow/talent-show.xml`</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建载入BeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建XMLBeanDefinitionReader</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-读取"><a href="#1-2-读取" class="headerlink" title="1.2 读取"></a>1.2 读取</h4><p><strong>创建处理每一个resource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// 通过Location来读取Resource</span></span><br><span class="line">    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">    <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="comment">// 载入每一个resource</span></span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理XML每个元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                <span class="comment">// 处理每个xml中的元素，可能是import、alias、bean</span></span><br><span class="line">                parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解析和注册bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册</span></span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(</span><br><span class="line">                bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本步骤中，通过<code>parseBeanDefinitionElement</code>将XML的元素解析为<code>BeanDefinition</code>，然后存在<code>BeanDefinitionHolder</code>中，然后再利用<code>BeanDefinitionHolder</code>将<code>BeanDefinition</code>注册，实质就是把<code>BeanDefinition</code>的实例put进<code>BeanFactory</code>中，和后面将详细的介绍解析和注册过程。</p><h4 id="1-3-解析"><a href="#1-3-解析" class="headerlink" title="1.3 解析"></a>1.3 解析</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/7896302/eae02bc6-06e6-11e5-941a-d1f59e3b363f.png" alt="process"></p><p><strong>处理每个Bean的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// 创建beandefinition</span></span><br><span class="line">    AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">    parseMetaElements(ele, bd);</span><br><span class="line">    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 处理“Constructor”</span></span><br><span class="line">    parseConstructorArgElements(ele, bd);</span><br><span class="line">    <span class="comment">// 处理“Preperty”</span></span><br><span class="line">    parsePropertyElements(ele, bd);</span><br><span class="line">    parseQualifierElements(ele, bd);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>处理属性的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;</span><br><span class="line">    String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">                    <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</span><br><span class="line">                    <span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">    <span class="comment">// 处理引用</span></span><br><span class="line">        String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">            error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">        ref.setSource(extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hasValueAttribute) &#123;</span><br><span class="line">    <span class="comment">// 处理值</span></span><br><span class="line">        TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">        valueHolder.setSource(extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> valueHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (subElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理子类型（比如list、map等）</span></span><br><span class="line">        <span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-注册"><a href="#1-4-注册" class="headerlink" title="1.4 注册"></a>1.4 注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将beanDefinition注册</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册过程中，最核心的一句就是：<code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>，也就是说注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap中。</p><h3 id="2-注入依赖"><a href="#2-注入依赖" class="headerlink" title="2. 注入依赖"></a>2. 注入依赖</h3><p>当完成初始化IOC容器后，如果bean没有设置lazy-init(延迟加载)属性，那么bean的实例就会在初始化IOC完成之后，及时地进行初始化。初始化时会先建立实例，然后根据配置利用反射对实例进行进一步操作，具体流程如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929429/615570ea-0930-11e5-8097-ae982ef7709d.png" alt="bean_flow"></p><p><strong>创建bean的实例</strong><br>创建bean的实例过程函数调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929379/cec01bcc-092f-11e5-81ad-88c285f33845.png" alt="create_bean"></p><p><strong>注入bean的属性</strong><br>注入bean的属性过程函数调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929381/db58350e-092f-11e5-82a4-caaf349291ea.png" alt="inject_property"></p><p>在创建bean和注入bean的属性时，都是在doCreateBean函数中进行的，我们重点看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建bean的实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化bean的实例，如注入属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了以上两个过程，我们就可以自己实现一个简单的Spring框架了。于是，我根据自己的理解实现了一个简单的IOC框架<a href="https://github.com/Yikun/simple-spring" target="_blank" rel="noopener">Simple Spring</a>，有兴趣可以看看。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-初始化&quot;&gt;&lt;a href=&quot;#1-初始化&quot; class=&quot;headerlink&quot; title=&quot;1. 初始化&quot;&gt;&lt;/a&gt;1. 初始化&lt;/h3&gt;&lt;p&gt;大致单步跟了下Spring IOC的初始化过程，整个脉络很庞大，初始化的过程主要就是&lt;strong&gt;读取XML资源，并解析，最终注册到Bean Factory中&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png&quot; alt=&quot;flow&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>学习awk和sed</title>
    <link href="http://yikun.github.io/2015/05/23/%E5%AD%A6%E4%B9%A0awk%E5%92%8Csed/"/>
    <id>http://yikun.github.io/2015/05/23/学习awk和sed/</id>
    <published>2015-05-23T16:52:31.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>最近把awk和sed又系统地学习了下，使用<a href="http://naotu.baidu.com/" target="_blank" rel="noopener">百度脑图</a>简单地整理了一下大概的思路：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7785009/0d604ea2-01af-11e5-8fdc-b658a02e76bc.png" alt="awk sed"></p><p>参考资料<br><a href="http://book.douban.com/subject/1236944/" target="_blank" rel="noopener">《sed与awk》</a><br><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="noopener">sed 简明教程</a><br><a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="noopener">awk 简明教程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近把awk和sed又系统地学习了下，使用&lt;a href=&quot;http://naotu.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度脑图&lt;/a&gt;简单地整理了一下大概的思路：&lt;br&gt;&lt;img src=&quot;https://cloud.g
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>利用Shell进行Web日志分析</title>
    <link href="http://yikun.github.io/2015/05/20/%E5%88%A9%E7%94%A8Shell%E8%BF%9B%E8%A1%8CWeb%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>http://yikun.github.io/2015/05/20/利用Shell进行Web日志分析/</id>
    <published>2015-05-20T16:24:48.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Web日志"><a href="#1-Web日志" class="headerlink" title="1.Web日志"></a>1.Web日志</h4><p>Web日志由Web服务器产生，比如Nginx、Apache等。例如一条Nginx的日志格式可能是这样的：</p><blockquote><p>222.68.172.190 - - [18/Sep/2013:06:49:57 +0000] “GET /images/my.jpg HTTP/1.1” 200 19939<br> “<a href="http://www.angularjs.cn/A00n&quot;" target="_blank" rel="noopener">http://www.angularjs.cn/A00n&quot;</a> “Mozilla/5.0 (Windows NT 6.1)<br> AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36”</p></blockquote><p>可以拆解为以下8个变量</p><blockquote><p>remote_addr: 记录客户端的ip地址, 222.68.172.190<br>remote_user: 记录客户端用户名称, –<br>time_local: 记录访问时间与时区, [18/Sep/2013:06:49:57 +0000]<br>request: 记录请求的url与http协议, “GET /images/my.jpg HTTP/1.1″<br>status: 记录请求状态,成功是200, 200<br>body_bytes_sent: 记录发送给客户端文件主体内容大小, 19939<br>http_referer: 用来记录从那个页面链接访问过来的, “<a href="http://www.angularjs.cn/A00n”" target="_blank" rel="noopener">http://www.angularjs.cn/A00n”</a><br>http_user_agent: 记录客户浏览器的相关信息, “Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36″</p></blockquote><h4 id="提取最近10分钟的日志："><a href="#提取最近10分钟的日志：" class="headerlink" title="提取最近10分钟的日志："></a>提取最近10分钟的日志：</h4><p>思路一：利用awk提取时间，并做字符串比较</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在OSX环境下，需要安装coreutils保证`date`等指令正常使用</span></span><br><span class="line"><span class="comment"># brew install coreutils</span></span><br><span class="line">tac <span class="built_in">log</span> | </span><br><span class="line">awk <span class="string">'BEGIN&#123;</span></span><br><span class="line"><span class="string">    # 获取时间至min10</span></span><br><span class="line"><span class="string">    "date -d \"-10 minute\" +\"%H:%M:%S\"" | getline min10 </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    # 日志时间和当前时间比较</span></span><br><span class="line"><span class="string">    if (substr($4,14) &gt; min10) </span></span><br><span class="line"><span class="string">        print ;</span></span><br><span class="line"><span class="string">    # 若一次不匹配则退出</span></span><br><span class="line"><span class="string">    else </span></span><br><span class="line"><span class="string">        exit;</span></span><br><span class="line"><span class="string">&#125;'</span> |</span><br><span class="line">tac</span><br></pre></td></tr></table></figure><p>思路二：利用grep的正则匹配，捕获满足条件的时刻</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | grep -E <span class="string">"19/Sep/2013:06:2[4-9]|19/Sep/2013:06:3[0-3]"</span></span><br></pre></td></tr></table></figure><p>思路三：使用sed的地址(时刻必须出现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | sed -n <span class="string">'/19\/Sep\/2013:06:24/,//19\/Sep\/2013:06:33/p'</span></span><br></pre></td></tr></table></figure><h4 id="统计某个接口-xxxapi-访问量和QPS"><a href="#统计某个接口-xxxapi-访问量和QPS" class="headerlink" title="统计某个接口(xxxapi)访问量和QPS"></a>统计某个接口(xxxapi)访问量和QPS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat log | grep xxxapi | wc -l</span></span><br><span class="line">query=$(cat <span class="built_in">log</span> | grep -c xxxapi)</span><br><span class="line">t=60</span><br><span class="line">qps=$((query/<span class="variable">$time</span>))</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://blog.fens.me/hadoop-mapreduce-log-kpi/" target="_blank" rel="noopener">海量Web日志分析 用Hadoop提取KPI统计指标</a><br><a href="https://www.centos.bz/2012/11/shell-scrpit-auto-count-log/" target="_blank" rel="noopener">shell脚本每天自动统计网站访问日志</a><br><a href="http://www.oschina.net/question/42741_115440" target="_blank" rel="noopener">如何用Shell截取nginx最近10分钟的日志</a><br><a href="http://bbs.chinaunix.net/thread-4096403-1-1.html" target="_blank" rel="noopener">如何用awk从日志文件中找到时间范围的数据</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Web日志&quot;&gt;&lt;a href=&quot;#1-Web日志&quot; class=&quot;headerlink&quot; title=&quot;1.Web日志&quot;&gt;&lt;/a&gt;1.Web日志&lt;/h4&gt;&lt;p&gt;Web日志由Web服务器产生，比如Nginx、Apache等。例如一条Nginx的日志格式可能是这样
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>重新学习Shell</title>
    <link href="http://yikun.github.io/2015/05/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Shell/"/>
    <id>http://yikun.github.io/2015/05/19/重新学习Shell/</id>
    <published>2015-05-19T04:42:23.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<p>之前，虽然已经对<code>Shell</code>比较熟悉了，但是遇到一些不太常用，但是却很有用的命令，还得搜个半天。所以，这几天准备把常用的指令重新过一下，然后再把基础的<code>Shell</code>流程控制、<code>awk</code>的操作等常用命令系统地学习一下，一方面作为总结，另一方面也作为一个Cheat Sheet，时不时的补充一下也是极好的，: )。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>传参</strong><br><code>$n</code> - 传递的第n个参数<br><code>$#</code> - 传递的参数个数<br><code>$*</code> - 所有参数<br><code>$@</code> - 所有参数，加引号为字符串数组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># var.sh arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"></span><br><span class="line"><span class="comment"># @:arg1</span></span><br><span class="line"><span class="comment"># @:arg2</span></span><br><span class="line"><span class="comment"># @:arg3</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> @:<span class="string">"<span class="variable">$arg</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *:arg1 arg2 arg3</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> *:<span class="string">"<span class="variable">$arg</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>if条件控制</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a euqals b."</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -lt <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a little than b."</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> -gt <span class="variable">$b</span> ]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a greater than b."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">"linux"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$str</span>"</span> == <span class="string">"linux"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"str is linux."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ -e filename]    判断文件存在</span></span><br><span class="line"><span class="comment"># [ -d pathname] 判断目录存在</span></span><br></pre></td></tr></table></figure><p><strong>循环控制</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr=(<span class="string">"hello"</span> <span class="string">"bash"</span> <span class="string">"shell"</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="variable">$&#123;arr[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p><strong>_head/tail</strong>_</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前5行</span></span><br><span class="line">head -5</span><br><span class="line">head -n 5</span><br><span class="line"><span class="comment"># 前n-5行</span></span><br><span class="line">head -n -5</span><br><span class="line"><span class="comment"># 后n-5行</span></span><br><span class="line">tail -n +5</span><br><span class="line"><span class="comment"># 前5字节</span></span><br><span class="line">head -c 5</span><br></pre></td></tr></table></figure><p><strong>_sort</strong>_</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略起始空格(b)数值(n)去重(u)逆序(r)按照:分隔(-t ':')的第二列(-k 2)排序</span></span><br><span class="line">sort -bnur -t <span class="string">':'</span> -k 2 somefile</span><br></pre></td></tr></table></figure><p><strong>_grep</strong>_</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前文件夹的所有文件递归(-r)搜索main</span></span><br><span class="line">grep -r <span class="string">"main"</span> *</span><br><span class="line"><span class="comment"># 搜索匹配正则(-E)的行数(-c)，（带main或者括弧的）</span></span><br><span class="line">grep -cE <span class="string">"main|\(\)"</span> *</span><br><span class="line"><span class="comment"># 搜索不包含extern的(-v --&gt; invert-match)</span></span><br><span class="line">grep -v <span class="string">"extern"</span></span><br></pre></td></tr></table></figure><p><strong>_wc</strong>_</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有.c文件的行数</span></span><br><span class="line">grep -r <span class="string">""</span> *.c | wc -l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前，虽然已经对&lt;code&gt;Shell&lt;/code&gt;比较熟悉了，但是遇到一些不太常用，但是却很有用的命令，还得搜个半天。所以，这几天准备把常用的指令重新过一下，然后再把基础的&lt;code&gt;Shell&lt;/code&gt;流程控制、&lt;code&gt;awk&lt;/code&gt;的操作等常用命令系统地
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java CopyOnWriteArrayList工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/28/Java-CopyOnWriteArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/28/Java-CopyOnWriteArrayList工作原理及实现/</id>
    <published>2015-04-28T15:58:01.000Z</published>
    <updated>2021-08-02T03:29:56.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。</p><p>因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。</p><p>增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。&lt;/p&gt;
&lt;p&gt;因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git常用操作总结</title>
    <link href="http://yikun.github.io/2015/04/24/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yikun.github.io/2015/04/24/Git常用操作总结/</id>
    <published>2015-04-24T17:13:25.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<p>用Git比较久了，之前一直在Win用的TortoiseGit，现在命令行用的比较多，所以把一些指令总结一下，以便回顾和查询。</p><p>理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>git tracked的是修改，而不是文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将“当前修改”移动到暂存区(stage)</span><br><span class="line">$ git add somfile.txt</span><br><span class="line">#将暂存区修改提交</span><br><span class="line">$ git commit -m &quot;Add somfile.txt.&quot;</span><br></pre></td></tr></table></figure><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git diff</span><br></pre></td></tr></table></figure><h3 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 放弃工作区修改</span><br><span class="line">$ git checkout -- file.name</span><br><span class="line">$ git checkout -- .</span><br><span class="line"></span><br><span class="line"># 取消commit(比如需要重写commit信息)</span><br><span class="line">$ git reset --soft HEAD</span><br><span class="line"></span><br><span class="line"># 取消commit、add(重新提交代码和commit)</span><br><span class="line">$ git reset HEAD</span><br><span class="line">$ git reset --mixed HEAD</span><br><span class="line"></span><br><span class="line"># 取消commit、add、工作区修改(需要完全重置)</span><br><span class="line">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">$ git log</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm file.name</span><br><span class="line">$ git rm file.name</span><br><span class="line">$ git commit -m &quot;Del&quot;</span><br></pre></td></tr></table></figure><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:michaelliao/learngit.git</span><br><span class="line"># 第一次推送，-u(--set-upstream)指定默认上游</span><br><span class="line">$ git push -u origin master</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/Yikun/yikun.github.com.git path</span><br><span class="line">$ git clone git@github.com:Yikun/yikun.github.com.git path</span><br></pre></td></tr></table></figure><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 产看当前分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 创建分支</span><br><span class="line">$ git branch dev</span><br><span class="line"># 切换分支</span><br><span class="line">$ git checkout dev</span><br><span class="line"></span><br><span class="line"># 创建并checkout分支</span><br><span class="line">$ git checkout -b dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 合并分支</span><br><span class="line">$ git merge dev</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag 0.1.1</span><br><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><h3 id="同步上游"><a href="#同步上游" class="headerlink" title="同步上游"></a>同步上游</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 1. 添加上游</span><br><span class="line">git remote add upstream</span><br><span class="line">// 2. 切换需要同步的分支</span><br><span class="line">git checkout XXX</span><br><span class="line">// 3. 更新上游</span><br><span class="line">git remote update upstream</span><br><span class="line">git rebase upstream/&#123;branch name&#125;</span><br><span class="line">// 4. 解决冲突</span><br><span class="line">// 手动解决冲突</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue</span><br><span class="line">// 5. push</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用Git比较久了，之前一直在Win用的TortoiseGit，现在命令行用的比较多，所以把一些指令总结一下，以便回顾和查询。&lt;/p&gt;
&lt;p&gt;理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java EnumMap工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/23/Java-EnumMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/23/Java-EnumMap工作原理及实现/</id>
    <published>2015-04-23T16:11:56.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote><p>A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient.</p></blockquote><p>EnumMap是是一种键为枚举类型的特殊的Map实现。所有的Key也必须是一种枚举类型，EnumMap是使用数组来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Course, String&gt; map = <span class="keyword">new</span> EnumMap&lt;Course, String&gt;(Course<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">map.put(Course.ONE, <span class="string">"语文"</span>);</span><br><span class="line">map.put(Course.ONE, <span class="string">"政治"</span>);</span><br><span class="line">map.put(Course.TWO, <span class="string">"数学"</span>);</span><br><span class="line">map.put(Course.THREE, <span class="string">"英语"</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Course, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ONE: 政治</span><br><span class="line">TWO: 数学</span><br><span class="line">THREE: 英语</span><br></pre></td></tr></table></figure><p>其具体实现的结构如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7323140/1dc9a734-eadf-11e4-96f8-8df820f64590.png" alt="enummap"></p><h3 id="2-put和get方法"><a href="#2-put和get方法" class="headerlink" title="2. put和get方法"></a>2. put和get方法</h3><p>put方法通过key的ordinal将值存储到对应的地方，get方法则根据key的ordinal获取对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类型检查</span></span><br><span class="line">    typeCheck(key);</span><br><span class="line">    <span class="comment">// 获取key的序号</span></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="comment">// 若之前的值为空，则size++</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ?</span><br><span class="line">            unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3. 遍历"></a>3. 遍历</h3><p>EnumMapIterator的迭代这样实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; vals.length &amp;&amp; vals[index] == <span class="keyword">null</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">return</span> index != vals.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    lastReturnedEntry = <span class="keyword">new</span> Entry(index++);</span><br><span class="line">    <span class="keyword">return</span> lastReturnedEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过hasNext跳过空的数组，也就是说，保证了遍历顺序与Enum中key的先后顺序一致。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://javarevisited.blogspot.jp/2012/09/what-is-enummap-in-java-example-tutorial.html" target="_blank" rel="noopener">What is EnumMap in Java</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A specialized Map implementation for use with enu
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C语言中移位操作符优先级的坑</title>
    <link href="http://yikun.github.io/2015/04/18/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%9D%91/"/>
    <id>http://yikun.github.io/2015/04/18/C语言中移位操作符优先级的坑/</id>
    <published>2015-04-18T09:16:55.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<p>今天和tiancai交流他腾讯面试题目的时候，有这么一个题目，大致是这样描述的：</p><blockquote><p>有一个函数f，可以等概率产生0,1，写一个函数g，可以等概率地产生0~7中的数。</p></blockquote><p>于是，我写出了如下一个错误的解法：</p><blockquote><p>f()+f()&lt;&lt;1+f()&lt;&lt;2</p></blockquote><p>而正确的应该是：</p><blockquote><p>f() + (f()&lt;&lt;1) + (f()&lt;&lt;2)</p></blockquote><p>之前一直有误解，而实际情况是是<strong>移位操作符的优先级低于加减法的优先级</strong>。为了验证和加深记忆，又写了一个小测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1&lt;&lt;1+2&lt;&lt;1:     %d\n"</span>, <span class="number">1</span>&lt;&lt;<span class="number">1</span>+<span class="number">2</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1&lt;&lt;(1+2)&lt;&lt;1:   %d\n"</span>, <span class="number">1</span>&lt;&lt;(<span class="number">1</span>+<span class="number">2</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(1&lt;&lt;1)+(2&lt;&lt;1): %d\n"</span>, (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)+(<span class="number">2</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&lt;&lt;1+2&lt;&lt;1:     16</span><br><span class="line">1&lt;&lt;(1+2)&lt;&lt;1:   16</span><br><span class="line">(1&lt;&lt;1)+(2&lt;&lt;1): 6</span><br></pre></td></tr></table></figure><p>其中编译的时候，也有一个友情提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.c:4:36: warning: operator &apos;&lt;&lt;&apos; has lower precedence than &apos;+&apos;; &apos;+&apos; will be</span><br><span class="line">      evaluated first [-Wshift-op-parentheses]</span><br><span class="line">        printf(&quot;1&lt;&lt;1+2&lt;&lt;1:     %d\n&quot;, 1&lt;&lt;1+2&lt;&lt;1);</span><br><span class="line">                                       ~~~^~</span><br><span class="line">main.c:4:36: note: place parentheses around the &apos;+&apos; expression to silence this</span><br><span class="line">      warning</span><br><span class="line">        printf(&quot;1&lt;&lt;1+2&lt;&lt;1:     %d\n&quot;, 1&lt;&lt;1+2&lt;&lt;1);</span><br><span class="line">                                          ^</span><br><span class="line">                                         (  )</span><br><span class="line">1 warning generated.</span><br></pre></td></tr></table></figure><p>最后，</p><blockquote><p>希望自己永远保持一颗怀疑的心。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天和tiancai交流他腾讯面试题目的时候，有这么一个题目，大致是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个函数f，可以等概率产生0,1，写一个函数g，可以等概率地产生0~7中的数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，我写出了如下一个错误的
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayDeque工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/11/Java-ArrayDeque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/11/Java-ArrayDeque工作原理及实现/</id>
    <published>2015-04-11T10:50:32.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p>Resizable-array implementation of the <strong>Deque interface</strong>. Array deques have no capacity restrictions; they <strong>grow as necessary to support usage</strong>. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.</p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/1736354/7120880/13a5b9a4-e243-11e4-8a63-33c4852c268c.png" alt="arrayqueue"></p><blockquote><p>以循环数组实现的双向Queue。大小是2的倍数，默认是16。</p><p>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组<a href="如果此时队头下标大于0，说明队头弹出过元素，有空位">0</a>，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Resizable-array implementation of the &lt;strong&gt;D
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java TreeSet工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/10/Java-TreeSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/10/Java-TreeSet工作原理及实现/</id>
    <published>2015-04-10T09:05:12.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><blockquote><p>A NavigableSet implementation based on a <strong>TreeMap</strong>. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.This implementation provides guaranteed <strong>log(n)</strong> time cost for the basic operations (add, remove and contains).</p></blockquote><p>TreeSet是基于TreeMap实现的，也非常简单，同样的只是用key及其操作，然后把value置为dummy的object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; tset = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">tset.add(<span class="string">"1语文"</span>);</span><br><span class="line">tset.add(<span class="string">"3英语"</span>);</span><br><span class="line">tset.add(<span class="string">"2数学"</span>);</span><br><span class="line">tset.add(<span class="string">"4政治"</span>);</span><br><span class="line">tset.add(<span class="string">"5历史"</span>);</span><br><span class="line">tset.add(<span class="string">"6地理"</span>);</span><br><span class="line">tset.add(<span class="string">"7生物"</span>);</span><br><span class="line">tset.add(<span class="string">"8化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : tset) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其具体的结构是：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7085286/d0b1658c-dfa7-11e4-972c-d1d07e5fadfd.png" alt="treeset"></p><p>利用TreeMap的特性，实现了set的有序性(通过红黑树实现)。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" target="_blank" rel="noopener">TreeSet(Java Platform SE 8)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A NavigableSet implementation based on a &lt;strong&gt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java LinkedHashSet工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/09/Java-LinkedHashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/09/Java-LinkedHashSet工作原理及实现/</id>
    <published>2015-04-09T14:50:16.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p><strong>Hash table and linked list implementation of the Set interface</strong>, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.)</p></blockquote><p>LinkedHashSet是基于HashMap和双向链表的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; lset = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">lset.add(<span class="string">"语文"</span>);</span><br><span class="line">lset.add(<span class="string">"数学"</span>);</span><br><span class="line">lset.add(<span class="string">"英语"</span>);</span><br><span class="line">lset.add(<span class="string">"历史"</span>);</span><br><span class="line">lset.add(<span class="string">"政治"</span>);</span><br><span class="line">lset.add(<span class="string">"地理"</span>);</span><br><span class="line">lset.add(<span class="string">"生物"</span>);</span><br><span class="line">lset.add(<span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : lset) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用链表来记录，保证了迭代输出的有序性。其具体结构如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7082382/14d44b8e-df86-11e4-8e50-1e925f430b6e.png" alt="hashset"><br>可以看出，其实现基本和LinkedHashMap一样。</p><h3 id="2-关键实现"><a href="#2-关键实现" class="headerlink" title="2. 关键实现"></a>2. 关键实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>从继承关系来看就知道LinkedHashMap的实现非常简单，就是集成HashSet的接口，并且在构造时调用的是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，结构也便是如HashSet于HashMap一样，LinkedHashSet也便如LinkedHashMap一样，只是将Value做了一个dummy的object。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html" target="_blank" rel="noopener">LinkedHashSet</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hash table and linked list implementati
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java HashSet工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/08/Java-HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/08/Java-HashSet工作原理及实现/</id>
    <published>2015-04-08T15:31:28.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p>This class implements the Set interface, backed by a hash table (actually a <strong>HashMap</strong> instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.</p></blockquote><p>HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，我们先来感性的认识一下这个结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"语文"</span>);</span><br><span class="line">set.add(<span class="string">"数学"</span>);</span><br><span class="line">set.add(<span class="string">"英语"</span>);</span><br><span class="line">set.add(<span class="string">"历史"</span>);</span><br><span class="line">set.add(<span class="string">"政治"</span>);</span><br><span class="line">set.add(<span class="string">"地理"</span>);</span><br><span class="line">set.add(<span class="string">"生物"</span>);</span><br><span class="line">set.add(<span class="string">"化学"</span>);</span><br></pre></td></tr></table></figure><p>其大致的结构是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7060522/0bcfd890-deb5-11e4-97b3-d4e811766893.png" alt="hashset"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p><code>map</code>是整个HashSet的核心，而<code>PRESENT</code>则是用来造一个假的value来用的。</p><h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本操作也非常简单，就是调用HashMap的相关方法，其中value就是之前那个dummy的Object。所以，只要了解#7 HashMap的实现就可以了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="noopener">HashSet(Java Platform 8)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;This class implements the Set interface, backed
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java PriorityQueue工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/07/Java-PriorityQueue%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/07/Java-PriorityQueue工作原理及实现/</id>
    <published>2015-04-07T14:25:48.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.iteye.com/topic/1061958" target="_blank" rel="noopener">基于最小堆（小根堆）的topn算法</a><br><a href="http://my.oschina.net/leejun2005/blog/135085" target="_blank" rel="noopener">基于堆实现的优先级队列：PriorityQueue 解决 Top K 问题</a><br><a href="http://www.importnew.com/6932.html" target="_blank" rel="noopener">Java优先队列（PriorityQueue）示例</a><br><a href="http://wlh0706-163-com.iteye.com/blog/1850125" target="_blank" rel="noopener">JDK源码研究PriorityQueue（优先队列）</a><br><a href="http://cuisuqiang.iteye.com/blog/2019157" target="_blank" rel="noopener">优先级队列：PriorityQueue</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.iteye.com/topic/1061958&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java TreeMap工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/06/Java-TreeMap工作原理及实现/</id>
    <published>2015-04-06T15:10:15.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p>A <strong>Red-Black tree</strong> based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.<br>This implementation provides guaranteed <strong>log(n) time cost</strong> for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest’s Introduction to Algorithms.</p></blockquote><p>之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; tmap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">tmap.put(<span class="number">1</span>, <span class="string">"语文"</span>);</span><br><span class="line">tmap.put(<span class="number">3</span>, <span class="string">"英语"</span>);</span><br><span class="line">tmap.put(<span class="number">2</span>, <span class="string">"数学"</span>);</span><br><span class="line">tmap.put(<span class="number">4</span>, <span class="string">"政治"</span>);</span><br><span class="line">tmap.put(<span class="number">5</span>, <span class="string">"历史"</span>);</span><br><span class="line">tmap.put(<span class="number">6</span>, <span class="string">"地理"</span>);</span><br><span class="line">tmap.put(<span class="number">7</span>, <span class="string">"生物"</span>);</span><br><span class="line">tmap.put(<span class="number">8</span>, <span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大致的结构如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7041463/05ee676a-de0c-11e4-9412-4c6964931e43.png" alt="treemap"><br>使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考<a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="noopener">数据结构之红黑树</a>、<a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">wikipedia-红黑树</a>等的实现。</p><h3 id="2-put函数"><a href="#2-put函数" class="headerlink" title="2. put函数"></a>2. put函数</h3><blockquote><p>Associates the specified value with the specified key in this map.If the map previously contained a mapping for the key, the old value is replaced.</p></blockquote><p>如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">// 如果该节点存在，则替换值直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 如果该节点未存在，则新建</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">        <span class="comment">// 红黑树平衡调整</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-get函数"><a href="#3-get函数" class="headerlink" title="3. get函数"></a>3. get函数</h3><p>get函数则相对来说比较简单，以log(n)的复杂度进行get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="comment">// 按照二叉树搜索的方式进行搜索，搜到返回</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-successor后继"><a href="#4-successor后继" class="headerlink" title="4. successor后继"></a>4. successor后继</h3><p>TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2" target="_blank" rel="noopener">The enhanced for statement</a>，for语句会做如下转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123;</span><br><span class="line">    Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>it.next()</strong>的调用中会使用<strong>nextEntry</strong>调用<code>successor</code>这个是过的后继的重点，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 有右子树的节点，后继节点就是右子树的“最左节点”</span></span><br><span class="line">        <span class="comment">// 因为“最左子树”是右子树的最小节点</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点</span></span><br><span class="line">        <span class="comment">// 因为左子树找完了，根据LDR该D了</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 保证左子树</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下：</p><blockquote><p><strong>a. 空节点，没有后继</strong><br><strong>b. 有右子树的节点，后继就是右子树的“最左节点”</strong><br><strong>c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点</strong></p></blockquote><p>a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了！</p><p><strong>有右子树的节点</strong>，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是<strong>右子树的“最左节点”</strong>，就好像下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7045283/652d00c4-de2f-11e4-8475-1a2f46afc380.png" alt="treemap1"></p><p><strong>无右子树的节点</strong>，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。<br><img src="https://cloud.githubusercontent.com/assets/1736354/7045284/68279686-de2f-11e4-8310-c9f76b3f52ab.png" alt="treemap2"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener">TreeMap (Java Platform SE 8)</a><br><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">浅谈算法和数据结构: 九 平衡查找树之红黑树</a><br><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="noopener">Java提高篇（二七）—–TreeMap</a><br><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="noopener">数据结构之红黑树</a><br><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">wikipedia-红黑树</a><br><a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" target="_blank" rel="noopener">Red-Black Trees</a><br><a href="http://stackoverflow.com/questions/18063394/how-treemap-searches-successor-for-given-entry" target="_blank" rel="noopener">How TreeMap searches successor for given Entry?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;Red-Black tree&lt;/strong&gt; based Navigab
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java LinkedList工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/05/Java-LinkedList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/05/Java-LinkedList工作原理及实现/</id>
    <published>2015-04-05T14:19:28.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</p><p>按下标访问元素–get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。</p><p>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作–add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。</p></blockquote><p>LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。</p><blockquote><p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 1"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 2"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 3"</span>);</span><br></pre></td></tr></table></figure><p>结构也相对简单一些，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6997435/92fab224-dbed-11e4-932a-4c5593a2abb7.png" alt="linkedlist"></p><h3 id="2-set和get函数"><a href="#2-set和get函数" class="headerlink" title="2. set和get函数"></a>2. set和get函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数都调用了<code>node</code>函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener">LinkedList (Java Platform SE 8)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayList工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/04/Java-ArrayList工作原理及实现/</id>
    <published>2015-04-04T13:22:27.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">关于Java集合的小抄</a>中是这样描述的：</p><blockquote><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p><p>按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p><p>直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p></blockquote><p>然后再来学习一下官方文档：</p><blockquote><p><strong>Resizable-array</strong> implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p></blockquote><p>ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。<br>来看一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 99"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 98"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 100"</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在执行这四条语句时，是这么变化的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6993037/5d4ba306-db19-11e4-85fb-61b0154d0d96.png" alt="arraylist"><br>其中，<code>add</code>操作可以理解为直接将数组的内容置位，<code>remove</code>操作可以理解为删除index为0的节点，并将后面元素移到0处。</p><h3 id="2-add函数"><a href="#2-add函数" class="headerlink" title="2. add函数"></a>2. add函数</h3><p>当我们在ArrayList中增加元素的时候，会使用<code>add</code>函数。他会将元素放到末尾。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到他的实现其实最核心的内容就是<code>ensureCapacityInternal</code>。这个函数其实就是<strong>自动扩容机制的核心</strong>。我们依次来看一下他的具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩展为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩为1.5倍还不满足需求，直接扩为需求值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们<code>add</code>10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6993129/e892246e-db1c-11e4-9ae8-f9719688a1ca.png" alt="arraylistadd"></p><h3 id="3-set和get函数"><a href="#3-set和get函数" class="headerlink" title="3 set和get函数"></a>3 set和get函数</h3><p>Array的put和get函数就比较简单了，先做index检查，然后执行赋值或访问操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-remove函数"><a href="#4-remove函数" class="headerlink" title="4 remove函数"></a>4 remove函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 把后面的往前移</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把最后的置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释很清楚：</p><blockquote><p>Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#add-E-" target="_blank" rel="noopener">Class ArrayList</a><br><a href="http://www.cnblogs.com/dongying/p/4013271.html" target="_blank" rel="noopener">ArrayList其实就那么一回事儿之源码浅析</a><br><a href="http://my.oschina.net/tunie/blog/122530" target="_blank" rel="noopener">关于ArrayList</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://calvin1978.blogcn.com/articles/collection.ht
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何设计实现一个LRU Cache？</title>
    <link href="http://yikun.github.io/2015/04/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/"/>
    <id>http://yikun.github.io/2015/04/03/如何设计实现一个LRU-Cache？/</id>
    <published>2015-04-03T15:35:02.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是LRU-Cache？"><a href="#1-什么是LRU-Cache？" class="headerlink" title="1. 什么是LRU Cache？"></a>1. 什么是LRU Cache？</h3><p>之前，在LeetCode上看到一个LRU Cache实现的题目，题目描述是这样的：</p><blockquote><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <strong>get</strong> and <strong>set</strong>.<br><strong>get(key)</strong> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><strong>set(key, value)</strong> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p></blockquote><p>简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。</p><p>那么我们思考一个问题：如何设计实现一个LRU Cache？<br>那么，我们可能需要使用类似这样的数据结构去实现这个LRU Cache：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6984935/92033a96-da60-11e4-8754-66135bb0d233.png" alt="lru"><br>这不就是LinkedHashMap吗！<br>这样做的好处是，<code>get</code>和<code>set</code>在不冲突的情况下可以保证O(1)的复杂度，同时，也可以通过双向链表来保证LRU的<code>删除</code>和<code>更新</code>操作也能保证O(1)的复杂度。</p><h3 id="2-实现思路"><a href="#2-实现思路" class="headerlink" title="2.实现思路"></a>2.实现思路</h3><p>在学习了HashMap(#7 )和LinkedHashMap(#8 )后，是不是觉得这俩数据结构简直太适合做LRU Cache了！那么动手实现一下：<br><strong>基于HashMap和双向链表的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        Integer key;</span><br><span class="line">        Integer val;</span><br><span class="line"></span><br><span class="line">        Node(Integer k, Integer v) &#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    <span class="comment">// The head (eldest) of the doubly linked list.</span></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">// The tail (youngest) of the doubly linked list.</span></span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            n.pre.next = n.next;</span><br><span class="line">            n.next.pre = n.pre;</span><br><span class="line">            appendTail(n);</span><br><span class="line">            <span class="keyword">return</span> n.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="comment">// existed</span></span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            n.val = value;</span><br><span class="line">            map.put(key, n);</span><br><span class="line">            n.pre.next = n.next;</span><br><span class="line">            n.next.pre = n.pre;</span><br><span class="line">            appendTail(n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(map.size() == cap) &#123;</span><br><span class="line">            Node tmp = head.next;</span><br><span class="line">            head.next = head.next.next;</span><br><span class="line">            head.next.pre = head;</span><br><span class="line">            map.remove(tmp.key);</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="comment">// youngest node append taill</span></span><br><span class="line">        appendTail(n);</span><br><span class="line">        map.put(key, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        n.next = tail;</span><br><span class="line">        n.pre = tail.pre;</span><br><span class="line">        tail.pre.next = n;</span><br><span class="line">        tail.pre = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于LinkedHashMap的实现</strong><br>HashMap+双向链表？这不就是LinkedHashMap吗！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> java.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义put后的移除规则，大于容量就删除eldest</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是LRU-Cache？&quot;&gt;&lt;a href=&quot;#1-什么是LRU-Cache？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是LRU Cache？&quot;&gt;&lt;/a&gt;1. 什么是LRU Cache？&lt;/h3&gt;&lt;p&gt;之前，在LeetCode上看到一
      
    
    </summary>
    
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java LinkedHashMap工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/02/Java-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/02/Java-LinkedHashMap工作原理及实现/</id>
    <published>2015-04-02T15:01:37.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在理解了#7 介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</span><br><span class="line">lmap.put(<span class="string">"语文"</span>, <span class="number">1</span>);</span><br><span class="line">lmap.put(<span class="string">"数学"</span>, <span class="number">2</span>);</span><br><span class="line">lmap.put(<span class="string">"英语"</span>, <span class="number">3</span>);</span><br><span class="line">lmap.put(<span class="string">"历史"</span>, <span class="number">4</span>);</span><br><span class="line">lmap.put(<span class="string">"政治"</span>, <span class="number">5</span>);</span><br><span class="line">lmap.put(<span class="string">"地理"</span>, <span class="number">6</span>);</span><br><span class="line">lmap.put(<span class="string">"生物"</span>, <span class="number">7</span>);</span><br><span class="line">lmap.put(<span class="string">"化学"</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是：</p><blockquote><p>语文: 1<br>数学: 2<br>英语: 3<br>历史: 4<br>政治: 5<br>地理: 6<br>生物: 7<br>化学: 8</p></blockquote><p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6981649/03eb9014-da38-11e4-9cbf-03d9c21f05f2.png" alt="linkedhashmap"></p><p>没错，正如官方文档所说：</p><blockquote><p><strong>Hash table</strong> and <strong>linked list</strong> implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a <strong>doubly-linked list</strong> running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (<strong>insertion-order</strong>).</p></blockquote><p>LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p><h3 id="2-三个重点实现的函数"><a href="#2-三个重点实现的函数" class="headerlink" title="2. 三个重点实现的函数"></a>2. 三个重点实现的函数</h3><p>在HashMap中提到了下面的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。</p><p><strong>afterNodeAccess函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果定义了accessOrder，那么就保证最近访问节点放到最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。</p><p><strong>afterNodeInsertion函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 如果定义了移除规则，则执行相应的溢出</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户定义了<code>removeEldestEntry</code>的规则，那么便可以执行相应的移除操作。</p><p><strong>afterNodeRemoval函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 从链表中移除节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是在移除节点后调用的，就是将节点从双向链表中删除。</p><p>我们从上面3个函数看出来，基本上都是为了<strong>保证双向链表中的节点次序或者双向链表容量</strong>所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p><h3 id="3-put和get函数"><a href="#3-put和get函数" class="headerlink" title="3. put和get函数"></a>3. put和get函数</h3><p><code>put</code>函数在LinkedHashMap中未重新实现，只是实现了<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>两个回调函数。<code>get</code>函数则重新实现并加入了<code>afterNodeAccess</code>来保证访问顺序，下面是<code>get</code>函数的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生<code>structural modification</code>。官方文档是这么描述的：</p><blockquote><p>A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. <strong>In access-ordered linked hash maps, merely querying the map with get is a structural modification</strong>.</p></blockquote><p>不要犯了像<a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833" target="_blank" rel="noopener">ConcurrentModificationException with LinkedHashMap</a>类似的问题。</p><p>总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。:-)</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener">Class LinkedHashMap</a><br><a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833" target="_blank" rel="noopener">ConcurrentModificationException with LinkedHashMap</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;在理解了#7 介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap工作原理及实现</title>
    <link href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/</id>
    <published>2015-04-01T08:53:14.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>从本文你可以学习到：</p><blockquote><ol><li>什么时候会使用HashMap？他有什么特点？</li><li>你知道HashMap的工作原理吗？</li><li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li><li>你知道hash的实现吗？为什么要这样实现？</li><li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li></ol></blockquote><p>当我们执行下面的操作时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"语文"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"数学"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"英语"</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">"历史"</span>, <span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">"政治"</span>, <span class="number">5</span>);</span><br><span class="line">map.put(<span class="string">"地理"</span>, <span class="number">6</span>);</span><br><span class="line">map.put(<span class="string">"生物"</span>, <span class="number">7</span>);</span><br><span class="line">map.put(<span class="string">"化学"</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是</p><blockquote><p>政治: 5<br>生物: 7<br>历史: 4<br>数学: 2<br>化学: 8<br>语文: 1<br>英语: 3<br>地理: 6</p></blockquote><p>发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957741/0c039b1c-d933-11e4-8c1e-7558a8766272.png" alt="hashmap"></p><p>在官方文档中是这样描述HashMap的：</p><blockquote><p>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is <strong>unsynchronized</strong> and <strong>permits nulls</strong>.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p></blockquote><p>几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p><h3 id="2-两个重要的参数"><a href="#2-两个重要的参数" class="headerlink" title="2. 两个重要的参数"></a>2. 两个重要的参数</h3><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p><blockquote><ul><li><strong>Initial capacity</strong> The capacity is <strong>the number of buckets</strong> in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</li><li><strong>Load factor</strong> The load factor is <strong>a measure of how full the hash table is allowed to get</strong> before its capacity is automatically increased.</li></ul></blockquote><p>简单的说，Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把<code>capacity</code>设置过大，也不要把<code>load factor</code>设置过小。当bucket填充的数目（即hashmap中元素的个数）大于<code>capacity*load factor</code>时就需要调整buckets的数目为当前的2倍。</p><h3 id="3-put函数的实现"><a href="#3-put函数的实现" class="headerlink" title="3. put函数的实现"></a>3. put函数的实现</h3><p>put函数大致的思路为：</p><ol><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ol><p>具体代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-get函数的实现"><a href="#4-get函数的实现" class="headerlink" title="4. get函数的实现"></a>4. get函数的实现</h3><p>在理解了put之后，get就很简单了。大致思路如下：</p><ol><li>bucket里的第一个节点，直接命中；</li><li>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ol><p>具体代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 未命中</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-hash函数的实现"><a href="#5-hash函数的实现" class="headerlink" title="5. hash函数的实现"></a>5. hash函数的实现</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt="hash"></p><p>在对hashCode()计算hash时具体实现是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的：</p><blockquote><p>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between <strong>speed, utility, and quality</strong> of bit-spreading. Because many common sets of hashes are already <strong>reasonably distributed</strong> (so don’t benefit from spreading), and because <strong>we use trees to handle large sets of collisions in bins</strong>, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p></blockquote><p>在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用<code>&amp;</code>位操作，而非<code>%</code>求余)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p><p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用<code>O(logn)</code>的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p><p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在<a href="http://openjdk.java.net/jeps/180" target="_blank" rel="noopener">JEP-180</a>中，描述了这个问题：</p><blockquote><p>Improve the performance of java.util.HashMap under high hash-collision conditions by <strong>using balanced trees rather than linked lists to store map entries</strong>. Implement the same improvement in the LinkedHashMap class.</p></blockquote><p>之前已经提过，在获取HashMap的元素时，基本分两步：</p><ol><li>首先根据hashCode()做hash，然后确定bucket的index；</li><li>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li></ol><p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p><p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在<a href="http://www.importnew.com/14417.html" target="_blank" rel="noopener">Java 8：HashMap的性能提升</a>一文中有性能测试的结果。</p><h4 id="6-resize的实现"><a href="#6-resize的实现" class="headerlink" title="6. resize的实现"></a>6. resize的实现</h4><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p><blockquote><p>Initializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either <strong>stay at same index</strong>, or <strong>move with a power of two offset</strong> in the new table.</p></blockquote><p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p><p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958256/ceb6e6ac-d93b-11e4-98e7-c5a5a07da8c4.png" alt="rehash"></p><p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958301/519be432-d93c-11e4-85bb-dff0a03af9d3.png" alt="resize"></p><p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958677/d7acbad8-d941-11e4-9493-2c5e69d084c0.png" alt="resize16-32"></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><p>下面是代码的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p><p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p><p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p><p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p><p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="noopener">关于Java集合的小抄</a>中是这样描述的：</p><blockquote><p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p><p>插入元素时，如果两条Key落在同一个桶（比如哈希值1和17取模16后都属于第一个哈希桶），我们称之为哈希冲突。</p><p>JDK的做法是链表法，Entry用一个next属性实现多个Entry以单向链表存放。查找哈希值为17的key时，先定位到哈希桶，然后链表遍历桶里所有元素，逐个比较其Hash值然后key值。</p><p>在JDK8里，新增默认为8的阈值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p><p>当然，最好还是桶里只有一个元素，不用去比较。所以默认当Entry数量达到桶数量的75%时，哈希冲突已比较严重，就会成倍扩容桶数组，并重新分配所有原来的Entry。扩容成本不低，所以也最好有个预估值。</p><p>取模用与操作（hash &amp; （arrayLength-1））会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p><p>iterator（）时顺着哈希桶数组来遍历，看起来是个乱序</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.importnew.com/7099.html" target="_blank" rel="noopener">HashMap的工作原理</a><br><a href="http://www.importnew.com/14417.html" target="_blank" rel="noopener">Java 8：HashMap的性能提升</a><br><a href="http://openjdk.java.net/jeps/180" target="_blank" rel="noopener">JEP 180: Handle Frequent HashMap Collisions with Balanced Trees</a><br><a href="http://www.importnew.com/7166.html" target="_blank" rel="noopener">ConurrentHashMap和Hashtable的区别</a><br><a href="http://www.importnew.com/7010.html" target="_blank" rel="noopener">HashMap和Hashtable的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;从本文你可以学习到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么时候会使用HashMap？他有什么特点？&lt;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合框架</title>
    <link href="http://yikun.github.io/2015/03/31/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yikun.github.io/2015/03/31/Java集合框架/</id>
    <published>2015-03-31T06:27:13.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="什么是集合？"><a href="#什么是集合？" class="headerlink" title="什么是集合？"></a>什么是集合？</h4><p>这Java官方的<a href="https://docs.oracle.com/javase/tutorial/collections/intro/index.html" target="_blank" rel="noopener">入门文档</a>是这样描述集合的：</p><blockquote><p>Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。</p></blockquote><h4 id="什么是集合框架？"><a href="#什么是集合框架？" class="headerlink" title="什么是集合框架？"></a>什么是集合框架？</h4><blockquote><p>Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了：</p><ul><li><strong>Interfaces:</strong><br>这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构；</li><li><strong>Implementations:</strong><br>这些是接口的具体实现。本质上，是一些可复用的数据结构；</li><li><strong>Algorithms:</strong><br>这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。</li></ul><p>除了Java的集合框架，还有一些著名的集合框架的例子：比如C++的STL和Smalltalk的集合架构。从历史上来看，集合框架可能比较复杂，也可能有一些很陡峭的学习曲线。不过我们相信Java的集合框架会突破这样的传统，在这章你就可以自己学会。</p></blockquote><h4 id="使用集合框架有什么好处？"><a href="#使用集合框架有什么好处？" class="headerlink" title="使用集合框架有什么好处？"></a>使用集合框架有什么好处？</h4><blockquote><p>Java的集合框架提供了一下优点：</p><ul><li><strong>减少编程的工作量</strong>：通过提供有用的数据结构和算法，集合框架能让你更专注的实现程序的核心功能，而不是去做一个底层的“管道工”。Java框架通过促进无关API的互操作性，使得你不用自己去实现不同API的适配</li><li><strong>提高程序的速度与质量</strong>：集合框架提供了一些有用数据结构和算法的高性能、高质量的实现。每个接口的不同的实现也是可以互换的，所以程序可以通过切换集合来做一些调整。正因为你从实现数据结构的那些苦差事中脱离出来，你才可以有更多的实现去改善你自己程序的性能和质量</li><li><strong>允许无关APIs的互操作</strong>：集合接口是API之间传递集合的一个“方言”，比如我的网络管理API有一个节点名的集合，而GUI工具需要一个列标题的集合，即使是分开实现它们，我们的APIs也可以无缝的接合。</li><li><strong>省力地学习和使用新API</strong>：<br>这是另一个领先的优势，设计者和实现者没必要在每次都重新设计API的时候都“推倒重来”地实现集合，而是直接使用标准的集合接口就好了。</li><li><strong>促进软件的复用</strong>：符合标准集合接口的新数据结构本质上是可以复用的。对于操作这些新数据结构算法也是一样可以复用的。</li></ul></blockquote><p>因此，后面也便从接口、实现、算法几方面结合着代码和官方的文档学习总结一下。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/6912860/5a9ea472-d7aa-11e4-9002-8e2c90d0ca58.png" alt="java interface"><br>在Java中所有的核心集合接口都是generic的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>也就是说在声明一个Collection的时候，应该指定一种类型。官方是这样解释原因的：</p><blockquote><p>Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime.</p></blockquote><p>下面就来介绍一下几种接口：</p><ul><li><strong>Collection</strong>： 集合层次中的根。一个集合表示一组对象。有些有序，有些无序。有些重复，有些重复。Collection没有直接的实现，而只有它的子接口的对应的实现。</li><li><strong>Set</strong>：<strong>不能包含重复的元素</strong>，比如扑克手牌、学生选课计划、计算机的进程。</li><li><strong>List</strong>：有序的集合，也可以包含重复的元素。用于对每个元素精确的控制，比如插入、用index来索引。</li><li><strong>Queue</strong>：用于多元素有优先级的处理，可以用做FIFO</li><li><strong>Deque</strong>：用于多元素有优先级的处理，double ended queue，可以用作FIFO，LIFO</li><li><strong>Map</strong>：用于keys到values的映射，不能包含重复元素<br>另外还提供了2个带排序的Set和Map。</li><li><strong>SortedSet</strong>：<strong>元素升序</strong></li><li><strong>SortedMap</strong>：<strong>key升序</strong></li></ul><p>在1.6版本开始，还有两种新的接口<strong>NavigableSet</strong>、<strong>NavigableMap</strong>。</p><blockquote><p>A SortedMap/SortedSet extended with navigation methods reporting closest matches for given search targets.</p></blockquote><p>提供诸如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回第一个大于e的元素</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>之类的“导航性质”的便捷操作。</p><p>以上便是Java集合框架与接口的相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;h4 id=&quot;什么是集合？&quot;&gt;&lt;a href=&quot;#什么是集合？&quot; class=&quot;headerlink&quot; title=&quot;什么是集合？&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>定时器管理实现与初探</title>
    <link href="http://yikun.github.io/2015/03/08/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%9D%E6%8E%A2/"/>
    <id>http://yikun.github.io/2015/03/08/定时器管理实现与初探/</id>
    <published>2015-03-08T05:52:10.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>最近需要实现一个简单的定时器管理，背景是硬件只有一个定时中断器，每100ms给一个时钟中断，我们需要利用它及相关代码实现整个协议中的定时器管理。然后大概看了看Linux的定时器、Nginx的定时器、Tegine的定时器，把一些思路和收获记一下。</p><h3 id="2-思路"><a href="#2-思路" class="headerlink" title="2. 思路"></a>2. 思路</h3><p>思路本身很简单，用硬件时钟计数，每次检查，有定时器该执行就调用就行了。</p><p>具体的来说就是</p><ol><li><strong>记录滴答数jiffies</strong>。用于记录当前时间；</li><li><strong>加入定时器事件</strong>。用户需要启动一个定时器时，我们将该定时器事件(触发时间timeout、回调函数timeout_handler)加入到某种数据结构中;</li><li><strong>检查执行事件</strong>。每次更新当前滴答数N时，去检查这个定时器结构中的每个定时器事件是否应该溢出，如果定时器没到，就啥也不做，时间到了的话(timeout&lt;=jiffies)就触发该定时器事件F。本步大致的代码逻辑是：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jiffies &lt; timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we did not timed out, do noting</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we timed out</span></span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3. 问题"></a>3. 问题</h3><h4 id="1-关于滴答数溢出的问题"><a href="#1-关于滴答数溢出的问题" class="headerlink" title="1 关于滴答数溢出的问题"></a>1 关于滴答数溢出的问题</h4><p>首先，遇到的第一个问题就是滴答数溢出的问题，在无符号数到达最大值时，会从0开始重新累加。</p><p>例如，我们用<code>unsigned char</code>计数，那么滴答数会从<code>0(0x00)-&gt;1(0x01)-&gt;....-&gt;254(0xFE)-&gt;255(0xFF)-&gt;0(0x00)-&gt;1(0x01)-&gt;...</code>如此循环计数。<br>那么问题出现了，在254时刻出现了一个A事件(+4后执行)，即时间溢出为0x02，那么如果我们做判定时，很显然，在254滴答的时候就把2滴答(实际上我们指的是254+4=258)的事件执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">254</span> &lt; <span class="number">2</span>) <span class="comment">//false</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// but</span></span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实问题的根本原因是<strong>事件发生滴答和当前时间滴答使用的不是一个参考系</strong>。然而在Linux代码实现中，利用<strong>无符号转有符号</strong>的巧妙方式解决了上面那个问题，<a href="https://github.com/torvalds/linux/blob/4f671fe2f9523a1ea206f63fe60a7c7b3a56d5c7/include/linux/jiffies.h#L101" target="_blank" rel="noopener">linux/include/linux/jiffies.h</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time_after(a,b) returns true if the time a is after time b.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_after(a,b)     \</span></span><br><span class="line">    (typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, a) &amp;&amp; \</span><br><span class="line">     typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, b) &amp;&amp; \</span><br><span class="line">     ((<span class="keyword">long</span>)(b) - (<span class="keyword">long</span>)(a) &lt; <span class="number">0</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_before(a,b)    time_after(b,a)</span></span><br></pre></td></tr></table></figure><p>用了这个宏以后，巧妙的一幕发生了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">char</span>(<span class="number">254</span>) &lt; <span class="keyword">char</span>(<span class="number">1</span>)) <span class="comment">//true =&gt; -2 &lt; -1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢，在Linux 3.12的一个<a href="https://github.com/torvalds/linux/commit/5a581b367b5df0531265311fc681c2abd377e5e6#diff-2610861e923003988c4c2aa213affc7d" target="_blank" rel="noopener">patch</a>中，又修改了下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_after(a,b)     \</span></span><br><span class="line">    (typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, a) &amp;&amp; \</span><br><span class="line">     typecheck(<span class="keyword">unsigned</span> <span class="keyword">long</span>, b) &amp;&amp; \</span><br><span class="line">     ((<span class="keyword">long</span>)((b) - (a)) &lt; <span class="number">0</span>))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> time_before(a,b)    time_after(b,a)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">According to the C standard 3.4.3p3, overflow of a signed integer results</span></span><br><span class="line"><span class="comment">in undefined behavior.  This commit therefore changes the definitions</span></span><br><span class="line"><span class="comment">of time_after(), time_after_eq(), time_after64(), and time_after_eq64()</span></span><br><span class="line"><span class="comment">to avoid this undefined behavior.  The trick is that the subtraction</span></span><br><span class="line"><span class="comment">is done using unsigned arithmetic, which according to 6.2.5p9 cannot</span></span><br><span class="line"><span class="comment">overflow because it is defined as modulo arithmetic.  This has the added</span></span><br><span class="line"><span class="comment">(though admittedly quite small) benefit of shortening four lines of code</span></span><br><span class="line"><span class="comment">by four characters each.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>大致意思就是C语言标准里面，有符号整型的溢出在C语言的标准中是未定义的blabla但是减法不会溢出，所以我这个改法是正确的blabla。哦对了，于是，我们对比时间代码编程了下面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(time_before(jiffies, timeout))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的<a href="https://github.com/alibaba/tengine/blob/master/src/event/ngx_event_timer.c#L98" target="_blank" rel="noopener">Tegine/Nginx</a>也是使用的类似的实现方法，而且有趣的是nginx也出现过类似的<a href="https://github.com/alibaba/tengine/commit/246f4133f6a1048dce36d3e55a5c748228288da1#diff-646868bfaeca38df552b086ec7cbf4e0L70" target="_blank" rel="noopener">patch</a>。</p><h4 id="2-关于定时器存储结构的问题"><a href="#2-关于定时器存储结构的问题" class="headerlink" title="2 关于定时器存储结构的问题"></a>2 关于定时器存储结构的问题</h4><p>因为我们的定时器个数比较少，所以用有序链表(按照expire时间)就差不多了。插入、删除都是O(n)，查找O(1)；</p><p>在Linux使用的是双向链表实现的；</p><p>在Nginx的实现中，则使用的是红黑树，类似的每次都要log(n)去查找最小节点；</p><p><a href="tengine.taobao.org/download/programmer-201209-Tengine.pdf">据说</a>Tengine要使用四叉最小堆(4-heap)去改进，在查找的时候能O(1)，其他操作可以O(log(n))，不过我看<a href="https://github.com/alibaba/tengine/blob/tengine-2.1.0/src/event/ngx_event_timer.c" target="_blank" rel="noopener">tengine -2.1.0</a>的代码中，还是用的红黑树实现的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://stackoverflow.com/questions/8206762/how-does-linux-handle-overflow-in-jiffies" target="_blank" rel="noopener">How does linux handle overflow in jiffies?</a><br><a href="http://blog.chinaunix.net/uid-23215128-id-2521293.html" target="_blank" rel="noopener">jiffies溢出与时间先后比较</a><br><a href="http://blog.csdn.net/mrpre/article/details/27890415" target="_blank" rel="noopener">linux内核计算时间差以及jiffies溢出</a><br><a href="http://www.cnblogs.com/xiaohuo/archive/2012/06/19/2555056.html" target="_blank" rel="noopener">nginx学习 - timer</a><br><a href="tengine.taobao.org/download/programmer-201209-Tengine.pdf">淘宝 Tengine易运维的高性能Nginx服务器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h3&gt;&lt;p&gt;最近需要实现一个简单的定时器管理，背景是硬件只有一个定时中断器，每100ms给一个时钟中断，我们需要利用它及相关代码实现
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>自增运算符的反汇编</title>
    <link href="http://yikun.github.io/2015/02/08/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://yikun.github.io/2015/02/08/自增运算符的反汇编/</id>
    <published>2015-02-08T11:19:11.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="i"><a href="#i" class="headerlink" title="i++"></a>i++</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j = i++;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov         eax,dword ptr [i]  </span><br><span class="line">mov         dword ptr [j],eax  ;将i值赋值给j</span><br><span class="line">mov         ecx,dword ptr [i]  </span><br><span class="line">add         ecx,1                    </span><br><span class="line">mov         dword ptr [i],ecx  ;i自增</span><br></pre></td></tr></table></figure><h3 id="i-1"><a href="#i-1" class="headerlink" title="++i"></a>++i</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j = ++i;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov         eax,dword ptr [i]  </span><br><span class="line">add         eax,1  </span><br><span class="line">mov         dword ptr [i],eax ;i自增 </span><br><span class="line">mov         ecx,dword ptr [i]  </span><br><span class="line">mov         dword ptr [j],ecx  ;将自增后i值给j</span><br></pre></td></tr></table></figure><p>很清晰了。: )</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;i&quot;&gt;&lt;a href=&quot;#i&quot; class=&quot;headerlink&quot; title=&quot;i++&quot;&gt;&lt;/a&gt;i++&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>搭建Git服务器</title>
    <link href="http://yikun.github.io/2015/02/05/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yikun.github.io/2015/02/05/搭建Git服务器/</id>
    <published>2015-02-05T05:11:46.000Z</published>
    <updated>2021-08-02T03:29:56.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在服务器上安装git"><a href="#在服务器上安装git" class="headerlink" title="在服务器上安装git"></a>在服务器上安装git</h1><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h3><p>sudo apt-get install git</p><h3 id="2-增加git用户"><a href="#2-增加git用户" class="headerlink" title="2. 增加git用户"></a>2. 增加git用户</h3><p>sudo adduser git</p><h3 id="3-将用户的公钥添加"><a href="#3-将用户的公钥添加" class="headerlink" title="3. 将用户的公钥添加"></a>3. 将用户的公钥添加</h3><p>cat id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys</p><h3 id="4-新建一个库"><a href="#4-新建一个库" class="headerlink" title="4. 新建一个库"></a>4. 新建一个库</h3><p>sudo git init –bare sample.git<br>sudo chown -R git:git sample.git</p><h3 id="5-禁止git登陆"><a href="#5-禁止git登陆" class="headerlink" title="5. 禁止git登陆"></a>5. 禁止git登陆</h3><p>vim /etc/passwd<br>把<code>git:X:1001:1001:,,,:/home/git:/bin/bash</code>换为下面的<br>git:X:1001:1001:,,,:/home/git:/usr/bin/git-shell</p><p>git clone git@server:/srv/sample.git</p><h1 id="在客户端上安装git"><a href="#在客户端上安装git" class="headerlink" title="在客户端上安装git"></a>在客户端上安装git</h1><h3 id="1-在windows下安装git"><a href="#1-在windows下安装git" class="headerlink" title="1. 在windows下安装git"></a>1. 在windows下安装git</h3><p><a href="http://www.git-scm.com/downloads" target="_blank" rel="noopener">下载地址</a></p><h3 id="2-安装可视化界面-可选"><a href="#2-安装可视化界面-可选" class="headerlink" title="2. 安装可视化界面(可选)"></a>2. 安装可视化界面(可选)</h3><p><a href="https://code.google.com/p/tortoisegit/wiki/Download?tm=2" target="_blank" rel="noopener">下载地址</a><br>鼠标邮件，选择“TortoiseGit”-&gt;“Settings”，在“User Info”输入Name和Email</p><h3 id="3-生成公钥"><a href="#3-生成公钥" class="headerlink" title="3. 生成公钥"></a>3. 生成公钥</h3><p>在命令行和tortoisegit中稍有不同：<br><strong>In shell</strong><br>a. win+r –&gt; Git Bash –&gt;  ssh-keygen.exe<br>b. 一路回车，将生成“c:/Users/XXX/.ssh/id_rsa.pub”<br>c. (公钥)把id_rsa.pub重命名为id_rsa.XXX.pub, 例如id_rsa.jiangyikun.pub<br>d. (私钥)也已经生成到<code>c:/Users/XXX/.ssh/id_rsa</code>了<br>e. 将id_rsa.XXX.pub发送给git管理员</p><p><strong>In tortoisegit</strong><br>a. 打开Puttygen，SSH-2 RSA，点击Generate<br>b. 使用鼠标生成随机key<br>c. (公钥)复制Key到id_rsa.XXX.pub<br>d. (私钥)Save private key为XXX.ppk，并将Load Putty Key设为XXX.ppk<br>e. 将id_rsa.XXX.pub发送给git管理员</p><h3 id="git管理员操作-4-添加公钥的服务器"><a href="#git管理员操作-4-添加公钥的服务器" class="headerlink" title="(git管理员操作) 4.添加公钥的服务器"></a>(git管理员操作) 4.添加公钥的服务器</h3><p>以root权限登陆， 注意是“&gt;&gt;”追加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.XXX.pub &gt;&gt; /home/git/.ssh/authorized_keys</span><br><span class="line"><span class="meta">#</span><span class="bash"> drwx------. 2 git  git  4096 Apr 15 13:17 .ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -rw-------. 1 git git 1189 Apr 15 13:17 authorized_keys</span></span><br></pre></td></tr></table></figure><p>在客户端测试：ssh <a href="mailto:git@XXX.XXX.XXX.XXX" target="_blank" rel="noopener">git@XXX.XXX.XXX.XXX</a>，不再输入密码即可。</p><h3 id="5-简单学习"><a href="#5-简单学习" class="headerlink" title="5. 简单学习"></a>5. 简单学习</h3><p>这是一个用于测试的repo你可以拿他来做做测试</p><p>a. 克隆仓库<br>git clone <a href="mailto:git@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">git@xxx.xxx.xxx.xxx</a>:/yikun/sample.git<br>或者使用tortoisegit，在某个文件夹，右键–&gt;Git Clone…–&gt; URL填写“<a href="mailto:git@xxx.xxx.xxx.xxx" target="_blank" rel="noopener">git@xxx.xxx.xxx.xxx</a>:/yikun/sample.git”–&gt; 输入密码</p><p>b. 修改文件并提交</p><ol><li>在sample目录下简历一个文件比如，XXX.txt</li><li>右键 Git Commit -&gt; “Master”</li><li>填写Commit Message，并选择需要提交的文件，双击可以可视化的查看diff</li></ol><p>c. 点击push， ok</p><h3 id="6-学习git"><a href="#6-学习git" class="headerlink" title="6. 学习git"></a>6. 学习git</h3><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></p><p>Enjoy it! :)</p><h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><h4 id="1-如何将一个现有的本地git库上传到服务器上？"><a href="#1-如何将一个现有的本地git库上传到服务器上？" class="headerlink" title="1. 如何将一个现有的本地git库上传到服务器上？"></a>1. 如何将一个现有的本地git库上传到服务器上？</h4><p>从现有repo新建server repo的时候(服务器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir newrepo.git</span><br><span class="line">cd newrepo.git</span><br><span class="line">git --bare init</span><br><span class="line"><span class="meta">#</span><span class="bash"> Initialized empty Git repository <span class="keyword">in</span> /yikun/newrepo.git/.git/</span></span><br></pre></td></tr></table></figure><p>在现有的repo中（客户端）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd newrepo.git  </span><br><span class="line">git remote add origin git@xxx.xxx.xxx.xxx:/yikun/newrepo.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="2-如何克隆服务器上现有库？"><a href="#2-如何克隆服务器上现有库？" class="headerlink" title="2. 如何克隆服务器上现有库？"></a>2. 如何克隆服务器上现有库？</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从服务器克隆</span></span><br><span class="line">git clone git@xxx.xxx.xxx.xxx:/yikun/newrepo.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改并本地提交</span></span><br><span class="line">git commit -am "commitmessage"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传至服务器</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h4><p>1 <strong>权限问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Counting objects: 179, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (176/176), done.</span><br><span class="line">fatal: Unable to create temporary file: Permission denied</span><br><span class="line">fatal: sha1 file &apos;&lt;stdout&gt;&apos; write error: Broken pipe</span><br><span class="line">error: failed to push some refs to &apos;git@xxx.xxx.xxx.xxx:/yikun/newrepo.git&apos;</span><br><span class="line">git did not exit cleanly (exit code 1) (3261 ms @ 2015/2/5 11:17:39)</span><br></pre></td></tr></table></figure><p>可以试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R git *</span><br><span class="line">chgrp -R git *</span><br></pre></td></tr></table></figure><p>2 <strong>提交问题</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error: refusing to update checked out branch: refs/heads/master</span><br><span class="line">error: By default, updating the current branch in a non-bare repository</span><br><span class="line">error: is denied, because it will make the index and work tree inconsistent</span><br><span class="line">error: with what you pushed, and will require &apos;git reset --hard&apos; to match</span><br><span class="line">error: the work tree to HEAD.</span><br><span class="line">error: </span><br><span class="line">error: You can set &apos;receive.denyCurrentBranch&apos; configuration variable to</span><br><span class="line">error: &apos;ignore&apos; or &apos;warn&apos; in the remote repository to allow pushing into</span><br><span class="line">error: its current branch; however, this is not recommended unless you</span><br><span class="line">error: arranged to update its work tree to match what you pushed in some</span><br><span class="line">error: other way.</span><br><span class="line">error: </span><br><span class="line">error: To squelch this message and still keep the default behaviour, set</span><br><span class="line">error: &apos;receive.denyCurrentBranch&apos; configuration variable to &apos;refuse&apos;.</span><br></pre></td></tr></table></figure><p>可以试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config 'receive.denyCurrentBranch' warn</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.163.com/clevertanglei900@126/blog/static/111352259201011655837986/" target="_blank" rel="noopener">小组级git服务器搭建</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在服务器上安装git&quot;&gt;&lt;a href=&quot;#在服务器上安装git&quot; class=&quot;headerlink&quot; title=&quot;在服务器上安装git&quot;&gt;&lt;/a&gt;在服务器上安装git&lt;/h1&gt;&lt;h3 id=&quot;1-安装git&quot;&gt;&lt;a href=&quot;#1-安装git&quot; class
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>排序算法总结</title>
    <link href="http://yikun.github.io/2014/11/20/algorithm_sort/"/>
    <id>http://yikun.github.io/2014/11/20/algorithm_sort/</id>
    <published>2014-11-20T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="1-排序算法汇总"><a href="#1-排序算法汇总" class="headerlink" title="1. 排序算法汇总"></a>1. 排序算法汇总</h3><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><table><thead><tr><th>算法名称</th><th>复杂度</th><th>实现关键</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>（有序区，无序区）。在无序区里选择一个最小的元素跟在有序区的后面。</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。</td></tr><tr><td>希尔排序</td><td>nlog^2(n)</td><td>每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1(插入)。</td></tr><tr><td>快速排序</td><td>nlog(n)</td><td>（小数，枢纽元，大数）。</td></tr><tr><td>堆排序</td><td>nlog(n)</td><td></td></tr><tr><td>桶排序</td><td>O(n)</td><td>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</td></tr></tbody></table><p>不稳定的排序：<br>稳定性一个形象的比喻，本来有两个并列第三，一排序把原来并列的顺序给变了。<br>比如：选择排序、快速排序、堆排序、希尔排序；<br><a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">参考链接</a><br><!--more--></p><h3 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Bubble_sort_animation.gif" alt></p><p>每次都把未排序的第一个作为起始点，然后逐渐冒泡上升，之后未排序区越来越少，最终排序完成</p><p><img src="http://yikun.github.io/assets/post/algorithm/sort/bubble_sort.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 比较相邻元素，若a[j]比a[j+1]大，则交换</span></span><br><span class="line"><span class="comment">// a[j]就像一个气泡一样“浮”到合适位置了</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n<span class="number">-1</span>-i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Selection_sort_animation.gif" alt></p><p>每一趟从待排序的数据元素中<strong>选出最小（或最大）的一个元素</strong>，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</p><p><img src="http://yikun.github.io/assets/post/algorithm/sort/select_sort.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">min = i;</span><br><span class="line"><span class="comment">// 找到最小值</span></span><br><span class="line"><span class="keyword">for</span> (j=i+<span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[min] &gt; a[j])</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(min != i)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[min], &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-插入排序"><a href="#4-插入排序" class="headerlink" title="4. 插入排序"></a>4. 插入排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Insertion_sort_animation.gif" alt></p><p>每次排序从未排序区取一个“牌”，然后往前插入(包括了两步：大的往后移，把牌放到合适位置)。<br><img src="http://yikun.github.io/assets/post/algorithm/sort/Insert-sort-animation.gif" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 取牌</span></span><br><span class="line">tmp = a[i];</span><br><span class="line"><span class="comment">// 往前插的起始位置</span></span><br><span class="line">j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大的a[j]都放后面，寻找出j</span></span><br><span class="line"><span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; a[j] &gt; tmp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 往后放一个</span></span><br><span class="line">a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放到该放的位置</span></span><br><span class="line">a[j+<span class="number">1</span>]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有种思路，把数据后移的过程换成交换的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，选中的牌冒泡向前插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort_2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//通过i选牌</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 冒泡向前插入(i-1 --&gt; 0)</span></span><br><span class="line"><span class="keyword">for</span> (j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; a[j] &gt; a[j + <span class="number">1</span>]; j--)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print_a(a, n);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><h3 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h3><p>对插入排序再加一个步长的循环就是希尔排序了，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</span><br></pre></td></tr></table></figure></p><p>按照5步长排序，则相当于按列先进行排序(实际是通过下标实现的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>排序后结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure></p><p>多次循环后，只需要<strong>最终步长为1</strong>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gap=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (gap &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line">gap = gap*<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 取牌</span></span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 冒泡向前插入(i-gap : gap : 0), 保证每列ok</span></span><br><span class="line"><span class="keyword">for</span> (j = i - gap; (j &gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt; a[j + gap]); j = j - gap)</span><br><span class="line">&#123;</span><br><span class="line">swap(&amp;a[j], &amp;a[j+gap]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gap = (gap<span class="number">-1</span>) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/quicksort.gif" alt><br>每次迭代都选出一个基准，左边放小的，右边放大的，最终迭代完成。</p><p><img src="http://yikun.github.io/assets/post/algorithm/sort/quick_sort.png" alt></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序分区</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="comment">// x为基准</span></span><br><span class="line">x = a[r];</span><br><span class="line"><span class="comment">// i为界限,发现小于x的，就i++，再放到i处</span></span><br><span class="line">i = p<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (j=p; j&lt;= r<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j]&lt;=x)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">swap(&amp;a[i], &amp;a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 至此，所有小于x的都到i左边了(a[0]~a[i-1])，a[r]是x，因此交换a[i+1]和a[r]</span></span><br><span class="line">swap(&amp;a[i+<span class="number">1</span>], &amp;a[r]);</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (p &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在数据集之中，选择一个元素作为"基准"（pivot）</span></span><br><span class="line"><span class="comment">// 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边</span></span><br><span class="line">q = partition(a, p, r);</span><br><span class="line"><span class="comment">// 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</span></span><br><span class="line">quick_sort(a, p, q<span class="number">-1</span>);</span><br><span class="line">quick_sort(a, q+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;1-排序算法汇总&quot;&gt;&lt;a href=&quot;#1-排序算法汇总&quot; class=&quot;headerlink&quot; title=&quot;1. 排序算法汇总&quot;&gt;&lt;/a&gt;1. 排序算法汇总&lt;/h3&gt;&lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx的连接池</title>
    <link href="http://yikun.github.io/2014/04/17/nginxconnections/"/>
    <id>http://yikun.github.io/2014/04/17/nginxconnections/</id>
    <published>2014-04-17T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>最近，有些忙，没看nginx代码，前几天去阿里实习面试了，结果还不错。:)让我激动的是二面面试我的居然是褚霸！面完了以后，还和他握了手。简直是激动得不能再激动啦。面试的时候也有很大收获，至少知道自己的路是对的，也应该加强自己后台开发的相关项目经历。加油吧！</p><a id="more"></a><h3 id="1-连接池的初始化"><a href="#1-连接池的初始化" class="headerlink" title="1. 连接池的初始化"></a>1. 连接池的初始化</h3><p>首先，初始化连接池，</p><pre><code>cycle-&gt;connections =    ngx_alloc(sizeof(ngx_connection_t) * cycle-&gt;connection_n, cycle-&gt;log);if (cycle-&gt;connections == NULL) {    return NGX_ERROR;}</code></pre><p>我们可以看到cycle-&gt;connections被分配了一个足够的空间。</p><pre><code>i = cycle-&gt;connection_n;next = NULL;do {    i--;    c[i].data = next;    c[i].read = &amp;cycle-&gt;read_events[i];    c[i].write = &amp;cycle-&gt;write_events[i];    c[i].fd = (ngx_socket_t) -1;    next = &amp;c[i];} while (i);cycle-&gt;free_connections = next;cycle-&gt;free_connection_n = cycle-&gt;connection_n;</code></pre><p>初始化完成后，连接池的样子就想一个前一个元素的一个数组。最后，free_connection指向第一个元素。我们可以看下<br>我们可以看下，初始化后连接池情况：</p><p><img src="/assets/post/2014-04-17-nginxconnections/connections_init.png" alt="connections_init"></p><p>现在的结果就是，沿着free–&gt;connection–&gt;connection就连成了一串，然后get的时候直接把free_connection拿出来就可以了，然后free_connection指向原来的那个next。</p><h3 id="2-连接的获取"><a href="#2-连接的获取" class="headerlink" title="2. 连接的获取"></a>2. 连接的获取</h3><pre><code>ngx_connection_t *ngx_get_connection(ngx_socket_t s, ngx_log_t *log){    ngx_uint_t         instance;    ngx_event_t       *rev, *wev;    ngx_connection_t  *c;    /* disable warning: Win32 SOCKET is u_int while UNIX socket is int */    if (ngx_cycle-&gt;files &amp;&amp; (ngx_uint_t) s &gt;= ngx_cycle-&gt;files_n) {        ngx_log_error(NGX_LOG_ALERT, log, 0,                      &quot;the new socket has number %d, &quot;                      &quot;but only %ui files are available&quot;,                      s, ngx_cycle-&gt;files_n);        return NULL;    }    /* ngx_mutex_lock */    //把free_connections给c，最后会返回c    c = ngx_cycle-&gt;free_connections;    //连接池不够了    if (c == NULL) {        ngx_drain_connections();        c = ngx_cycle-&gt;free_connections;    }    if (c == NULL) {        ngx_log_error(NGX_LOG_ALERT, log, 0,                      &quot;%ui worker_connections are not enough&quot;,                      ngx_cycle-&gt;connection_n);        /* ngx_mutex_unlock */        return NULL;    }    // free_connections指向下一个可用连接    ngx_cycle-&gt;free_connections = c-&gt;data;    ngx_cycle-&gt;free_connection_n--;    /* ngx_mutex_unlock */    if (ngx_cycle-&gt;files) {        ngx_cycle-&gt;files[s] = c;    }    rev = c-&gt;read;    wev = c-&gt;write;    ngx_memzero(c, sizeof(ngx_connection_t));    c-&gt;read = rev;    c-&gt;write = wev;    c-&gt;fd = s;    c-&gt;log = log;    instance = rev-&gt;instance;    ngx_memzero(rev, sizeof(ngx_event_t));    ngx_memzero(wev, sizeof(ngx_event_t));    rev-&gt;instance = !instance;    wev-&gt;instance = !instance;    rev-&gt;index = NGX_INVALID_INDEX;    wev-&gt;index = NGX_INVALID_INDEX;    rev-&gt;data = c;    wev-&gt;data = c;    wev-&gt;write = 1;    return c;}</code></pre><p>我们可以看下，get了三次后的连接池情况：</p><p><img src="/assets/post/2014-04-17-nginxconnections/connections_get.png" alt="connections_get"></p><h3 id="3-连接的释放"><a href="#3-连接的释放" class="headerlink" title="3. 连接的释放"></a>3. 连接的释放</h3><p>下面是free_connection的过程，连接释放后，重新加入到连接池的过程很像链表在头指针后插入节点的操作(其实就是)，free之后，可能连接池的整体情况不像开始那样“整齐”，不过，我们把他当做链表来看，free_connection是头指针，通过c-&gt;data把指针一个一个串了起来，保证下次get的时候，get头节点的，free的时候，也是free头节点。</p><pre><code>voidngx_free_connection(ngx_connection_t *c){    /* ngx_mutex_lock */    //free节点next指向    c-&gt;data = ngx_cycle-&gt;free_connections;    ngx_cycle-&gt;free_connections = c;    ngx_cycle-&gt;free_connection_n++;    /* ngx_mutex_unlock */    if (ngx_cycle-&gt;files) {        ngx_cycle-&gt;files[c-&gt;fd] = NULL;    }}</code></pre><p>我们可以看下，free了三次后的连接池情况：</p><p><img src="/assets/post/2014-04-17-nginxconnections/connections_free.png" alt="connections_free"></p><p>以上就是连接池的基本操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，有些忙，没看nginx代码，前几天去阿里实习面试了，结果还不错。:)让我激动的是二面面试我的居然是褚霸！面完了以后，还和他握了手。简直是激动得不能再激动啦。面试的时候也有很大收获，至少知道自己的路是对的，也应该加强自己后台开发的相关项目经历。加油吧！&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx建立连接过程分析</title>
    <link href="http://yikun.github.io/2014/04/01/nginxaccept/"/>
    <id>http://yikun.github.io/2014/04/01/nginxaccept/</id>
    <published>2014-04-01T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>本文主要学习了nginx连接accept的步骤，以及nginx的负载均衡的方法。<br><a id="more"></a></p><h3 id="2-建立连接过程"><a href="#2-建立连接过程" class="headerlink" title="2. 建立连接过程"></a>2. 建立连接过程</h3><p>处理新链接事件的回调函数是ngx_event_accept函数，当处理建立连接事件的时候就调用ngx_event_accept函数。该函数的具体步骤如下所示。</p><p>1.调用accpet方法。</p><pre><code>s=accept(lc-&gt;fd, (struct sockaddr *)sa, &amp;socklen)</code></pre><p>2.设置负载均衡的阈值。</p><pre><code>ngx_accept_disabled = ngx_cycle-&gt;connection_n/8 - ngx_cycle-&gt;free_connection_n;</code></pre><p>3.从连接池获取连接。</p><pre><code>c = ngx_get_connection(s, ev-&gt;log);</code></pre><p>4.给连接分配内存空间。</p><p>5.设置套接字属性，设置非阻塞<br>        ngx_nonblocking(s)</p><p>6.将连接加入事件循环。<br>        ngx_add_conn(c)</p><pre><code>#define ngx_add_conn         ngx_event_actions.add_conn</code></pre><p>7.调用监听对象的回调方法。</p><h3 id="3-负载均衡问题"><a href="#3-负载均衡问题" class="headerlink" title="3. 负载均衡问题"></a>3. 负载均衡问题</h3><p>在建立连接前需要使用ngx_trylock_accept_mutex()去“抢锁”，抢到锁了之后，才有资格去accept连接。</p><p>代码比较简单，拿出来分析一下</p><pre><code>ngx_int_tngx_trylock_accept_mutex(ngx_cycle_t *cycle){    //尝试锁，无论取到还是未取到，均立即返回，取到返回1，否则返回0。    if (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) {        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;log, 0,                       &quot;accept mutex locked&quot;);        if (ngx_accept_mutex_held            &amp;&amp; ngx_accept_events == 0            &amp;&amp; !(ngx_event_flags &amp; NGX_USE_RTSIG_EVENT))        {            return NGX_OK;        }        //将所有读事件加入epoll        if (ngx_enable_accept_events(cycle) == NGX_ERROR) {            ngx_shmtx_unlock(&amp;ngx_accept_mutex);            return NGX_ERROR;        }        ngx_accept_events = 0;        ngx_accept_mutex_held = 1;        return NGX_OK;    }    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;log, 0,                   &quot;accept mutex lock failed: %ui&quot;, ngx_accept_mutex_held);    //未取到锁，ngx_accept_mutex_held还为1，则删除所有监听的读事件    if (ngx_accept_mutex_held) {        if (ngx_disable_accept_events(cycle) == NGX_ERROR) {            return NGX_ERROR;        }        ngx_accept_mutex_held = 0;    }    return NGX_OK;}</code></pre><p>总结一下就是说，拿到锁了，就监听事件，拿不到就不能监听。若ngx_accept_mutex_held为1，则拥有了把accept事件加入到自己的ngx_posted_accept_events的权利。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;本文主要学习了nginx连接accept的步骤，以及nginx的负载均衡的方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx的事件主体分析</title>
    <link href="http://yikun.github.io/2014/03/26/nginxevent/"/>
    <id>http://yikun.github.io/2014/03/26/nginxevent/</id>
    <published>2014-03-26T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>在上篇文章中，介绍了事件模块的初始化工作，其中ngx_event_process_init会调用module-&gt;actions.init(对应epoll为ngx_epoll_init)，该步调用的是epoll的初始化函数，之后，将rev的回调函数指向ngx_event_accept函数，这样便会accept新的链接。那么，本文将以epoll为例，来学习一下事件机制的主体。<br><a id="more"></a></p><h3 id="2-事件主体"><a href="#2-事件主体" class="headerlink" title="2. 事件主体"></a>2. 事件主体</h3><p>我们的重点还是放在ngx_worker_process_cycle，处理事件的核心则是ngx_process_events_and_timers，其基本机制如下图所示，<br><img src="/assets/post/2014-03-26-nginxevent/nginx_epoll.png" alt="eventcore"></p><p>在ngx_worker_process_cycle最开始的初始化中，epoll模块会调用epoll_creat初始化，之后便进入事件的循环中，然后epoll_wait有事件就加入到队列中，然后集中处理，如果拿到锁了就可以处理accept的事件，然后处理完accept后就解锁，之后再去处理普通读写事件。</p><p>事件的主循环主要分为三步</p><p>1.调用ngx_process_events。</p><pre><code>#define ngx_process_events   ngx_event_actions.process_events</code></pre><p>而对于epoll来说就是调用ngx_epoll_process_events函数。</p><p>2.调用ngx_event_process_posted处理事件队列中的事件。</p><p>ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);<br>ngx_event_process_posted(cycle, &amp;ngx_posted_events);<br>我们可以看见处理的网络事件主要牵扯到2个队列，一个是ngx_posted_accept_events，另一个是ngx_posted_events。其中，一个队列用于放accept的事件，另一个则是普通的读写事件；<br>ngx_event_process_posted会处理事件队列，其实就是调用每个事件的回调函数，然后再让这个事件出队。<br>例如，我们在开始的时候，已经把accept事件的回调函数指定为ngx_event_accept，那么当处理accept事件的时候便会调用这个函数。</p><p>我么可以看到，每个worker进程先抢锁，抢到锁的worker就获得所有监听的事件，这个worker来“接待”新的”accept”，当接待完ngx_posted_accept_events队列里面的连接后，就解锁。没拿到锁的，会更频繁的拿锁。最终实现了负载均衡。</p><p>3.处理定时器事件。</p><p>以上便是整个事件机制的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;在上篇文章中，介绍了事件模块的初始化工作，其中ngx_event_process_init会调用module-&amp;gt;actions.init(对应epoll为ngx_epoll_init)，该步调用的是epoll的初始化函数，之后，将rev的回调函数指向ngx_event_accept函数，这样便会accept新的链接。那么，本文将以epoll为例，来学习一下事件机制的主体。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx的事件初始化与框架</title>
    <link href="http://yikun.github.io/2014/03/21/nginxeventinit/"/>
    <id>http://yikun.github.io/2014/03/21/nginxeventinit/</id>
    <published>2014-03-21T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>因为开始对nginx的模块机制不是很了解，所以开始看事件模块的这部分还是云里来，雾里去的，最后，算是理清了，我觉得应该抓几个核心的数据结构，无论是初始化，还是在事件循环中，都和这些数据结构息息相关。我们需要抓住这两个结构体，搞清楚他们在什么时候初始化，什么时候起作用，这样就可以理清大概的<br><a id="more"></a><br>nginx的事件机制最重要的牵扯到几个结构体，当然niginx的事件的初始化也围绕着这几个模块进行。</p><h3 id="2-事件模块配置的初始化"><a href="#2-事件模块配置的初始化" class="headerlink" title="2. 事件模块配置的初始化"></a>2. 事件模块配置的初始化</h3><p>事件模块配置的初始化，主要是所有事件模块的配置创建与初始化的过程，与事件模块息息相关的是ngx_events_module结构体，定义了对<code>events</code>的“兴趣”，以及初始化events的回调函数ngx_events_block。</p><p>首先，最重要的结构体是</p><pre><code>ngx_module_t  ngx_events_module = {    NGX_MODULE_V1,    &amp;ngx_events_module_ctx,                /* module context */    ngx_events_commands,                   /* module directives */    NGX_CORE_MODULE,                       /* module type */    NULL,                                  /* init master */    NULL,                                  /* init module */    NULL,                                  /* init process */    NULL,                                  /* init thread */    NULL,                                  /* exit thread */    NULL,                                  /* exit process */    NULL,                                  /* exit master */    NGX_MODULE_V1_PADDING};</code></pre><p>该结构提为nginx的核心模块(NGX_CORE_MODULE)，主要用于events配置的解析，那么初始化的时候围绕着这个结构体进行的当然也便是配置解析的相关工作了。</p><p>其次，这个模块还需要管理所有时间模块的配置，最后还有就是对各个事件模块的配置进行统一管理。</p><pre><code>static ngx_command_t  ngx_events_commands[] = {    { ngx_string(&quot;events&quot;),      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,      ngx_events_block,      0,      0,      NULL },      ngx_null_command};static ngx_core_module_t  ngx_events_module_ctx = {    ngx_string(&quot;events&quot;),    NULL,    ngx_event_init_conf};</code></pre><p>然后再看看<code>ngx_events_module</code>的内容，主要牵扯到的变量有<code>ngx_events_commands</code>、<code>ngx_events_module_ctx</code>，<br><code>ngx_events_commands</code>可以理解为告诉解析conf，解析到什么指令，调用什么函数，比如这里就是解析到<code>events</code>指令调用<code>ngx_events_block</code>函数。<br><code>ngx_events_module_ctx</code>则是核心模块提供给各种模块实现时提供的接口，事件模块作为核心模块，也需要实现这个接口。</p><p>也就是说除了配置文件解析之外，这个模块没有做任何其他事情，让我们来关注一下<code>ngx_events_block</code>。</p><p>之前的文章有介绍过nginx的初始化过程，在初始化的时候，会调用ngx_init_cycle函数，而该函数会调用ngx_conf_parse，其中ngx_conf_parse会完成对<code>ngx_events_block</code>的调用，具体是怎么样调用的在以后再学习配置解析的时候再分析。现在只需要知道ngx_events_block调用时机是在ngx_conf_parse的时候就勾勒，重点看下ngx_events_block的实现，ngx_events_block执行过程如图所示，</p><p><img src="/assets/post/2014-03-21-nginxeventinit/ngx_events_block.png" alt="nginx_channel"></p><p>下面将这五步详细介绍一下，</p><p>1.对事件模块进行标号。首先在ngx_modules[i]数组里面找到<code>NGX_EVENT_MODULE</code>的变量，之后对每一个事件模块进行标号，也就是说ctx_index表示在相同类型模块中的标号。例如此处的就表示在所有事件模块中的标号。ngx_modules则是一个全局数组，位于<code>obj/ngx_modules.c</code>目录，存储着所有的模块信息。</p><pre><code>ngx_event_max_module = 0;for (i = 0; ngx_modules[i]; i++) {    if (ngx_modules[i]-&gt;type != NGX_EVENT_MODULE) {        continue;    }    ngx_modules[i]-&gt;ctx_index = ngx_event_max_module++;}</code></pre><p>2.为事件模块的配置分配空间。其次便是给事件模块配置的指针及配置所存储的指针数组分配空间。</p><pre><code>//开辟红色部分空间ctx = ngx_pcalloc(cf-&gt;pool, sizeof(void *));if (ctx == NULL) {    return NGX_CONF_ERROR;}//开辟蓝色部分空间*ctx = ngx_pcalloc(cf-&gt;pool, ngx_event_max_module * sizeof(void *));if (*ctx == NULL) {    return NGX_CONF_ERROR;}</code></pre><p>在ngx_cycle_t中有一个conf的四级指针(conf_ctx)。它指向了一个指针数组A(存储着所有核心模块配置结构体指针)，A中的指针又指向了另一个指针数组B(假设A中的这个指针是事件模块配置结构体的指针)，那么B中就存着事件模块的配置。如图所示</p><p><img src="/assets/post/2014-03-21-nginxeventinit/nginx_module_conf.png" alt="nginx_channel"></p><p>3.对每个事件模块create_conf, 调用每个事件模块中的create_conf方法，m现在指向的就是每个模块的配置内容(即ctx, context，上下文)</p><pre><code>for (i = 0; ngx_modules[i]; i++) {    if (ngx_modules[i]-&gt;type != NGX_EVENT_MODULE) {        continue;    }    m = ngx_modules[i]-&gt;ctx;    if (m-&gt;create_conf) {        (*ctx)[ngx_modules[i]-&gt;ctx_index] = m-&gt;create_conf(cf-&gt;cycle);        if ((*ctx)[ngx_modules[i]-&gt;ctx_index] == NULL) {            return NGX_CONF_ERROR;        }    }}</code></pre><p>4.解析events中的指令。调用ngx_conf_parse解析events块中的指令。</p><p>5.对每个事件模块init_conf。调用每个事件模块中的init方法</p><pre><code>for (i = 0; ngx_modules[i]; i++) {    if (ngx_modules[i]-&gt;type != NGX_EVENT_MODULE) {        continue;    }    m = ngx_modules[i]-&gt;ctx;    if (m-&gt;init_conf) {        rv = m-&gt;init_conf(cf-&gt;cycle, (*ctx)[ngx_modules[i]-&gt;ctx_index]);        if (rv != NGX_CONF_OK) {            return rv;        }    }}</code></pre><p>完成每个conf的配置。至此，<code>ngx_events_block</code>的工作就完了，总结一下就是负责配置文件中events block的解析。</p><h3 id="3-ngx-event-core-module"><a href="#3-ngx-event-core-module" class="headerlink" title="3. ngx_event_core_module"></a>3. ngx_event_core_module</h3><p>其次，是ngx_event_core_module这个模块是一个事件类型(NGX_EVENT_MODULE)的模块</p><pre><code>ngx_module_t  ngx_event_core_module = {    NGX_MODULE_V1,    &amp;ngx_event_core_module_ctx,            /* module context */    ngx_event_core_commands,               /* module directives */    NGX_EVENT_MODULE,                      /* module type */    NULL,                                  /* init master */    ngx_event_module_init,                 /* init module */    ngx_event_process_init,                /* init process */    NULL,                                  /* init thread */    NULL,                                  /* exit thread */    NULL,                                  /* exit process */    NULL,                                  /* exit master */    NGX_MODULE_V1_PADDING};</code></pre><p>先开始，把<code>ngx_events_module</code>和<code>ngx_event_core_module</code>搞混了，因为之前没有接触过nginx的模块，现在清楚了，当看到一个模块的时候，先看module type，<code>ngx_event_core_module</code>的type是NGX_EVENT_MODULE。而比较特殊，他是NGX_EVENT_MODULE最核心的module，同样的，我们看看ngx_event_core_module的内容<br><code>ngx_event_core_commands</code> 存储着解析到”某些指令”回调”某些函数”。<br><code>ngx_event_core_module_ctx</code> 则存储着模块配置的创建与初始化函数。</p><pre><code>static ngx_command_t  ngx_event_core_commands[] = {    { ngx_string(&quot;worker_connections&quot;),      NGX_EVENT_CONF|NGX_CONF_TAKE1,      ngx_event_connections,      0,      0,      NULL },    { ngx_string(&quot;connections&quot;),      NGX_EVENT_CONF|NGX_CONF_TAKE1,      ngx_event_connections,      0,      0,      NULL },    { ngx_string(&quot;use&quot;),      NGX_EVENT_CONF|NGX_CONF_TAKE1,      ngx_event_use,      0,      0,      NULL },    { ngx_string(&quot;multi_accept&quot;),      NGX_EVENT_CONF|NGX_CONF_FLAG,      ngx_conf_set_flag_slot,      0,      offsetof(ngx_event_conf_t, multi_accept),      NULL },    { ngx_string(&quot;accept_mutex&quot;),      NGX_EVENT_CONF|NGX_CONF_FLAG,      ngx_conf_set_flag_slot,      0,      offsetof(ngx_event_conf_t, accept_mutex),      NULL },    { ngx_string(&quot;accept_mutex_delay&quot;),      NGX_EVENT_CONF|NGX_CONF_TAKE1,      ngx_conf_set_msec_slot,      0,      offsetof(ngx_event_conf_t, accept_mutex_delay),      NULL },    { ngx_string(&quot;debug_connection&quot;),      NGX_EVENT_CONF|NGX_CONF_TAKE1,      ngx_event_debug_connection,      0,      0,      NULL },      ngx_null_command};ngx_event_module_t  ngx_event_core_module_ctx = {    &amp;event_core_name,    ngx_event_core_create_conf,            /* create configuration */    ngx_event_core_init_conf,              /* init configuration */    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }};</code></pre><p>另外，ngx_event_core_module还定义了2个函数。我们来看看这两个函数的调用情况</p><pre><code>ngx_event_module_init,                 /* init module */ngx_event_process_init,                /* init process */</code></pre><p>这两个函数的调用的时机，如下图所示：</p><p><img src="/assets/post/2014-03-21-nginxeventinit/module_process_init.png" alt="nginx_channel"></p><p>ngx_event_module_init是在ngx_init_cycle被调用的，主要就是初始化模块的一些变量。</p><p>ngx_event_process_init则是在worker进程开始时被调用，之后便进入事件循环中，主要包括了负载均衡锁的初始化、定时器的初始化、连接池的初始化，以及在最后遍历所有modules来调用modules数组中的ngx_add_event函数，将事件添加到监听队列中。可以看到</p><pre><code>#define ngx_process_changes  ngx_event_actions.process_changes#define ngx_process_events   ngx_event_actions.process_events#define ngx_done_events      ngx_event_actions.done#define ngx_add_event        ngx_event_actions.add#define ngx_del_event        ngx_event_actions.del#define ngx_add_conn         ngx_event_actions.add_conn#define ngx_del_conn         ngx_event_actions.del_conn</code></pre><p>这就是nginx事件模块的精华所在，通过这样的方式，就可以使得ngx_event_actions不同，采用不同的复用机制。可以参照下图，来理解ngx_event_core_module。</p><p><img src="/assets/post/2014-03-21-nginxeventinit/nginx_core_module.png" alt="nginx_channel"></p><p>上面可以看到红色的部分是ngx_event_core_module有用的部分，需要强调的是这个事件模型只是用来初始化类似epoll的模块的，而自己是不做一些类似epoll事件循环的具体事件的。</p><p>至此，事件初始化就结束了，可以看到上面都是nginx通用的，不牵扯到具体的复用机制，后面会根据epoll来具体学习一下nginx事件循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;因为开始对nginx的模块机制不是很了解，所以开始看事件模块的这部分还是云里来，雾里去的，最后，算是理清了，我觉得应该抓几个核心的数据结构，无论是初始化，还是在事件循环中，都和这些数据结构息息相关。我们需要抓住这两个结构体，搞清楚他们在什么时候初始化，什么时候起作用，这样就可以理清大概的&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>我的vim配置</title>
    <link href="http://yikun.github.io/2014/03/19/vim/"/>
    <id>http://yikun.github.io/2014/03/19/vim/</id>
    <published>2014-03-19T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>最近把vim的配置整理的一下，然后更新到github上了。<br><a id="more"></a><br>之前一直在用vim，不过一直把他作为编辑器而已，就是写，然后:wq。最近在看nginx的代码，然后稍微归整了下vim的配置，也总结了一些有用的插件，让我阅读代码爽一些。放到github的主要目的还是为了备份，虽然插件不多，但是对我来说基本够用了。大致插件是实现的功能集中在高亮、函数列表、文件夹列表、函数跳转、代码补全、头源文件跳转、文件打开、状态栏美化。下面具体的介绍下我的配置。</p><p><img src="/assets/post/2014-03-19-vim/vim_all.png" alt="vim概览"></p><p>###我的vim插件概览###</p><p><code>pathogen.vim</code> 用于插件管理，把插件放到bundle目录就可以了。</p><p><code>Trinity.vim</code> 用于集中管理taglist、nerdtree、srcexpl三个插件，按 <code>F8</code> 就可以快速打开这三个插件了。</p><p><code>taglist.vim</code> 用于生成、展示函数列表</p><p><code>nerdtree.vim</code> 用于生成、展示目录和文件</p><p><code>srcexpl.vim</code> 用于函数的展示，当移动到函数上的之后，就会在srcexpl的窗口里面显示函数定义的。</p><p><code>CSApprox.vim</code> 这是一个vim配色的插件，我比较喜欢desert这个配色。</p><p><code>OmniCppComplete.vim</code> 用于代码补全工作，能够加快<a href="/assets/post/2014-03-19-vim/vim_omni.png">效果</a></p><p><code>a.vim</code> 用于快速切换<em>.c和</em>.h</p><p><code>ctrlp.vim</code> 用于文件的模糊搜索，能够加快打开文件的速度<a href="/assets/post/2014-03-19-vim/vim_ctrlp.png">效果</a></p><p><code>powerline.vim</code> 一个优雅的状态栏插件</p><p><code>vimgrep</code> 自带插件，用于搜索tags中匹配字符，可以查看函数调用情况<a href="/assets/post/2014-03-19-vim/vim_grep.png">效果</a></p><p>###如何使用的我的配置###</p><p>最简单的方法就是clone所有的配置到你的<code>.vim</code>目录之中，首先交代下我的vim配置方法，与vim相关的配置主要是<code>.vim</code>里的插件，一般目录位于<code>~/.vim</code>，还有vim的配置文件<code>~/.vimrc</code>，为了让配置vim更简单些，利用了<code>ln -s  ~/.vim/.vimrc ~/.vimrc</code>命令，这样，就相当于<code>～/.vimrc</code>是一个指向<code>~/.vim/.vimrc</code>的快捷方式。因此使用我的配置，也很简单。</p><p>第一步，备份。</p><pre><code># mv ~/.vim backup# mv ~/.vimrc backup</code></pre><p>第二部，复制配置。</p><pre><code># git clone git@github.com:Yikun/vim-config.git ~/.vim</code></pre><p>第三部，创建.vimrc链接</p><pre><code># ln -s ~/.vim/.vimrc ~/.vimrc</code></pre><p>这样就ok了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近把vim的配置整理的一下，然后更新到github上了。&lt;br&gt;
    
    </summary>
    
    
      <category term="vim" scheme="http://yikun.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>nginx中channel机制</title>
    <link href="http://yikun.github.io/2014/03/16/nginxchannel/"/>
    <id>http://yikun.github.io/2014/03/16/nginxchannel/</id>
    <published>2014-03-16T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p>由于nginx使用的是多进程的模型，因此，进程间的通信或者同步很重要，为什么要进行进程同步呢？我们知道，nginx有master和worker进程，在上篇文章已经分析过了master具体是怎样创建worker进程的。不过，在创建worker进程的时候，是需要对进程同步的。举个具体的例子，我们假设服务器共有4个worker进程，我们知道nginx有一个全局变量，是ngx_processes数组，他存储着所有进程的信息，在worker1创建的时候，worker2，worker3，worker4进程是没有创建的，因此，这个时候就牵扯到同步，最合理的方式是，在master创建一个进程的时候，就应该通知所有子进程有新的进程被fork了，以及这个进程的基本信息。<br><a id="more"></a><br>这个好比一个集体(由很多processes组成)，当有新的成员加入这个集体的时候，老大应该告诉大伙，有新成员进来了，他的基本信息是balabala。因此，也就引出了本文所要总结的内容，即nginx的进程通信机制。</p><h3 id="2-worker进程的创建"><a href="#2-worker进程的创建" class="headerlink" title="2. worker进程的创建"></a>2. worker进程的创建</h3><p>我们先回顾一下worker进程的创建过程，ngx_master_process_cycle -&gt; ngx_start_worker_processes，在 <code>ngx_start_worker_processes</code> 函数中，有下面的代码</p><pre><code>static voidngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t type){    ngx_int_t      i;    ngx_channel_t  ch;    ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, 0, &quot;start worker processes&quot;);    ch.command = NGX_CMD_OPEN_CHANNEL;    for (i = 0; i &lt; n; i++) {        ngx_spawn_process(cycle, ngx_worker_process_cycle,                          (void *) (intptr_t) i, &quot;worker process&quot;, type);        ch.pid = ngx_processes[ngx_process_slot].pid;        ch.slot = ngx_process_slot;        ch.fd = ngx_processes[ngx_process_slot].channel[0];        ngx_pass_open_channel(cycle, &amp;ch);    }}</code></pre><p>注意观察下， <code>ngx_channel_t</code> 结构体的定义如下：</p><pre><code>typedef struct {     ngx_uint_t  command;     ngx_pid_t   pid;     ngx_int_t   slot;     ngx_fd_t    fd;} ngx_channel_t;</code></pre><p>没错，这个就是master与worker进程通信的最重要的结构，短小精汗。</p><p>该结构封装了四个变量，分别是指令(master要worker干啥)，pid(worker的进程id)，slot(worker进程在ngx_processes的索引)，文件描述符。我们思考一下概述中的那个问题，怎么将master后创建的进程通知前面已创建的进程。 <code>ngx_pass_open_channel(cycle, &amp;ch);</code> 注意一下这个函数，没错就是它了，通过它对每个进程进行通知。</p><h3 id="3-nginx频道"><a href="#3-nginx频道" class="headerlink" title="3. nginx频道"></a>3. nginx频道</h3><p>那么具体又是怎么实现通知的呢？我们看到在 <code>ngx_channel_t</code> 中有一个 <code>ngx_fd_t    fd;</code> 这个文件描述便存储着通信的“接口”，从之前的代码我们看出来， <code>ch.fd = ngx_processes[ngx_process_slot].channel[0];</code> 这个channel[0]是真正传输的接口。那么他是什么呢？简单的说，就是master写给每个process的channel[0]一些信息(ngx_channel_t的实际内容)，worker就能在自己的channel[1]中，读取到这些信息。</p><p>nginx使用的是 <code>socketpair</code> 方法关联套接字，我们看看socketpair的原型：</p><pre><code>int socketpair(int d, int type, int protocol, int sv[2]);</code></pre><p>我们关注一下第四个参数，当这个socketpair函数执行成功后，就会生成一个socket对在数组中，sv[2]中的socket是关联起来的，什么意思呢？就是说向sv[0]写数据，在sv[1]就能读到相应的数据；相反的，在sv[1]写数据，在sv[0]也可以读到相应的数据。在master进程fork worker进程的时候，也把这个套接字传给了worker，也就是说在master向worker的sv[0]写数据，那么worker便可以在自己的sv[1]中读到数据。</p><p><img src="/assets/post/2014-03-16-nginxchannel/nginx_channel.png" alt="nginx_channel"></p><p>nginx的具体的实现方式如上图所示：<br>channel[0]和channel[0]为一对socketpair。</p><pre><code>1. 向channel[0]写数据时，可从channel[1]读数据；2. 向channel[1]写数据时，可从channel[0]读数据。</code></pre><p>而nginx，只利用了第一条，即master向channel[0]写数据时，worker可从channel[1]读数据<br>socketpair也用来进行父子进程的通信，子进程会继承父进程的资源。</p><h3 id="3-master写入与worker读取数据"><a href="#3-master写入与worker读取数据" class="headerlink" title="3. master写入与worker读取数据"></a>3. master写入与worker读取数据</h3><p>我们具体的来看下nginx写入数据的过程，</p><pre><code>ngx_write_channel(ngx_processes[i].channel[0],                          ch, sizeof(ngx_channel_t), cycle-&gt;log);</code></pre><p>和上节介绍的一样，我们看到master对每一个ngx_processes[i].channel[0]写入数据。并且写入的数据就是 <code>ngx_channel_t</code> 变量。<br>好了，既然master向worker写数据的接口有了，那么woker又怎么对master写入的数据进行读取和处理呢？</p><p>我们目光移到worker进程上面，ngx_worker_process_cycle函数，在初始化时，调用了 <code>ngx_worker_process_init</code> 函数，这个初始化函数又调用了</p><pre><code>ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT,ngx_channel_handler)</code></pre><p>这个就利用了nginx强大的事件机制，这个函数大概的功能就是，如果worker channel[1]有可读的数据，便会调用  <code>ngx_channel_handler</code>  进行处理。</p><pre><code>switch (ch.command) {case NGX_CMD_QUIT:    ngx_quit = 1;    break;case NGX_CMD_TERMINATE:    ngx_terminate = 1;    break;case NGX_CMD_REOPEN:    ngx_reopen = 1;    break;case NGX_CMD_OPEN_CHANNEL:    ...    ngx_processes[ch.slot].pid = ch.pid;    ngx_processes[ch.slot].channel[0] = ch.fd;    break;case NGX_CMD_CLOSE_CHANNEL:    ...    if (close(ngx_processes[ch.slot].channel[0]) == -1) {        ngx_log_error(NGX_LOG_ALERT, ev-&gt;log, ngx_errno,                      &quot;close() channel failed&quot;);    }    ngx_processes[ch.slot].channel[0] = -1;    break;case NGX_CMD_PIPE_BROKEN:    ngx_pipe_broken_action(ev-&gt;log, ch.pid, 0);    break;}</code></pre><p>由于nginx目前的读写数据只是单向的即mater–&gt;worker，因此，这些指令的解析，都是需要让worker做一些事儿。我们可以关注一下 <code>NGX_CMD_OPEN_CHANNEL</code> 这个分支。在ngx_start_worker_processes函数中，master就向worker写入了 <code>NGX_CMD_OPEN_CHANNEL</code> 指令。</p><p>那么worker进程，便根据这个 <code>ngx_channel_t ch</code> 信息，更新processes数组。这样便完成了进程的同步。</p><h3 id="4-nginx中channel指令"><a href="#4-nginx中channel指令" class="headerlink" title="4. nginx中channel指令"></a>4. nginx中channel指令</h3><p>我们发现，ngx_channel_handler中共有6个指令类型，分别是NGX_CMD_QUIT、NGX_CMD_TERMINATE、NGX_CMD_REOPEN、NGX_CMD_OPEN_CHANNEL、NGX_CMD_CLOSE_CHANNEL、NGX_CMD_PIPE_BROKEN。下面我们分析下，和channel相关的命令。</p><p><code>NGX_CMD_OPEN_CHANNEL</code><br>之前，我们已经分析了NGX_CMD_OPEN_CHANNEL信号的解析大致过程，现在仔细观察一下，我先搜索了一下使用<code>NGX_CMD_OPEN_CHANNEL</code>命令的地方，对<code>ch.command</code>赋值的地方有四处。第一处是用于worker进程的，第二、三处是和cache manager进程有关的，暂不关注，第四处，是<code>ngx_reap_children</code>主要是用于nginx重启后，重新开启channel的。</p><p>我们只分析第一处，master进程的函数<code>ngx_start_worker_processes</code> 在开启worker进程的时候，把命令设置为<code>NGX_CMD_OPEN_CHANNEL</code>，并且通过<code>ngx_write_channel</code>把指令给相应的进程，这样当worker进程解析这个消息时，便根据新进程的slot把新进程的信息(新进程的pid、新进程的channel[0])保存起来。<br><img src="/assets/post/2014-03-16-nginxchannel/nginx_open_channel.png" alt="nginx_open_channel"></p><p>上图已经表明了<code>NGX_CMD_OPEN_CHANNEL</code>的传递与生效过程。<br>分为2个部分</p><ol><li>Master部分。<br> 第一步，由Master进程创建socket pair，即创建channel，利用socketpair函数，master进程processes数组中存储了master与新的work的channel信息。<br> 第二步，2. Fork的子进程会继承父进程，Fork子进程，利用fork函数，子进程会继承父进程的资源。<br> 第三步，3. 利用ngx_pass_open_channel向各进程发送NGX_CMD_OPEN_CHANNEL，通知其他进程信息更新。<br>2.Worker部分。<br> 第一步，关闭除自己以外的channel[1]。<br> 第二步，关闭自己的channel[0]。</li></ol><p>总结一下，这个命令就是告诉worker，有新的进程来，他OPEN_CHANNEL了，你得存起来，然后worker就存这个新进程的信息了，当然这个信息是存在processes数组里了。</p><p><code>NGX_CMD_CLOSE_CHANNEL</code><br>当然，与打开对应的就是关闭channel指令了，与这个命令相关的赋值只有一处，就是<code>ngx_reap_children</code>，当然就是master向每个进程更新信息，如果发现某个进程exited了，就告诉大家，可以把它的channel关闭了，即把这个channel的flag置为-1。而关闭的时候，<code>close(ngx_processes[ch.slot].channel[0])</code>关闭了channel[0]，先开始有疑问了，为什么只关0呢？1怎么办？原来1其实在work刚开始的时候就关闭了，即最开始就已经“关闭了除了自己外的channel[1]，然后再关闭自己的channel[0]。</p><p>总结一下，这个命令就是告诉work，你要关闭这个CHANNEL了，原因从目前的nginx代码来看，只有一个，就是需要重启。关闭已经exited的进程的channel。</p><p>不过，有些疑问，</p><p>1.目前来看只有master向worker的消息，不存在worker向master，或者worker向worker写了，那么为什么不关闭其他worker的channel[0]呢？我觉得可能是不是和cache load进程有关，后面再思考一下。</p><p>2.为什么master中要保留所有子进程channel[1]？可以在fork完子进程，就关闭，为什么不关闭呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h3&gt;&lt;p&gt;由于nginx使用的是多进程的模型，因此，进程间的通信或者同步很重要，为什么要进行进程同步呢？我们知道，nginx有master和worker进程，在上篇文章已经分析过了master具体是怎样创建worker进程的。不过，在创建worker进程的时候，是需要对进程同步的。举个具体的例子，我们假设服务器共有4个worker进程，我们知道nginx有一个全局变量，是ngx_processes数组，他存储着所有进程的信息，在worker1创建的时候，worker2，worker3，worker4进程是没有创建的，因此，这个时候就牵扯到同步，最合理的方式是，在master创建一个进程的时候，就应该通知所有子进程有新的进程被fork了，以及这个进程的基本信息。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx启动流程分析</title>
    <link href="http://yikun.github.io/2014/03/13/nginxstart/"/>
    <id>http://yikun.github.io/2014/03/13/nginxstart/</id>
    <published>2014-03-13T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近，开始学习nginx的代码，大致根据<a href="http://www.alidata.org/archives/category/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">阿里数据平台</a>的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框架和主要工作流程。<br><a id="more"></a><br>如下图所示，为总的启动流程分析，后面是我对每个部分的总结和分析<br><img src="/assets/post/2014-03-13-nginxstart/nginx_start.png" alt="启动流程分析"></p><h3 id="1-解析命令参数"><a href="#1-解析命令参数" class="headerlink" title="1. 解析命令参数"></a>1. 解析命令参数</h3><p>nginx是由C语言写成的，因此，从main函数开始开启我们的“旅程”，传入参数为argc，还有argv，最开始的任务当然就是解析它们了，以获得用户启动的参数，调用ngx_get_options解析参数，一般情况，Linux的解析命令参数都会调用getopt之类的系统函数，而nginx却没有，应该是考虑到了跨平台性。解析命令参数的代码比较简单，大致的工作就是标记flag，类似ngx_show_version，ngx_show_modules的全局参数可以记录命令参数。<br>而后，根据这些flag来做一些事情，例如使用nginx -h，会将ngx_show_version，ngx_show_help置为有效(1)，然后后面回到main后，就是做一些对应的输出。</p><h3 id="2-初始化工作"><a href="#2-初始化工作" class="headerlink" title="2. 初始化工作"></a>2. 初始化工作</h3><p>包括了time、regex、log、ssl等初始化，而后进行一个很重要的结构的初始化ngx_cycle。</p><pre><code>struct ngx_cycle_s {    void                  ****conf_ctx;                        //配置上下文数组(含所有模块)    ngx_pool_t               *pool;                        //内存池    ngx_log_t                *log;                        //日志    ngx_log_t                 new_log;    ngx_connection_t        **files;                        //连接文件    ngx_connection_t         *free_connections;                    //空闲连接    ngx_uint_t                free_connection_n;                //空闲连接个数    ngx_queue_t               reusable_connections_queue;            //再利用连接队列    ngx_array_t               listening;                    //监听数组    ngx_array_t               paths;                        //路径数组    ngx_list_t                open_files;                    //打开文件链表    ngx_list_t                shared_memory;                    //共享内存链表    ngx_uint_t                connection_n;                    //连接个数    ngx_uint_t                files_n;                        //打开文件个数    ngx_connection_t         *connections;                    //连接    ngx_event_t              *read_events;                    //读事件    ngx_event_t              *write_events;                    //写事件    ngx_cycle_t              *old_cycle;                    //old cycle指针    ngx_str_t                 conf_file;                    //配置文件    ngx_str_t                 conf_param;                    //配置参数    ngx_str_t                 conf_prefix;                    //配置前缀    ngx_str_t                 prefix;                        //前缀    ngx_str_t                 lock_file;                    //锁文件    ngx_str_t                 hostname;                        //主机名};</code></pre><p>ngx_init_cycle的过程的详细情况可以参考<a href="http://www.alidata.org/archives/1148" target="_blank" rel="noopener">Nginx启动初始化过程(二)</a>。因为现在功力不是很深，等以后对nginx有透彻了解后，再仔细分析。这里第一次出现了内存池的操作，后面重点分析一下内存池的实现。</p><hr><h3 id="3-信号处理的初始化"><a href="#3-信号处理的初始化" class="headerlink" title="3. 信号处理的初始化"></a>3. 信号处理的初始化</h3><p>ngx_init_signals会进行信号处理的初始化，signals是一个结构体数组，存储着各种信号的结构体，在初始化的过程中，会利用sigaction函数对每个信号进行设置，如下所示，主要是对signo和handler回调函数进行设置。初始化成功以后，当信号产生以后，便可以调用信号处理函数了，因此可以利用ngx_signal_handler进行信号处理了。</p><pre><code>ngx_int_tngx_init_signals(ngx_log_t *log){    ngx_signal_t      *sig;    struct sigaction   sa;    for (sig = signals; sig-&gt;signo != 0; sig++) {        ngx_memzero(&amp;sa, sizeof(struct sigaction));        sa.sa_handler = sig-&gt;handler;        sigemptyset(&amp;sa.sa_mask);        if (sigaction(sig-&gt;signo, &amp;sa, NULL) == -1) {            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,                          &quot;sigaction(%s) failed&quot;, sig-&gt;signame);            return NGX_ERROR;        }    }    return NGX_OK;}</code></pre><h3 id="4-守护进程"><a href="#4-守护进程" class="headerlink" title="4. 守护进程"></a>4. 守护进程</h3><p>在启动过程中，会调用ngx_daemon(cycle-&gt;log)，这个函数实现的很经典。</p><pre><code>ngx_int_tngx_daemon(ngx_log_t *log){    int  fd;    //父进程fork    switch (fork()) {    //fork执行完后，master的    case -1:        //fork出错了        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;fork() failed&quot;);        return NGX_ERROR;    case 0:        //master daemon(子进程)什么也不做        break;    default:        //master前台进程(父进程)退出，以给控制终端一个“假象”，这个程序执行完了        exit(0);    }    /*    执行到这，说明最开始的“前台”进程已经退出了，这时得刷新下ngx_pid，以便后面ngx_create_pidfile用(用来优雅的重启)    当然，有人问为什么main最开始就记录了，ngx_pid呢？那是因为nginx不一定会daemon形式启动，这样开始的进程就是master    然而在这里，nginx将原来的前台master exit掉，然后master fork出来的，所以这里的ngx_pid就是就是daemon master的了。    */    ngx_pid = ngx_getpid();    /*    作为daemon只fork还是不够的，需要第二步，setsid，他的作用是让daemon成为真正的daemon    1.会话组的老大; 2.进程组的老大; 3.不受任何控制终端控制    */    if (setsid() == -1) {        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;setsid() failed&quot;);        return NGX_ERROR;    }    //umask(0)是为了让读写权限保持原来的状态    umask(0);    //后面几句就是把STD的输入/输出/错误都输出到/dev/null，也就是什么也不输出    fd = open(&quot;/dev/null&quot;, O_RDWR);    if (fd == -1) {        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno,                      &quot;open(\&quot;/dev/null\&quot;) failed&quot;);        return NGX_ERROR;    }    if (dup2(fd, STDIN_FILENO) == -1) {        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;dup2(STDIN) failed&quot;);        return NGX_ERROR;    }    if (dup2(fd, STDOUT_FILENO) == -1) {        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;dup2(STDOUT) failed&quot;);        return NGX_ERROR;    }#if 0    if (dup2(fd, STDERR_FILENO) == -1) {        ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;dup2(STDERR) failed&quot;);        return NGX_ERROR;    }#endif    if (fd &gt; STDERR_FILENO) {        if (close(fd) == -1) {            ngx_log_error(NGX_LOG_EMERG, log, ngx_errno, &quot;close() failed&quot;);            return NGX_ERROR;        }    }    return NGX_OK;}</code></pre><p>守护进程指的是后台运行不与任何控制终端相联的进程，许多网络服务器都作为守护进程运行。那么，什么样的进程才是守护进程呢？2种方法:</p><pre><code>1. 这个进程是“富二代“，由内核无终端启动;2. 是靠自己后天努力，这个后天努力需要借助setid的帮助，新建一个会话，这样这个进程就成老大了，而且不受任何终端控制。</code></pre><p>注释已经写的很详细了，总结一下就是以下几步。</p><pre><code>1. fork一个daemon进程，退出前台进程。2. setsid 让daemon彻底脱离控制终端（如果没用这步的话，就会造成终端一退出，进程也就退了）3. umask(0)4. 不让他输入输出5. 改变目录，避免父进程工作目录的影响（nginx没做）6. 关闭没用的fd</code></pre><p>这个是APUE中提到的6步。当然，也有人建议进行第二次fork，二次fork的原因是不让进程重新被终端控制。是这样的，如果一个进程是一个不属于任何一个终端的会话组的首进程，当这个进程打开终端的时候，系统就会为他分配一个终端，这样就惨了，它又要受终端控制了(一个会话组的首进程如果不属于任何终端，则该进程打开终端时会被分配终端，一个会话如果属于某个终端，就会有一个前台进程组)，也就做不成守护进程了。不过要是二次fork的话，daemon A fork 出来 daemon B，这个daemon B不是会话首进程，就不会被分配到终端控制了。但是nginx没做，我觉得可能是因为nginx不会作类似操作吧。<br>注：不过2次fork，要记得Sighnal(SIG_HUP, SIG_IGN)，否则daemon A作为首进程退出的时候，会告诉所有的小弟(包括B了)。</p><p>具体的守护进程参考UNP和APUE中的资料。</p><h3 id="5-ngx-master-process-cycle，mater干的活"><a href="#5-ngx-master-process-cycle，mater干的活" class="headerlink" title="5. ngx_master_process_cycle，mater干的活"></a>5. ngx_master_process_cycle，mater干的活</h3><p>在完成main中的初始化后，我们的“初始化”旅程到了结尾，热身结束，开始重点。到调用这个函数的时候，nginx还是只有master进程的，作为master进程的开始工作，最终要的就是启动“work”进程。其实，很多软件都有master，work的概念，诸如Hadoop的jobtracker、tasktracker。master处理和用户的交互，然后work专心的去做业务，这样的话，master可以想象为一个管理者，work则是真正的工人。</p><p>屏蔽一下干扰</p><pre><code>sigemptyset(&amp;set);sigaddset(&amp;set, SIGCHLD);sigaddset(&amp;set, SIGALRM);sigaddset(&amp;set, SIGIO);sigaddset(&amp;set, SIGINT);sigaddset(&amp;set, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));sigaddset(&amp;set, ngx_signal_value(NGX_REOPEN_SIGNAL));sigaddset(&amp;set, ngx_signal_value(NGX_NOACCEPT_SIGNAL));sigaddset(&amp;set, ngx_signal_value(NGX_TERMINATE_SIGNAL));sigaddset(&amp;set, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));sigaddset(&amp;set, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));if (sigprocmask(SIG_BLOCK, &amp;set, NULL) == -1) {    ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,                  &quot;sigprocmask() failed&quot;);}sigemptyset(&amp;set);</code></pre><p>最开始的工作就是做一些信号处理的工作，首先将系统信号，nginx自定义的信号加入’sigset_t set;’信号集中，然后调用sigprocmask进行信号的屏蔽，函数为 ‘sigprocmask(SIG_BLOCK, &amp;set, NULL)’ ，第一个参数为SIG_BLOCK意思就是按照set屏蔽信号，也就是说把之前通过 ‘sigaddset’ 的10个信号都屏蔽掉了，以防止在fork Work的过程中发生的意外。</p><h3 id="6-master开始工作"><a href="#6-master开始工作" class="headerlink" title="6. master开始工作"></a>6. master开始工作</h3><p>master进程在屏蔽完信号干扰后，便调用了ngx_start_worker_processes来启动worker进程，这个函数的核心就是一个for循环，调用ccf-&gt;worker_processes次ngx_spawn_process函数，fork了ccf-&gt;worker_processes个worker。</p><p>ngx_spawn_process则是真正fork worker的函数。</p><pre><code>pid = fork();switch (pid) {case -1:    ngx_log_error(NGX_LOG_ALERT, cycle-&gt;log, ngx_errno,                  &quot;fork() failed while spawning \&quot;%s\&quot;&quot;, name);    ngx_close_channel(ngx_processes[s].channel, cycle-&gt;log);    return NGX_INVALID_PID;case 0:    ngx_pid = ngx_getpid();    proc(cycle, data);    break;default:    break;}</code></pre><p>又是熟悉的fork了，能进入case 0的就是worker进程。而master进程则继续ngx_master_process_cycle，在worker都被master fork出来之后，master就要正常开始他的工作了</p><pre><code>for ( ;; ) {// ...     sigsuspend(&amp;set);// ...}</code></pre><p>这个就是master的工作框架，简单吧？就是休眠，等信号，做事儿，再休眠，等信号，做事儿。sigsuspend(&amp;set);就是让进程休眠，直到有信号的时候，去处理。</p><p>在main开始初始化的时候，就通过’ngx_init_signals’对每个信号的回调函数进行<a href="./#siginit">初始化</a>，也就是说，每次信号来了都会调用 ‘ngx_signal_handler’ 去设全局的flag，如果有信号了，master的 ‘ngx_master_process_cycle’ 就会对这些全局flag进行对应的处理。</p><p>最后，总结一下master的工作，就是先把信号都屏蔽了，然后去fork worker进程，fork完work以后，master就进入信号处理的循环了，利用sigsuspend等信号，等到信号就处理，处理完了再sigsusoend，如此循环，完成伟大的幕后工作。</p><h3 id="7-ngx-worker-process-cycle，worker开始工作"><a href="#7-ngx-worker-process-cycle，worker开始工作" class="headerlink" title="7. ngx_worker_process_cycle，worker开始工作"></a>7. ngx_worker_process_cycle，worker开始工作</h3><p>worker开始工作的真正时候，应该是在master调用ngx_spawn_process之后的，master传入的proc参数就是ngx_worker_process_cycle函数指针，再回到刚才master中那个fork的过程，case 0的时候调用了proc(cycle, data);也就是相当与调用了ngx_worker_process_cycle，这样worker的工作也马不停蹄的开始了。</p><p>首先，惯例，进行初始化，ngx_worker_process_init，这里面就包括了自身的初始化，还有去除一下从master过来的没用的东西，比如sigprocmask一下，把之前master的屏蔽掉信号都开启了。这样，才能对master的信号进行处理，以便完成master和work的进程间的通信。</p><p>然后就开始真正的工作了，也是一个大循环。</p><pre><code>for ( ;; ) {// ...     ngx_process_events_and_timers(cycle)// ...}</code></pre><p>到此worker的框架也就这样了，然后for循环的底部会有一些对master发来的信号的处理。</p><p>至此，master和worker的初始化工作以及基本的框架算是完了，经过上面的学习以后，发现对nginx的整个流程有了一个大概的认识。学习初始化的过程中，我学到了daemon，多进程，信号处理等基本知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;最近，开始学习nginx的代码，大致根据&lt;a href=&quot;http://www.alidata.org/archives/category/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里数据平台&lt;/a&gt;的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框架和主要工作流程。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>JNI调试方法</title>
    <link href="http://yikun.github.io/2013/02/27/gdb-record/"/>
    <id>http://yikun.github.io/2013/02/27/gdb-record/</id>
    <published>2013-02-27T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Remote-Debug-jni-Code"><a href="#Remote-Debug-jni-Code" class="headerlink" title="Remote Debug jni Code"></a>Remote Debug jni Code</h2><a id="more"></a><p>1.Start your java application, set the breakpoint in java before call jni function</p><pre><code>java -Xdebug -Xrunjdwp:transport=dt_socket,address=6666,server=y,suspend=y com.kero.test.HelloJNI</code></pre><p>2.Look up the pid using top, ps, …</p><pre><code>ps -ef |grep com.kero.test.HelloJNI</code></pre><p>3.Start gdb with this pid</p><pre><code>gdb -p pidnum</code></pre><p>or<br>    gdb -p $(ps -ef |grep com.kero.test.HelloJNI |grep -v ‘grep’|awk ‘{print $2}’)</p><p>4.Attach your program code</p><pre><code>dir XXX/HelloJNI/</code></pre><p>5.Debug as usual using gdb</p><pre><code>b function_name_XXX</code></pre><p>6.Continue in java</p><p>Now, you will it will stop in c code where you set breakpoint.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Remote-Debug-jni-Code&quot;&gt;&lt;a href=&quot;#Remote-Debug-jni-Code&quot; class=&quot;headerlink&quot; title=&quot;Remote Debug jni Code&quot;&gt;&lt;/a&gt;Remote Debug jni Code&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>岁月如梭, 我的2012</title>
    <link href="http://yikun.github.io/2012/12/27/2012Conclusion/"/>
    <id>http://yikun.github.io/2012/12/27/2012Conclusion/</id>
    <published>2012-12-27T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.864Z</updated>
    
    <content type="html"><![CDATA[<p>又是一年岁末时，2012对我来说，确实算是比较“丰满”的一年。从年初的嵌入式培训，到上半年的比赛准备，中间还夹杂着高密度的期末考试，国创的结题答辩，之后，去上海的正式比赛，回来之后保研的事情，一直到最后的实习。这一年，算是成长最快以及收获最多的一年，就按照顺序一一道来吧。<br><a id="more"></a></p><h3 id="年初的嵌入式培训"><a href="#年初的嵌入式培训" class="headerlink" title="年初的嵌入式培训"></a><strong>年初的嵌入式培训</strong></h3><p>说实话，嵌入式比赛应该是我准备的最充分的也是最重视的比赛，首先这个比赛也算是大学阶段的最后一次了，其次比赛的结果也会是间接影响我未来的走向：工作还是上研。年初，记得很清楚，初十，校队的12人就已经全部到老校区开始了培训。我们住在留学生的宿舍，那宿舍旧的我们无语凝咽了，除了暖气，没有一样符合这个时代的特征，就是那种五六十年代的楼层。实验室的条件还算好，本来在主楼，最后到新科技楼付老师的实验室去了。每天的内容就是：想题目。想完题目，PPT答辩，老师点评，1-2天一个循环。那时候真是感觉自己的创意都被挖干净了，而且我们大家总是进入了怪圈，3D投影，虚拟现实，感觉还是限制在往届的思路中。时间过的很快，马上就开学了，题目基本还是没怎么完全定下。</p><h3 id="嵌入式比赛进行时"><a href="#嵌入式比赛进行时" class="headerlink" title="嵌入式比赛进行时"></a><strong>嵌入式比赛进行时</strong></h3><p>到了开学，3月份去了一次上海，把平台拿回来的之后，基本上大家都住在新校区的实验室了，F520，估计一辈子也不会忘记这个实验室吧。每天的生活就是实验室和餐厅的两点一线，为什么没有宿舍？因为我们已经都扎根实验室了，在实验室买了气垫床，因为有空调的原因还是在实验室过的比较惬意，至少在夏天酷暑之时，免去了大汗淋漓的痛苦。晚上2点多睡，早上不到8点就起，其实我们也不想起那么早，因为实验室有女生啊，女生都是不熬夜的但是早起的生活规律的学霸呀，记得有次比较夸张，看到太阳从工训中心快升起來了，赶紧睡觉了，可过了一会，刚升起来了，女生来了，我们就都起来了。</p><p>那时候特别好玩，我和君朋，雨舟起床的时候都是不会互相叫的，我是觉得晚上睡得挺晚的，大家都听辛苦的，自己起来就多干点活吧。另外，因为夏天大家也就光穿一件就睡了，往往早上起来女生进来的时候，那就是个春光乍泄的景色。有时候也互相拍个照片留个“纪念”。所以，这样一来，大家都把闹铃弄得早于女生进实验室。可是君朋大神的闹钟总是叫不起他，一般情况下就是，他的闹钟把我们都叫起来了，然后我们把他闹钟关了。然后君朋起来的时候，总是睡意朦胧的问我，几点起的？我说，女生来之前……然后君朋看看我，不说话了。哈哈哈哈。</p><p>晚上睡的最晚的是子兼大神，他是信安那边的，比我们低一级，基本上就是不睡，然后在我们睡觉的时候，总能听见他在骂着什么，基本上也就一个字“艹”，估摸着是bug卡住了吧。我和君朋就叫他“艹艹哥”了。嵌入式的几组里面，进展最快的应该是谢老师的那一组，谢老师给他们安排的比较紧，一步一步，到最后也就比较规律了，不像我们，像没头苍蝇一样撞来去，云阳不停地调飞控，我们背后就是四轴飞行器螺旋桨不停地旋转，只有我们一组算是基本上纯软件的项目，所以，当时是真心比较心虚，毕竟别的组的实物都摆出来了，我们还是干巴巴的代码，图形都没有做好最后渲染，确实有点急了，君朋的FPGA的弄的也特别紊乱，还好有之前君朋做过FPGA的东西，也算是慢慢地有些进展了。</p><p>比赛中夹杂着高密度的期末考试，合起来大概有快10门课，那时候也顾不上那么多了，毕竟还是把比赛放在第一位了，基本上就是上午考的复习一晚上，下午考的复习一上午。不过还算是比较理想，至少还都在80左右。对于我这种在成绩上没什么打要求的来说，已经不错了。这时候就大概5月份了，5月的时候又有一件比较重要的事情就是国家大学生创新性实验计划的结题。</p><h3 id="国创项目结题答辩"><a href="#国创项目结题答辩" class="headerlink" title="国创项目结题答辩"></a><strong>国创项目结题答辩</strong></h3><p>因为之前就想到过会遇到这个情况，所以，在年初的时候，就和DC说好，把服务器做好，然后，我这边Android端也基本上没什么问题了，大概3月多就基本全部搞定了。之前，中期答辩的时候得的是优，所以也没什么大的压力，所以感觉我作为负责人还是安排的比较合理的，嘿嘿。到后面就是写写结题报告，然后就答辩了。答辩的时候很幸运的进了复赛，最后的成绩还不错，第六名，如果提前一名，就可以有一个保研资格，谢胖也就不用现在苦逼的去考研了。话说回来，也快到考研了， 倒计时也是个位数，希望付出都有收获吧。</p><h3 id="The-Trip-of-Shanghai"><a href="#The-Trip-of-Shanghai" class="headerlink" title="The Trip of Shanghai"></a><strong>The Trip of Shanghai</strong></h3><p>7月中旬的时候，就去上海了，票不好买，学校坑爹的定的硬座，付老师和任老师和我们一起，累死了快到宾馆，到了宾馆也没怎么休息，中午吃了饭，就赶紧收拾收拾调试平台了，然后雨舟去抽签了，付老师带队去的，付老师走前说了一句话：要是抽到明天，也就别睡了，直接通宵准备答辩吧。突然，我心中就有种不详的预感，雨舟大神总是一个充满着惊喜的人物。</p><p>果不起然，雨舟大神没让我们失望，第二天早上第三队！跪了。然后就开始准备，到晚上11点多的时候，在付老师的房间，来了一次四个队伍的整体模拟答辩，然后就1点多了，我们回到自己的房间，按着老师的意思修改了下，就准备睡了，实在困的不行了，一个电话想起，老师说凌晨2点半的时候再过去答辩一次。我们回到自己的房间，我检查了下，软件和驱动部分没问题，然后君朋就开始调手势的指环了，我就在改ppt。<br>突然，君朋告诉我FPGA坏了，我靠，我当时那是一身冷汗啊，跪的心都有了，脑海里呈现的就是3、4个月的辛苦白费了，不过我还是比较镇定的说，再检查一下，看看有啥问题，其实心中早已经是翻江倒海了。君朋把所有线都拔了，我说你重新插一下，看看是不是短路了。之后，把程序重新烧了一遍就好了。我那个心呀，终于放下了，也基本不困了，真心是吓清醒了。</p><p>然后最后一次答辩老师就比较细致了，包括应该怎么修改怎么注意细节。最后主要是一些鼓励我们的话，然后就四点快五点了，我们的ppt还算比较好没什么大的修改，付老师那组的ppt听说是谢老师跟他们改的通宵。我回去，君朋先睡半小时，说我改好ppt就叫他，我改好ppt大概就5点多了，看着君朋睡的香，我都不忍心叫他了，哈哈。没办法，因为还有几个小时就要去答辩了，所以还是叫他起来了。</p><p>我就睡觉了，睡了一个小时，就起来了，君朋还在调试程序，收拾了下东西，洗了个澡，就准备出发了。出发的时候君朋告诉我，2对指环（有一对备份），其中有一个短路了。我突然就想到了不知道哪位前辈对与程序说的一句名言，“只要你觉得会出bug的地方，就一定会出bug”。还别说陕西地方邪，我觉得上海也挺邪的。到了交大的电信大楼，真心出错了，失效了，复位也没用。眼看着就要开始答辩了，君朋居然把430的程序又重新下了一遍，就快开始的时候，君朋说，ok了，我和雨舟算是放心了，雨舟在填功能测试表，我去弄ppt了。之后的答辩还算比较不错，演示效果也算是正常发挥了。</p><p>回到宾馆，繁忙了半年的身心，终于放松了。在宾馆，我跟君朋说，希望回到西安，就能开始骄奢淫逸的生活了。最后的结果还算不错了，1个国一，3个国二，我们是国二。这样，我靠着竞赛的成绩，也就被保研了。</p><p>之后，我们在上海转了转，后面，还去杭州转了一圈，主要就去了西湖，时间安排的太紧，加上天气比较热，所以，也没觉得有什么特别美好的地方。惬意的是在西湖旁的回廊中的微风，西湖游行的客船，还有三潭映月的水畔。</p><p>别了上海，又回到西安，大学的最后一年，就开始了。</p><h3 id="Intern-in-IBM"><a href="#Intern-in-IBM" class="headerlink" title="Intern in IBM"></a><strong>Intern in IBM</strong></h3><p>比较幸运吧，10月初的时候，在大街网上，收到了一个面试邀请，然后经过邮件面试，电话面试，两轮现场面试，终于拿到了实习的offer。这算是我第一份offer吧，上学期自己也确实准备过一些实习的面试，不过因为准备的不充分，深受打击，这次抱着试一试的态度，狠下心来，好好准备，意外的收获。在IBM 2个月了收获还算比较多，主要方面就是修改一些bug，还有一些性能测试。主要用shell和java比较多。</p><p>之前，一直在学校，确实没有工作方面的经验，不过和自己的想象还比较相似。不过，工作比我想象的稍微忙碌一些，我常常说的是，上班竞赛节奏，下班保研节奏。实习会持续到明年的6月左右，时间还长。后面再认真总结。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一年岁末时，2012对我来说，确实算是比较“丰满”的一年。从年初的嵌入式培训，到上半年的比赛准备，中间还夹杂着高密度的期末考试，国创的结题答辩，之后，去上海的正式比赛，回来之后保研的事情，一直到最后的实习。这一年，算是成长最快以及收获最多的一年，就按照顺序一一道来吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MarkDown格式备注</title>
    <link href="http://yikun.github.io/2012/12/26/MarkDown-geshibeizhu/"/>
    <id>http://yikun.github.io/2012/12/26/MarkDown-geshibeizhu/</id>
    <published>2012-12-26T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="noopener">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md" target="_blank" rel="noopener">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md" target="_blank" rel="noopener">查看这里</a>」–By @<a href="http://twitter.com/riku" target="_blank" rel="noopener">riku</a><br><a id="more"></a><br><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="noopener">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p><h1 id="Markdown-Basics-（快速入门）"><a href="#Markdown-Basics-（快速入门）" class="headerlink" title="Markdown: Basics （快速入门）"></a>Markdown: Basics （快速入门）</h1><p>此页提供了 Markdown 的简单概念， <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" title="Markdown Syntax" target="_blank" rel="noopener">语法说明</a> 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。</p><p>其实直接试试看也是一个很不错的方法， <a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown Dingus" target="_blank" rel="noopener">Dingus</a> 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。</p><h2 id="段落、标题、区块代码"><a href="#段落、标题、区块代码" class="headerlink" title="段落、标题、区块代码"></a>段落、标题、区块代码</h2><p>一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。</p><p>Markdown 支持两种标题的语法，<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），Atx 形式在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶。</p><p>区块引用则使用 email 形式的 ‘<code>&gt;</code>‘ 角括号。</p><p>Markdown 语法:</p><pre><code>A First Level Header====================A Second Level Header---------------------Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.The quick brown fox jumped over the lazydog&apos;s back.### Header 3&gt; This is a blockquote.&gt; &gt; This is the second paragraph in the blockquote.&gt;&gt; ## This is an H2 in a blockquote</code></pre><p>输出 HTML 为：</p><pre><code>&lt;h1&gt;A First Level Header&lt;/h1&gt;&lt;h2&gt;A Second Level Header&lt;/h2&gt;&lt;p&gt;Now is the time for all good men to come tothe aid of their country. This is just aregular paragraph.&lt;/p&gt;&lt;p&gt;The quick brown fox jumped over the lazydog&apos;s back.&lt;/p&gt;&lt;h3&gt;Header 3&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;This is a blockquote.&lt;/p&gt;&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;&lt;/blockquote&gt;</code></pre><h3 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h3><p>Markdown 使用星号和底线来标记需要强调的区段。</p><p>Markdown 语法:</p><pre><code>Some of these words *are emphasized*.Some of these words _are emphasized also_.Use two asterisks for **strong emphasis**.Or, if you prefer, __use two underscores instead__.</code></pre><p>输出 HTML 为:</p><pre><code>&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt;</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：</p><pre><code>* Candy.* Gum.* Booze.</code></pre><p>加号：</p><pre><code>+ Candy.+ Gum.+ Booze.</code></pre><p>和减号</p><pre><code>- Candy.- Gum.- Booze.</code></pre><p>都会输出 HTML 为：</p><pre><code>&lt;ul&gt;&lt;li&gt;Candy.&lt;/li&gt;&lt;li&gt;Gum.&lt;/li&gt;&lt;li&gt;Booze.&lt;/li&gt;&lt;/ul&gt;</code></pre><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记：</p><pre><code>1. Red2. Green3. Blue</code></pre><p>输出 HTML 为：</p><pre><code>&lt;ol&gt;&lt;li&gt;Red&lt;/li&gt;&lt;li&gt;Green&lt;/li&gt;&lt;li&gt;Blue&lt;/li&gt;&lt;/ol&gt;</code></pre><p>如果你在项目之间插入空行，那项目的内容会用 <code>&lt;p&gt;</code> 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。</p><pre><code>* A list item.With multiple paragraphs.* Another item in the list.</code></pre><p>输出 HTML 为：</p><pre><code>&lt;ul&gt;&lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt;&lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支援两种形式的链接语法： <em>行内</em> 和 <em>参考</em> 两种形式，两种都是使用角括号来把文字转成连结。</p><p>行内形式是直接在后面用括号直接接上链接：</p><pre><code>This is an [example link](http://example.com/).</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt;</code></pre><p>你也可以选择性的加上 title 属性：</p><pre><code>This is an [example link](http://example.com/ &quot;With a Title&quot;).</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;example link&lt;/a&gt;.&lt;/p&gt;</code></pre><p>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：</p><pre><code>I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot;</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot;title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot;title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;</code></pre><p>title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：</p><pre><code>I start my morning with a cup of coffee and[The New York Times][NY Times].[ny times]: http://www.nytimes.com/</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;I start my morning with a cup of coffee and&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt;</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的语法和链接很像。</p><p>行内形式（title 是选择性的）：</p><pre><code>![alt text](/path/to/img.jpg &quot;Title&quot;)</code></pre><p>参考形式：</p><pre><code>![alt text][id][id]: /path/to/img.jpg &quot;Title&quot;</code></pre><p>上面两种方法都会输出 HTML 为：</p><pre><code>&lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号 <code>`</code> 来标记代码区段，区段内的 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p><pre><code>I strongly recommend against using any `&lt;blink&gt;` tags.I wish SmartyPants used named entities like `&amp;mdash;`instead of decimal-encoded entites like `&amp;#8212;`.</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;I strongly recommend against using any&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;&lt;p&gt;I wish SmartyPants used named entities like&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encodedentites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt;</code></pre><p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 也一样会自动转成 HTML 实体。</p><p>Markdown 语法:</p><pre><code>If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;blockquote&gt;&lt;p&gt;For example.&lt;/p&gt;&lt;/blockquote&gt;</code></pre><p>输出 HTML 为：</p><pre><code>&lt;p&gt;If you want your page to validate under XHTML 1.0 Strict,you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/code&gt;&lt;/pre&gt;</code></pre><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>质能方程：</p><pre><code>$E=mc^2$</code></pre><p>$E=mc^2$</p><p>余弦定理：</p><pre><code>$\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1$</code></pre><p>$\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1$</p><p>插入方程组（注意多行公式结尾\\需要打成\\，可能是因为markdown会自动转义第一个\）：</p><pre><code>\begin{aligned}\dot{x} &amp; = \sigma(y-x) \\\\dot{y} &amp; = \rho x - y - xz \\\\dot{z} &amp; = -\beta z + xy\end{aligned}</code></pre><p>\begin{aligned}<br>\dot{x} &amp; = \sigma(y-x) \\<br>\dot{y} &amp; = \rho x - y - xz \\<br>\dot{z} &amp; = -\beta z + xy<br>\end{aligned}</p><p>插入矩阵：</p><pre><code>\begin{bmatrix}1 &amp; 2\\\3 &amp; 4\end{bmatrix}</code></pre><p>\begin{bmatrix}<br>1 &amp; 2\\<br>3 &amp; 4<br>\end{bmatrix}</p><p>对于Markdown有转换冲突的，可以使用<code>rawblock</code>将公式扩起来(百分号为<code>%</code>)：</p><pre><code>{百分号 raw 百分号}$$\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)$${百分号 endraw 百分号}</code></pre>$$\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)$$]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 这份文档派生(fork)于&lt;a href=&quot;http://markdown.tw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;繁体中文版&lt;/a&gt;，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里&lt;a href=&quot;http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;查看它的源文件&lt;/a&gt;。「繁体中文版的原始文件可以&lt;a href=&quot;https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;查看这里&lt;/a&gt;」–By @&lt;a href=&quot;http://twitter.com/riku&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;riku&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yikun.github.io/2012/12/21/Hello-World/"/>
    <id>http://yikun.github.io/2012/12/21/Hello-World/</id>
    <published>2012-12-21T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.864Z</updated>
    
    <content type="html"><![CDATA[<p>今天，是世界末日。同时，末日也是新生。<br><a id="more"></a><br>用Github建立了一个博客，希望可以坚持下来。</p><p>专心做好一件事，慢慢来，比较快。</p><p>See also, My old blog in csdn.<a href="http://blog.csdn.net/kerenigma" target="_blank" rel="noopener">here</a></p><p><strong><em>Hello World</em></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，是世界末日。同时，末日也是新生。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux Record</title>
    <link href="http://yikun.github.io/2012/12/06/linux-record/"/>
    <id>http://yikun.github.io/2012/12/06/linux-record/</id>
    <published>2012-12-06T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="User-Group-Password-Set"><a href="#User-Group-Password-Set" class="headerlink" title="User Group Password Set"></a>User Group Password Set</h2><pre><code>useradd –d /home/youtpath yournamepasswd  yournamegroupadd yourgroupchown yourname:yourgroup /home/yourname</code></pre><p>if accuont is exist, try to using <code>usermod -d /home/yourpath -U yourname</code></p><h2 id="IP-set"><a href="#IP-set" class="headerlink" title="IP set"></a>IP set</h2><h3 id="In-Ubuntu"><a href="#In-Ubuntu" class="headerlink" title="In Ubuntu"></a>In Ubuntu</h3><p>(/etc/network/interfaces)</p><pre><code># Dynamic IPauto eth0iface eth0 inet dhcp# Static IP auto eth0iface eth0 inet staticaddress 192.168.33.201netmask 255.255.255.0gateway 192.168.33.1</code></pre><p>then, in shell(also, need sudo):</p><pre><code>ifconfig eth0 downifconfig eth0 up</code></pre><p>last, try to <code>ifconfig</code> to check result, perhaps you need using <code>/etc/init.d/networking restart</code> to restart all network services</p><h3 id="In-RedHat"><a href="#In-RedHat" class="headerlink" title="In RedHat"></a>In RedHat</h3><p>you need modify 3 files:</p><pre><code>/etc/sysconfig/network/etc/sysconfig/network-scripts/ifcfg-eth0/etc/resolv.conf</code></pre><p>1./etc/sysconfig/network</p><pre><code>NETWORKING=yesNETWORKING_IPV6=noHOSTNAME=keroGATEWAY=192.168.1.1</code></pre><p>2./etc/sysconfig/network-scripts/ifcfg-eth0</p><pre><code>DEVICE=eth0                                NETMASK=255.255.255.0             IPADDR=192.168.1.88             BOOTPROTO=static                      #【none | static | bootp | dhcp】ONBOOT=yes                            #【yes | no】引导时是否激活设备DNS1=211.99.25.1                      #域名解析服务器PEERDNS=yes</code></pre><p>3./etc/resolv.conf</p><pre><code>nameserver 211.99.25.1          #DNS配置 同2中的 【DNS1=211.99.25.1 】</code></pre><p>4.Resart</p><p>   /sbin/ifdown eth0<br>   /sbin/ifup eth0<br>   /etc/init.d/network restart</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><pre><code>sudo apt-get install openssh-server</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><pre><code>find ./ -name &apos;*.*&apos; </code></pre><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><pre><code>du -h --max-depth=1</code></pre><h2 id="Virtual-IP"><a href="#Virtual-IP" class="headerlink" title="Virtual IP"></a>Virtual IP</h2><ol><li><p>Using <code>ifconfig</code> check your IP and eth</p><p> eth1      Link encap:Ethernet  HWaddr 08:00:27:71:DA:8C</p><pre><code>inet addr:XXX.XXX.XXX.250  Bcast:XXX.XXX.XXX.255  Mask:255.255.255.0inet6 addr: fe80::a00:27ff:fe71:da8c/64 Scope:LinkUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1RX packets:782 errors:0 dropped:0 overruns:0 frame:0TX packets:91 errors:0 dropped:0 overruns:0 carrier:0collisions:0 txqueuelen:1000RX bytes:77624 (75.8 KiB)  TX bytes:14476 (14.1 KiB)Base address:0xd240 Memory:f0820000-f0840000</code></pre></li><li><p>Set the Virtual IP, </p><p> ifconfig eth1:ha1 XXX.XXX.XXX.252 broadcast XXX.XXX.XXX.255 netmask 255.255.255.0 up</p></li></ol><p><code>eth1:ha1</code>, eth1:XXXX, XXXX is your virtual name, modifiy name what you want.</p><p><code>XXX.XXX.XXX.252</code>,  Virtual IP</p><p><code>XXX.XXX.XXX.255</code>, broadcast (Same as eth1 Bcast)</p><p><code>255.255.255.0</code>, netmask (Same as eth1 Mask)</p><p>Also, you can using <code>ifconfig eth1:ha1 XXX.XXX.XXX.252 broadcast XXX.XXX.XXX.255 netmask 255.255.255.0 down</code> shutdown Virtual IP</p><p>After it, you can using <code>ifconfig</code>, check result</p><pre><code>eth1:ha1  Link encap:Ethernet  HWaddr 08:00:27:71:DA:8C          inet addr:XXX.XXX.XXX.252  Bcast:XXX.XXX.XXX.255  Mask:255.255.255.0          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          Base address:0xd240 Memory:f0820000-f0840000</code></pre><ol start="3"><li>To ensure, Ip is unique, you could using arping to check</li></ol><p><code>arping -c 3 -I eth1 -s XXX.XXX.XXX.250 XXX.XXX.XXX.252</code></p><p><code>-c</code> is count, </p><p><code>-I</code> is your eth interface name, </p><p><code>-s XXX.XXX.XXX.250</code> is your now ip(source ip)</p><p><code>XXX.XXX.XXX.252</code> is the virtual ip you want to check</p><ol start="4"><li>If not active, you could using </li></ol><p><code>route add -host XXX.XXX.XXX.252 dev eth1:ha1</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;User-Group-Password-Set&quot;&gt;&lt;a href=&quot;#User-Group-Password-Set&quot; class=&quot;headerlink&quot; title=&quot;User Group Password Set&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从实践中一路走来</title>
    <link href="http://yikun.github.io/2012/11/17/congshijianzhongyiluzoulai/"/>
    <id>http://yikun.github.io/2012/11/17/congshijianzhongyiluzoulai/</id>
    <published>2012-11-17T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>又是一样的开学，又是一样的军训，仿佛我们入学的那天刚刚逝去，仿佛礼仪广场上的标语——“你们是中国电子信息科技未来的栋梁” 是为我们写的一样。可是，标语前面的称呼早已变成“ 2012级新同学”。<br><a id="more"></a><br>虽说自己学的不行，长的也不行，当真正成为学校里最大的一级时，也要负责地做一回学长。大学这四年，自己参加过一些比赛和实践活动，从星火杯到挑战杯，到国家大学生创新性实验计划，再到最后的全国大学生电子设计竞赛赛嵌入式系统邀请赛，也算是在竞赛路上磕磕碰碰的前行过。在这里，主要从竞赛的经历方面分享一下自己的路途与对大学认识的一些拙见。</p><p>大一，刚开学那阵子，大家好像延续了军训时期的斗志，都是充满斗志地打满了鸡血。希望加入各种各样的学生组织、社团、班委锻炼自己的能力，希望白天在图书馆、自习室争当学霸，希望晚上在篮球场上、操场上增强体质。当时的心态就是，要做一个德智体美劳全面发展的大学生！（好吧，好假，囧）</p><p>在刚入学的时候，就听说了通院科协是一个很锻炼人的组织，于是，招新的时候自信满满的去面试，很不幸，悲剧了，当时真心是感觉人生一下子灰暗了，真没言重，当时就是那么想的。还好通院科协的一些活动、讲座是面对全院的，我十分积极的参加各种各样的讲座、培训，就这样，学习了单片机和编程方面的基础知识 。</p><p>想想当时大一真是个鸡血少年，早上 6点多起床，去教室看看书，中午也不睡觉，就去图书馆。大一上学期什么也不懂，大学之前接触过一些编程但是都是很简单的，可以说基本不会；硬件方面也什么也不会，连烙铁都没有用过，开学没几个月就参加了大学的第一个比赛，星火杯。星火杯是学校内的比赛，很有西电的特色，主要就是软件、硬件、软硬结合、论文几个方面。</p><p>当时我们什么也不会，就按照电路图，买元件，焊电路，完成了我们的作品——电子百灵鸟。当时，特别特别兴奋，最终得了一个安慰奖。<br>大一下学期，科协让我们自己动手焊的单片机实验板。这个开发板也变成了我的“启蒙老师”，抱着电脑认真的学习郭天祥《十天学会单片机》，然后自己烧些程序在自己的开发板上。</p><p>刚开始的时候大家都有些像没头苍蝇，这时，可以适当地去听听讲座，参考一下长者的意见，只是参考，你应该有自己思想，追随自己的内心，走自己的路。另外，推荐大家读下开复老师的“当迷茫在大学里泛滥成灾”这篇文章。</p><p>大二的时候，自己算是入门了，因为特别喜欢编程，所以自己认真学习了 C和 C++，第二次星火杯可比第一次强多了，我们做了一个以公寓远程报修为功能核心功能的作品——基于 ZigBee网络的公寓自动化管理系统，最终得到了评委的肯定，获得校级一等奖。这次比赛算是大学里面第一个认真准备的比赛，开始的时候真心是什么都不会，只学过一些 C/C++，没用过MFC ，没用单片机做过系统，短短的 2个月，从 PC端的管理软件到学生端的交互终端，都是自己认真完成的，确实得到了锻炼。也许很多同学都会想“自己什么都不会，什么也没学过，自己可以吗？”其实大可不必担心，因为你会在你一点一滴的实践中逐渐成长。</p><p>在大二下学期恰好有个机会参加了陕西省挑战杯，由学校选拔参加的，基本上和星火杯的流程差不多，我们的作品也没有什么改变，只是完善了文档。文档其实是比赛中很重要的一个环节，好的文档确实能为你的作品添色不少。最终，拿了陕西省挑战杯的二等奖。其实大一大二的时候，就好似一个跳板，为之后打下基础。</p><p>大一大二的时候都比较纠结，很多人都纠结自己该怎么走完接下来的路，其实，我觉得吧，不管干什么，只要认真的一心一意的做下去，坚持下去都可以成为一个出色的人。</p><p>在大二的六月份左右，学校会组织申报“国家大学生创新创业实验计划项目”也就是我们平常简称的“国创”。通过“国创”的申请，学校会批给你们项目组一万元左右的资金去完成一个项目，时间期限是 1年，每个项目组三人。通过这个机会，你可以“免费”地阅读、购买到很多的书籍，这更是一个难得的机会去真正地接触一个项目从产生、管理、完成的整个过程。当时我们选择做的软件项目，主要是完成了条码扫描、社交分享、附近交易的一个Android 端的软件。很幸运的我们拿到了所有项目组的第六名 (前五能保研，恩，对，前五！杯具！ )。</p><p>其实，当时也真的不是很在意，因为那时候，已经在嵌入式比赛最后阶段，这个比赛全名叫做“全国大学生电子设计竞赛嵌入式邀请赛”，校队选拔相对比较严格、跨度时间比较长，基本是大三再加上大三暑假就搭进去了。这个比赛是我最投入，最用心也是得到最多锻炼的一个比赛。</p><p>2个多月，三轮选拔，从全校范围内 200多人中，选出了 12个来自不同学院的学生，组成 4队进行比赛。因为比赛平台的特殊性，是 Intel最新的CPU ，将FPGA芯片和 CPU集成在一起。从寒假开始，就选题，定题之后就开始完成作品了，每天真的是很充实。我们的题目是，室内交互设计游览系统，通过手上的一对指环，在家居场景中布置家具，体验游览家具设计，在 cpu中完成软件部分，在 FPGA中完成手势识别算法。因为新的东西比较多， Qt、图像引擎、物理引擎、图像识别、虚拟现实。从三月起基本每晚就睡的很晚，到最后比赛接近尾声的时候，基本上每天 3、 4点睡，早上 8点不到就起来了。每天睡的时候，都会和队友开玩笑，“大神们，赶紧睡吧，小心猝了”。比赛那几天更夸张，因为要去上海进行比赛坐火车，硬座一晚上基本没睡，第一天到上海没休息就去抽签，雨舟大神抽了个第二天早上的第三个，当时的心情就一个词儿——情何以堪。于是，第一天晚上也就没睡。那天夜里，突然 FPGA失灵了，当时吓了我们一身冷汗，当时脑海就是一片空白，心想“不是这么悲剧吧？”还好最后，把线重新插了下，又恢复了。付、谢、任三位带队老师特别负责（致敬！），晚上 3点多的时候，还在为我们把关答辩。回去的时候 4点多了，我修改 ppt完了就凌晨 5点了，老师让第二天答辩的人早点睡，因为是我答辩，于是我就可耻地睡去了，君朋大神活生生地一夜没睡，早上 6点多我起来的时候，看君朋还在调指环，鞠躬致敬！</p><p>第二天去比赛的时候，我们本来是第三个，第二个放弃了，我们又提前了一个，我们一去就开始准备。去上海的时候，我们准备了四个指环，两对，有一个短路了，当时我就想到一句话“所有你觉得可能出现问题的地方，就会出现问题”，当时也没想太多，比赛的时候，果不其然，悲剧了。那个没有备份的指环，程序跑飞了。君朋大神确实淡定，冷静地把程序重新烧了一遍，又恢复正常了，那就是一个心惊肉跳。最终演示的时候效果还不错，最后拿了国家二等奖，四队最终以一个一等奖，三个二等奖为比赛划上了句号。</p><p>我是这样一步一步走来的，当然上面的一些经历只是我个人的情况，刚入大学的你，应该有自己的道路。你需要清楚竞赛的路途上，不只有掌声和鲜花，或许也会有低靡，因为竞赛失利的人大有人在。不过，如果你真的喜欢竞赛带给你的锻炼与能力上的提高，而且在你深思熟虑过自己是否应该参加竞赛，如果确定要继续，那么坚持地做下去，不要在乎太多的功利，因为能力上的提高远远大于那些奖项。或许，你可以尝试从大一起就开始做自己的简历，每学期更新一次，看看自己是否有东西可写，是否比之前有些进步，哪怕只是简历上的一行。</p><p>最近看到过一段话，“在一定程度上，大一遇到什么水平的学长学姐，可以左右他大学的方向。请某些人高抬贵手，不要把你那些可笑的经验云云装的很像样的告诉他们，影响人家的认知，大学是他们自己的，走错了路，这个责任谁也担不起”。确实是这样，你需要谨慎地去面对那些“学长学姐”所谓的经验，就好像这篇文章一样，肯定会有不妥的地方，你需要保持一颗怀疑的心，大步向前。当然，如果你遇到了一些自己解决不了的问题，不妨请教一下长者，无论是学长、学姐、导员、老师，他们都会帮助你的。</p><p>大学是你们自己的，需要你们自己去探索，我们也只是起到抛砖引玉的作用，追随你自己的内心，走自己的路。准备好了吗？让你的大学流光溢彩吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是一样的开学，又是一样的军训，仿佛我们入学的那天刚刚逝去，仿佛礼仪广场上的标语——“你们是中国电子信息科技未来的栋梁” 是为我们写的一样。可是，标语前面的称呼早已变成“ 2012级新同学”。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>渐变</title>
    <link href="http://yikun.github.io/2011/05/18/jianbian/"/>
    <id>http://yikun.github.io/2011/05/18/jianbian/</id>
    <published>2011-05-18T00:50:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>变，渐变，我在变，朋友在变，周围在变，都在变。<br><a id="more"></a><br>突然发现，就这样的大学快过去一半了，如果说真正的习惯了大学生活那也不为过。早上起床，已经练就了从物理的、生理的、心理的、合情合理的忽视闹钟。中午还是不怎么想睡觉，因为睡久了会有想吐的感觉。天气慢慢的炎热起来，可恶的太阳从早上就开始不停的晒。</p><p>和宿舍同学的关系也越来越和谐了，宿舍的孩子们最近也开始堕落了，天天晚上都在dota，每次看他们玩的时候总想到四个字，玩物丧志。当然，自己在他们玩的时候，也没做些什么有意义的事。甚至周六周日也和他们沦陷一番。</p><p>最近和娱乐有关的活动，除了对吃感兴趣外，真的什么也觉得没意思，游戏没心思玩，篮球很久没碰了，电影看一半就想睡觉了，上网看见人人上那些个无聊的状态就直接注销了，不想再上，今天又有急于联系的人，又解封了，我也真是可笑。</p><p>今天晚上，突发奇想到操场跑了几圈，在草坪上，休息的时候捡到一个手机，然后，高尚的还给人家，他还说要请我吃饭。囧不囧</p><p>最 近，各方面都还顺利，国家大学生创新性实验计划申上了，批1.2万的可用资金，这是第一次有那么多钱可以用吧，好好珍惜，项目期限，一年的时间。富士通的 初赛也通过了，也可以有个开发板可以免费用了，说不定十月的时候还有机会去次上海。世园会志愿者也选上了，暑假也可以充实起来了。</p><p>最近压力比较大的还是课内的东西还有六级，现在都是全裸状态。得赶紧补了</p><p>最近，也在关注一些实习生招聘的东西，突然觉得涉猎有些广泛了，android＆java  嵌入式  c&amp;c++，得精通一个才好。</p><p>有一个小小的目标就是大三暑假大四左右的时候，去创新工厂实习。可能android 和C++会成为蓝筹吧。所以，要专心技术基础了。</p><p>嗯。拿得起，放不下。是不是很失败啊。哈哈，不知道该怎么办。只怪时间不是优质的稀释液。</p><p>有2,3个月都没吃胡辣汤了，这周一定要回去吃！</p><p>嗯，就到这里吧。</p><p>Go on ! </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;变，渐变，我在变，朋友在变，周围在变，都在变。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>很久很久</title>
    <link href="http://yikun.github.io/2011/03/22/henjiuhenjiu/"/>
    <id>http://yikun.github.io/2011/03/22/henjiuhenjiu/</id>
    <published>2011-03-22T00:57:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>很久很久没有发过日志什么的了，生活越来越趋向于充实的平稳与平静。每天都在忙，不过有时候想想时间真是不知道怎么的就没了。 或许归根结底还是没好好的规划吧。<br><a id="more"></a><br>电装过去了，收音机响的那一刻也没有过多的惊喜，或许是种趋于成熟的平淡或者平凡吧。手也被烫伤了两处，突然让我想到一句话，被淹死的都是会游泳的。只是可惜了再也没有实践的机会了，名正言顺的逃避学术理论数十天的机会。</p><p>这学期的课都不是什么省油的灯，数电模电数据结构还算过得去电磁场与电磁波真是一门见不到底的学科，信号看着那些卷积积分傅立叶Z变换就头大。考试月也不 会轻松吧，更何况又是万恶的夏天。最近看些模拟技术的东西觉得好有兴趣，可是看着模电书里干巴巴的式子也顿时没了激情，这还是因为过于浮躁吧。</p><p>天气最近也是格外的变态，又听到了一些同学问类似于西安天气是不是一直这么怪的问题。我也是不知怎么回答的笑笑，天气也不归我管吧，是吧。</p><p> 大家也都在开始为着自己的事情奋斗了，拼命GRE奋斗雅思的人也不少，像我吧，这种飘摇不定的不知上研还是工作，只是一直在学着，51完了430，430中间又杀出个cortex M3，无奈又转战ARM了。就等着厚积薄发，独孤一掷了吧。</p><p>慢慢的，一些事情和能力也渐渐的得到了认可，自己也有了那么几分信心。 当然，还是时常被一些繁琐的事困扰着，侵略着不多的自由。还好听说明天可能就发布上线了，也没我这个打酱油的什么也不会的美工什么事了，也算了却了一桩心 事吧。不过这些时间也认识了不少强人，自己也学到了一些UI方面的东西。</p><p>有句话说的好，穷则独善GPA，达则兼顾GDP。有时候也翻翻墙看看世界，和同学交流一下真相什么的也挺开心的。最近地球不太安稳，一会地震一会军事冲突的，渐渐的发现自己有些锁闭了，所以开始坚持每天看看新浪，也有了个微博叫Keroenigma。</p><p>前几天还看见同学说，大学找到媳妇就工作，找不到就安心上研。这也不失为一个好办法，要不我也这样？其实我还是偏重于工作一些吧。 有些事情，很久，很久。还是没有忘记，或许就像一个划伤，虽然不疼了，但是疤还在那，永远也不退去，都是写死亡的细胞却永远不能消失殆尽。慢慢的真的是越 来越远了。或许这也是没什么办法的无能为力吧。每当想起了就想着，有些事情过去了就让他过去了吧，也没有什么时间和机会去留给我去后悔。</p><p>时间啊时间，又是时间。如果要是时间多点，哦，没有如果。</p><p>开始学车了，也还算顺利，倒库移库的一直在练。</p><p>四级也坎坷的裸过了，六级好好准备吧。</p><p>三月的最后几天了，很关键吧。一个人发现自己最平庸的时候便是没有灵感。有时候没有想法真的是一件苦恼的事。</p><p>这学期的这些个事也不会闲下来的，这样也好，慢慢来吧，一行一行的写，书一本一本的啃，路一步一步的走。。。</p><p>嗯。还是那句话，无悔就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久很久没有发过日志什么的了，生活越来越趋向于充实的平稳与平静。每天都在忙，不过有时候想想时间真是不知道怎么的就没了。 或许归根结底还是没好好的规划吧。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>写一篇日志</title>
    <link href="http://yikun.github.io/2010/10/05/xieyipianrizhi/"/>
    <id>http://yikun.github.io/2010/10/05/xieyipianrizhi/</id>
    <published>2010-10-05T03:40:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>今天是十月五日，天气晴朗，星空美丽。<br><a id="more"></a><br>现在我在宿舍的床上滴滴哒哒的按着手机。交待了时间地点人物，还差起因经过结果。本 身我不是什么有文采的人，但是经过和谐美好社会的洗礼，养成了一些美好的习惯。刚才看见二姐的日志，这件事情姑且算作起因。不大灵光的头脑经过一系列乱窜 的微弱电流在头部的沟沟壑壑中形成的紊乱的思绪，这个过程算作经过。然后我下面打出的几行未经过任何处理的只言片语，这便算作是结果吧。这样，记叙文的六 大要素算是齐全了，也便没有辜负从小学一直到高一都是语文老师做班主任的这个事实。</p><p>正如二姐所说的，于是，大二了。经过一年的高 等教育的培育，我现在也算是一名不折不扣的大学生了。二姐文章内的很多都是藏在内心里面，不想在公开场面表露的。我自认为我还算是一个敢说敢做敢为的人。 正如他所含沙涉影的描述，我们的大学生活中出现了这种那种利益的纷争。我在考虑具体什么的用不用在这里附上一个超级链接然后转向二姐的日志，但是考虑到二 姐的广泛影响力还有手机的具体能力。我还是决定不多此一举了。关于学生会、奖学金、团委、热水供应那些和我无关的事情我便也无权描述。既然，我处在大学这 个小社会中，那么我也应该享有这么一项言论自由。所以，写不写随我，看不看随你。</p><p>大一一年的时间，我到底做了什么，我想也是时候描述一下了。没有什么丰功伟绩，没有什么惊天动地，和大家一样的加了几个什么组织。</p><p>那好，先说学生会。为了那些所谓的潜移默化的进步，然后投简历，开始兴致勃勃的进行面试，终于是头破血流般的从外联部调剂到学习实践部，在这个部酱油的一年 来，多多少少也算是有所收获有所成长，以致于我觉得进步超过了我所想象，感觉到所有的东西都领悟了之后，在学期初的时候，选择了退出。刚才看到二姐日志中 写到什么干事—部长助理—部长副部长的路线，突然给了我启发，我才知道原来事情是这样发展的。这里，我也无力去评价学生会什么的好坏，大家心里也都明白。 我是想说，什么如果留下来要给我升官，什么我可以去聚餐那些东西又能影响的到我什么，最多是简历上一行平淡的经历，然后再也没什么了，被大家妖化的学生 会，也在日益增加的光芒中不断的健壮，赢得了大一莘莘学子的青睐，最终学生会也往开一面，基本全额地收留了屈指可数的报名的精英。有些人评价说学生会要没 落了，那些事情与你们无关，你死了以后，不会在你的墓碑刻上一行字：在学生会没落之前，此人果断离开。所以，我也没有说我的离开彰显我的明智。只是个人不 喜欢那种氛围罢了。什么大二之后就可以管别人了，我自己的事情都没有管好，哪有资格倚老卖老欺骗广大新生，并且美其名曰潜移默化的进步。</p><p>然后是科协，当我斗志昂扬的写好简历，面试，并且被面试官无情秒杀时，便发誓与科协誓不两力。如今，我也便是充满自豪的忝列于技术部部长助理的名单中，在 此，我想我要向张静媛同学致谢，没有她的推荐，或许我还在科协外部碌碌无为。比较戏剧的我也成了面试官，当坐到这里，我才发现，或许，那些有意念想要学好 的孩子们，也被我们这些面试官以一句：技术部需要有技术基础的搪塞过去了。科协确实是个好地方，没有学生会那些无聊的纷争，做自己喜欢的事情，学学技术， 打打酱油，足以。学长们都有闪闪发光的一面，没有什么架子可言，什么嵌入式奖杯，什么国创计划，有能力的学长有着这样那样的荣誉，可是没有丝毫的高姿态， 我想这才是作为学长应有的姿态。尤其要提下黄翔学长，前几个月为了给我讲一个8255的读写，花费了他将近三个小时。最后还从他口中得知，当时他在给我们 讲单片机的时候，被不少人误以为他们从实验板里捞了不少钱。我说那些人你是脑残还是怎么了叫你大四保研了，占用自己的时间去教大一的，不求回报，你能做到 么。别以为你不能，别人就不能。在这里还是要非常感谢那些学长的，当然，到大四以后，如果我也有能力的话，也一定会传承你们的意志的。</p><p>下来说说星火杯，什么我们这组好强，什么冲击校特，都是吓唬人的。不管这组有怎样怎样栩栩如生，精彩动人刻骨铭心的故事，那些都不重要，重要的是在于真正的 学到东西了，这种事情过程确实很重要。和强人混，拿别人的东西ctrl c，ctrl v，然后你拿个院奖免修，或者一不小心还拿个校特，保研加个1分2分，对自己又有多大提升？什么没基础求强人带，你就那么看不起自己？那么强人永远是强 人，你自己永远只是你自己。我没有像某些人什么从小就开始学编程，家里的人随便就弄个专利给自己挥霍。我就是零基础那又怎样，我通过自己努力，团队合作完 成了作品，达到了自己预想的功能，这就足够了。对自己的队友的能力要信任，这是最起码的规则，你必须要遵守。所以，到最后，不管是没奖院奖校奖，不管合理 与否，我都接受，我也只能接受，至少我能做到问心无愧。那些纷争，利益，关系，那些都是社会层面的事情，和技术层面是没有任何牵连的。</p><p>下来说说班级，我通过匪夷所思的路线，从心理委员一跃成为副班长，可能大家会想，凭什么我就拿了社会工作奖学金，凭什么我就有资格参加高党课程。得到这些东 西或者荣誉，我觉得没人会认为我是绞尽脑汁用什么非法手段吧？这点我还是比较自信的。下来就是班长竞选，王琪他大一做了多少事可能我是比较清楚的，为了一 个答辩，你能做到耗尽自己自习的时间吗？虽然，你对他这样那样的看不惯，不过你想想也便明白，为什么王琪最终还是当上正班长，即使只是一票之差。</p><p>至于导员，大家对导员有这样那样的意见，在这里我也无意评价导员的好坏。导员本身是个比较尴尬的位置，对于班主任大家都心存一个黑暗的形象，以致于把这层阴 影覆盖到了导员的职位上，我只是希望大家在说一些话的时候，能换位思考一下。人无完人，或许有些事情处理的不得当，但是，请你不要用有色的眼睛去看待世 界。好了，夜也比较深了，想说的也说完了，打字也累了，那么，就到这吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是十月五日，天气晴朗，星空美丽。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>静夕思</title>
    <link href="http://yikun.github.io/2010/07/10/jingxisi/"/>
    <id>http://yikun.github.io/2010/07/10/jingxisi/</id>
    <published>2010-07-10T00:00:00.000Z</published>
    <updated>2021-08-02T03:29:39.868Z</updated>
    
    <content type="html"><![CDATA[<p>一个人，静悄悄地坐在窗台，看着天空是阴霾。<br><a id="more"></a><br>几缕阳光，耐不住寂寞，钻过某处略显稀薄的云雾，真的是一缕一缕的，爬到世间，忍不住回到桌前，拿起笔记录几点几滴的文字。</p><p>没有犹豫的拿起钢笔，已经干涸了的钢笔，吸了几滴甘霖般的墨水，蓝色，纯蓝色。坐在马扎上，靠着阳台的墙，墙被太阳烤得有些余温，靠上去丝毫感受不到温暖， 而是几分燥热。外面是垃圾与绿色的杂草构成的废地，夏的绿很深很深，在几处凌乱的垃圾的点缀下略显几分荒颓，这样的荒颓如大一下学期的生活，没有一丝一抹 的鲜活的灵感，只剩下没有生机的暗淡；废地旁，还有一个废弃的工厂，传说之中有各种原因，它坚强的被遗弃在这荒芜的西电，工厂只剩下一圈围墙禁锢些那些荒 砖颓墙，几簇挺拔的野草顽固的扎在那儿，又增添几分紊乱，这紊乱如大一下学期的林总，无处安置的梦想碰到了迷失的现实。</p><p>坐在阳台最显惬意的是能吹来一阵阵的微风，触摸灵魂般的微凉。一切都很安静，很安静。安静到坐在这里什么也不用想，那些思绪便仿佛识破了这安寂一般，喷涌而出，没有人打扰我，没有人能打扰我，没有人会打扰我，略显几分得意的孤独。</p><p>是 孤独，不是寂寞。孤独是一种比寂寞更坚强的东西，没有寂寞那么的无助。身边，没有人说话，没有人谈心，即使有，也是肤浅的嘻哈几句带过，记着开学的时候， 总把贵重的物品，还有这些珍贵的笔迹锁在抽屉里，有戒备。现在呢？锁永远开着，没有人会动那些所谓的贵重，或许，就算是不小心看见了这些凌乱的笔迹也可能 看不懂吧？这锁确实永远开着，然而，心却上了一把锁，没有钥匙的锁。</p><p>我曾说过，本来人与人之间并没有隔阂，可是，门一层一层地加上了，锁也一把一 把地死死地焊在上面，于是，太累了，便懒得去打开，或者是说不想去打开。眼看着日子就这么一天一天的从眼间划过，也便慢慢地，力不从心，无力抓住，毫不知 情地被几分低迷侵占，然后守着梦想糜烂在这无处安放的青春。</p><p>想要破除这阴霾，却总是半途而止。再看看天，那略显稀薄的云雾也开始慢慢地合上，几缕阳光是否也望见了这世间的暗淡，无奈地退了回去？</p><p>客 厅又传来了咯吱的的门声，再啪的一声彻底击碎这片宁静，回头看看，不是有人回来，而是有人离开。离开？是的，就像朋友一个一个离去一样，不打招呼，还没反 应过来，这里便空得只剩下我一个人。刚才又看到了类似的话语。“朋友。一个，知己；两个，略显敷衍；三个、四个，也未免太多了吧”有到了一个我可以笑而不 语的时刻。每次，每时，每刻听到朋友二字时，心中总是有说不出来的无奈与酸楚，我人际能力太强了吧，人缘太好了吧？呵。。大家都说朋友是财富。那我未免也 有点太过富有了吧？富有到最后，我便应该成了一个最穷的富翁了吧？</p><p>是不是想得太多了，也罢，该收尾了。顺其自然。这些思绪或许也就停留在这些歪七 扭八的字里行间了吧？想想也可笑，高中文章结尾的时候总喜欢这样写：我拾起散落了一地的思绪，看着远方的阳，夕阳咬破云的唇，留下一抹血迹在天边。”然后 便是描写几句明早破晓的美好。可现在呢？却真是到了夕阳时，，天际却还是只有大片的阴霾，思绪也不那么能轻易的散开，而却像墨迹留在纸上一样，便深深的印 在了我这矫柔造作的文字上了。还好这不是高考作文，我不用可以去敷衍，隐藏什么。现实是怎样我便记下来。</p><p>远处还是阴霾，破晓是否能见朝阳，谁可得知。正如我于别人，永远是个Enigma。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个人，静悄悄地坐在窗台，看着天空是阴霾。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
