<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Yikun]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yikun.github.io/"/>
  <updated>2016-06-29T15:47:27.000Z</updated>
  <id>http://yikun.github.io/</id>
  
  <author>
    <name><![CDATA[Yikun]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[一致性哈希算法的理解与实践]]></title>
    <link href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yikun.github.io/2016/06/09/一致性哈希算法的理解与实践/</id>
    <published>2016-06-09T02:43:54.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="0-_概述">0. 概述</h3><p>在维基百科中，是这么定义的</p>
<blockquote>
<p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
</blockquote>
<h3 id="1-_引出">1. 引出</h3><p>我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？<br>那么我们引出一个问题：</p>
<blockquote>
<p>假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。</p>
</blockquote>
<p>看一看普通Hash算法的原理：<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341297/fe155f98-3a5e-11e6-834d-193e6f85afcd.png" alt="normal_hash"><br>算法的核心计算如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    k = md5(str(item)).digest()</span><br><span class="line">    h = unpack_from(<span class="string">"&gt;I"</span>, k)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 通过取余的方式进行映射</span></span><br><span class="line">    n = h % NODES</span><br><span class="line">    node_stat[n] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>具体的完整实现请参考<a href="https://github.com/Yikun/hashes/blob/master/normal_hash.py" target="_blank" rel="external">normal_hash.py</a>，输出是这样的：</p>
<blockquote>
<p>Ave: 100000<br>Max: 100695    (0.69%)<br>Min: 99073    (0.93%)</p>
</blockquote>
<p>从上述结果可以发现，普通的Hash算法均匀地将这些数据项打散到了这些节点上，并且分布最少和最多的存储节点数据项数目小于1%。之所以分布均匀，主要是依赖Hash算法（实现使用的MD5算法）能够比较随机的分布。</p>
<p>然而，我们看看存在一个问题，由于该算法使用节点数取余的方法，强依赖node的数目，因此，当是node数发生变化的时候，item所对应的node发生剧烈变化，而发生变化的成本就是我们需要在node数发生变化的时候，数据需要迁移，这对存储产品来说显然是不能忍的，我们观察一下增加node后，数据项移动的情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    k = md5(str(item)).digest()</span><br><span class="line">    h = unpack_from(<span class="string">"&gt;I"</span>, k)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 原映射结果</span></span><br><span class="line">    n = h % NODES</span><br><span class="line">    <span class="comment"># 现映射结果</span></span><br><span class="line">    n_new = h % NEW_NODES</span><br><span class="line">    <span class="keyword">if</span> n_new != n:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>详细实现代码在<a href="https://github.com/Yikun/hashes/blob/master/normal_hash_add.py" target="_blank" rel="external">normal_hash_add.py</a>输出是这样的：</p>
<blockquote>
<p>Change: 9900989    (99.01%)</p>
</blockquote>
<p>翻译一下就是，<strong>如果有100个item，当增加一个node，之前99%的数据都需要重新移动</strong>。</p>
<p>这显然是不能忍的，普通哈希算法的问题我们已经发现了，如何对其进行改进呢？没错，我们的一致性哈希算法闪亮登场。</p>
<h3 id="2-_登场">2. 登场</h3><p>我们上节介绍了普通Hash算法的劣势，即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。</p>
<p>那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即<strong>当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量的降到最低</strong>。</p>
<p>一致性Hash算法的原理是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341311/0e8fea32-3a5f-11e6-84b5-ff101495cf49.png" alt="consist_hash"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(NODES):</span><br><span class="line">    h = _hash(n)</span><br><span class="line">    ring.append(h)</span><br><span class="line">    ring.sort()</span><br><span class="line">    hash2node[h] = n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item)</span><br><span class="line">    n = bisect_left(ring, h) % NODES</span><br><span class="line">    node_stat[hash2node[ring[n]]] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>我们依然对其进行了实现<a href="https://github.com/Yikun/hashes/blob/master/consist_hash_add.py" target="_blank" rel="external">consist_hash_add.py</a>，并且观察了数据迁移的结果：</p>
<blockquote>
<p>Change: 235603    (2.36%)</p>
</blockquote>
<p>虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据项分布的均匀性，进行了一致性Hash算法的实现<a href="https://github.com/Yikun/hashes/blob/master/consist_hash.py" target="_blank" rel="external">consist_hash.py</a>：</p>
<blockquote>
<p>Ave: 100000<br>Max: 596413    (496.41%)<br>Min: 103    (99.90%)</p>
</blockquote>
<p>这结果简直是简直了，确实非常结果差，分配的很不均匀。我们思考一下，一致性哈希算法分布不均匀的原因是什么？从最初的1000w个数据项经过一般的哈希算法的模拟来看，这些数据项“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据项本身的哈希值并未发生变化，变化的是判断数据项哈希应该落到哪个节点的算法变了。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341426/8c9e6caa-3a5f-11e6-87ad-fdb462b76aef.png" alt="consist_hash_1"><br>因此，主要是因为这100个节点Hash后，<strong>在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一</strong>造成的。</p>
<h3 id="3-_改进-虚节点">3. 改进-虚节点</h3><p>当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341445/a0e32fde-3a5f-11e6-969d-085f64220e63.png" alt="consist_hash_virtual"></p>
<p>详细实现请见<a href="https://github.com/Yikun/hashes/blob/master/virtual_consist_hash.py" target="_blank" rel="external">virtual_consist_hash.py</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(NODES):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(VNODES):</span><br><span class="line">        h = _hash(str(n) + str(v))</span><br><span class="line">        <span class="comment"># 构造ring</span></span><br><span class="line">        ring.append(h)</span><br><span class="line">        <span class="comment"># 记录hash所对应节点</span></span><br><span class="line">        hash2node[h] = n</span><br><span class="line">ring.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(str(item))</span><br><span class="line">    <span class="comment"># 搜索ring上最近的hash</span></span><br><span class="line">    n = bisect_left(ring, h) % (NODES*VNODES)</span><br><span class="line">    node_stat[hash2node[ring[n]]] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果是这样的：</p>
<blockquote>
<p>Ave: 100000<br>Max: 116902    (16.90%)<br>Min: 9492    (90.51%)</p>
</blockquote>
<p>因此，通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。<br>同时，观察增加节点后数据变动情况，详细的代码请见<a href="https://github.com/Yikun/hashes/blob/master/virtual_consist_hash_add.py" target="_blank" rel="external">virtual_consist_hash_add.py</a>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(str(item))</span><br><span class="line">    n = bisect_left(ring, h) % (NODES*VNODES)</span><br><span class="line">    n2 = bisect_left(ring2, h) % (NODES2*VNODES)</span><br><span class="line">    <span class="keyword">if</span> hash2node[ring[n]] != hash2node2[ring2[n2]]:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>100000<br>101000<br>Change: 104871    (1.05%)</p>
</blockquote>
<h3 id="3-_另一种改进">3. 另一种改进</h3><p>然而，虚节点这种靠数量取胜的策略增加了存储这些虚节点信息所需要的空间。在OpenStack的Swift组件中，使用了一种比较特殊的方法来解决分布不均的问题，改进了这些数据分布的算法，将环上的空间均匀的映射到一个线性空间，这样，就保证分布的均匀性。<br><img src="https://cloud.githubusercontent.com/assets/1736354/16341455/b01139ec-3a5f-11e6-965a-070f5c4c0afa.png" alt="consist_hash_ring"><br>代码实现见<a href="https://github.com/Yikun/hashes/blob/master/part_consist_hash.py" target="_blank" rel="external">part_consist_hash.py</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> range(<span class="number">2</span> ** LOG_NODE):</span><br><span class="line">    ring.append(part)</span><br><span class="line">    part2node[part] = part % NODES</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item) &gt;&gt; PARTITION</span><br><span class="line">    part = bisect_left(ring, h)</span><br><span class="line">    n = part % NODES</span><br><span class="line">    node_stat[n] += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Ave: 100000<br>Max: 157298    (57.30%)<br>Min: 77405    (22.59%)</p>
</blockquote>
<p>可以看到，数据分布是比较理想的。如果节点数刚好和分区数相等，理论上是可以均匀分布的。而观察下增加节点后的数据移动比例，代码实现见<a href="https://github.com/Yikun/hashes/blob/master/part_consist_hash.py" target="_blank" rel="external">part_consist_hash.py</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> range(<span class="number">2</span> ** LOG_NODE):</span><br><span class="line">    ring.append(part)</span><br><span class="line">    part2node[part] = part % NODES</span><br><span class="line">    part2node2[part] = part % NODES2</span><br><span class="line"></span><br><span class="line">change = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> range(ITEMS):</span><br><span class="line">    h = _hash(item) &gt;&gt; PARTITION</span><br><span class="line">    p = bisect_left(ring, h)</span><br><span class="line">    p2 = bisect_left(ring, h)</span><br><span class="line">    n = part2node[p] % NODES</span><br><span class="line">    n2 = part2node2[p] % NODES2</span><br><span class="line">    <span class="keyword">if</span> n2 != n:</span><br><span class="line">        change += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下所示：<br>&gt;<br>Change: 2190208    (21.90%)</p>
<p>可以看到，移动也是比较理想的。</p>
<h3 id="参考链接：">参考链接：</h3><p><a href="http://www.cnblogs.com/yuxc/archive/2012/06/22/2558312.html" target="_blank" rel="external">深入云存储系统Swift核心组件：Ring实现原理剖析</a><br><a href="https://github.com/gholt/ring/blob/master/BASIC_HASH_RING.md" target="_blank" rel="external">Basic Hash Ring</a><br><a href="https://github.com/gholt/ring/blob/master/PARTITION_RING_VS_HASH_RING.md" target="_blank" rel="external">Partition Ring vs. Hash Ring</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="0-_概述">0. 概述</h3><p>在维基百科中，是这么定义的</p>
<blockquote>
<p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然]]>
    </summary>
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解Python中的“with”]]></title>
    <link href="http://yikun.github.io/2016/04/15/%E7%90%86%E8%A7%A3Python%E4%B8%AD%E7%9A%84%E2%80%9Cwith%E2%80%9D/"/>
    <id>http://yikun.github.io/2016/04/15/理解Python中的“with”/</id>
    <published>2016-04-15T15:44:15.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_缘起">1. 缘起</h3><p>Python中，打开文件的操作是非常常见的，也是非常方便的，那么如何优雅的打开一个文件？大部分的同学会这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open( <span class="string">"a.txt"</span> ) <span class="keyword">as</span> f :</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure></p>
<p>大家都知道，这样写可以自动处理资源的释放、处理异常等，化简了我们打开文件的操作，那么，<code>with</code>到底做了什么呢？</p>
<p>从《Python学习手册》中是这么描述的：</p>
<blockquote>
<p>简而言之，with/as语句的设计是作为常见try/finally用法模式的替代方案。就像try/finally语句，with/as语句也是用于定义必须执行的终止或“清理”行为,无论步骤中是否发生异常。不过，和try/finally不同的是，with语句支持更丰富的基于对象的协议，可以为代码块定义支持进入和离开动作。</p>
</blockquote>
<p>也就是说对于代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> expression [<span class="keyword">as</span> varible]:</span><br><span class="line">    <span class="keyword">with</span>-block</span><br></pre></td></tr></table></figure></p>
<p>with语句的实际工作方式：</p>
<blockquote>
<p>1.计算表达式，所得到的对象是<strong>环境管理器</strong>，他必须有<strong>enter</strong>，<strong>exit</strong>两个方法。<br>2.环境管理器的<strong>enter</strong>方法会被调用。如果as存在，<strong>enter</strong>的返回值赋值给as后面的变量，否则，被丢弃。<br>3.代码块中嵌套的代码（with-block）会执行。<br>4.如果with代码块会引发异常，<strong>exit</strong>(type,value,traceback)方法就会被调用。这些也是由sys.exec<em>info返回相同的值。如果此方法返回为假，则异常会重新引发。否则，异常会中止。正常情况下异常是应该被重新引发，这样的话传递到with语句外。<br>5.如果with代码块没有引发异常，<em>_exit</em></em>方法依然会调用，其type、value以及traceback参数会以None传递。</p>
</blockquote>
<p>with/as语句的设计，是为了让必须在程序代码块周围发生的启动和终止活动一定会发生。和try/finally语句（无论异常是否发生其离开动作都会执行）类似，但是with/as有更丰富的对象协议，可以定义进入和离开的动作。</p>
<h3 id="2-_设计的初衷">2. 设计的初衷</h3><p>with/as语句的设计的初衷，在<a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="external">PEP343</a>中是这么描述的：</p>
<blockquote>
<p>This PEP adds a new statement “with” to the Python language to make it possible to factor out standard uses of try/finally statements.<br>In this PEP, context managers provide <strong>enter</strong>() and <strong>exit</strong>() methods that are invoked on entry to and exit from the body of the with statement.</p>
</blockquote>
<p>对于下面的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">            BLOCK</span><br></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mgr = (EXPR)</span><br><span class="line">exit = type(mgr).__exit__  <span class="comment"># Not calling it yet</span></span><br><span class="line">value = type(mgr).__enter__(mgr)</span><br><span class="line">exc = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将__enter__函数调用的返回值返回给VAR</span></span><br><span class="line">        VAR = value  <span class="comment"># Only if "as VAR" is present</span></span><br><span class="line">        <span class="comment"># 执行BLOCK</span></span><br><span class="line">        BLOCK</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># 异常处理，The exceptional case is handled here</span></span><br><span class="line">        exc = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(mgr, *sys.exc_info()):</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="comment"># The exception is swallowed if exit() returns true</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理，The normal and non-local-goto cases are handled here</span></span><br><span class="line">    <span class="keyword">if</span> exc:</span><br><span class="line">        exit(mgr, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到上述代码完整的处理了初始化及异常/正常场景的清理操作，这便是<code>with</code>的设计思想，化简了冗余的代码，把那些重复的工作以及异常处理操作交给写“EXPR”源码（比如open操作）的同学。</p>
<h3 id="3-_更深入的学习">3. 更深入的学习</h3><p>我们继续深入的看下<a href="https://github.com/Yikun/Python3/blob/master/Lib/_pyio.py#L447" target="_blank" rel="external">Python3</a>中<strong>enter</strong>和<strong>exit</strong>的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOBase</span><span class="params">(metaclass=abc.ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### Context manager ###</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span>  <span class="comment"># That's a forward reference</span></span><br><span class="line">        <span class="string">"""Context management protocol.  Returns self (an instance of IOBase)."""</span></span><br><span class="line">        self._checkClosed()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="string">"""Context management protocol.  Calls close()"""</span></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></p>
<p>和我们预期的一致，在<strong>enter</strong>中返回了这个IO对象，然后在<strong>exit</strong>中，进行了清理。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li>《Python学习手册》 </li>
<li><a href="http://effbot.org/zone/python-with-statement.htm" target="_blank" rel="external">Understanding Python’s “with” statement</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0343/" target="_blank" rel="external">PEP 343 — The “with” Statement</a></li>
<li><a href="http://stackoverflow.com/questions/713794/catching-an-exception-while-using-a-python-with-statement" target="_blank" rel="external">Catching an exception while using a Python ‘with’ statement</a></li>
<li><a href="http://zhoutall.com/archives/325" target="_blank" rel="external">理解Python中的with…as…语法</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3116/" target="_blank" rel="external">PEP 3116 — New I/O</a></li>
<li><a href="https://github.com/Yikun/Python3/blob/master/Lib/_pyio.py#L447" target="_blank" rel="external">Python 3.5.0 Code</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_缘起">1. 缘起</h3><p>Python中，打开文件的操作是非常常见的，也是非常方便的，那么如何优雅的打开一个文件？大部分的同学会这样实现：<br><figure class="highlight python"><table><tr><td clas]]>
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[存储数据包的一生]]></title>
    <link href="http://yikun.github.io/2016/04/03/%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E4%B8%80%E7%94%9F/"/>
    <id>http://yikun.github.io/2016/04/03/存储数据包的一生/</id>
    <published>2016-04-03T14:04:23.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>最近认认真真学习了一个叫<a href="https://www.brighttalk.com/webcast/663/169543" target="_blank" rel="external">《Life of a Storage Packet》</a>讲座，借助这个讲座将整个存储的过程理解了下，不放过任何一个有疑问的点。这篇文章算是对讲座的理解和自己收获的总结，同时也为那些对存储系统不够了解又想要了解的初学者，展现一个存储数据包的“生命”。这个演讲主要聚焦在“整体的存储”，强调存储系统中各个基本元素的关系，并且尽可能简单、清楚地用一种不同的方式可视化一些存储的概念。</p>
<p>先上一张大图，可以说这篇文章目的就是解释这个图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png" alt="12"><br><a id="more"></a></p>
<h3 id="1-_整体视角">1. 整体视角</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232846/9c75a7a8-f9e9-11e5-8487-415e410372bf.png" alt="1"></p>
<p>存储系统从整体的分层一览，包括了主机/应用，存储介质，存储网络。对于存储来说就做了一件事：</p>
<blockquote>
<p>Here is a bit of data. Hold onto it. Give that same bit back to me when I ask for it.</p>
</blockquote>
<h3 id="2-_Application视角">2. Application视角</h3><p>每个系统都有会有很多应用程序运行在CPU上，对于这些Application来说，他们觉得自己有很多很多足够的可用内存。</p>
<h4 id="2-1_CPU和MMU">2.1 CPU和MMU</h4><p>计算机系统中有一个“内存管理单元”（MMU，Memory Management Unit）的概念，MMU负责与DRAM内存直接通信，并且获得一些可用的“页”<br>多租户：内存被某个进程（比如一个应用）独享，这些内存不能被其他进程重写。<br>地址：将CPU的物理地址翻译成独有的DRAM地址或者是很多行DRAMs<br>有了MMU以后，对于每个进程来说，他们就像是一个人独占了所有的内存一样。</p>
<h4 id="2-2_访问内存">2.2 访问内存</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232849/a28c5010-f9e9-11e5-9d03-ce555d9ca575.png" alt="2"></p>
<p>Application在他需要访问的时候，获取这些内存，在实际进行访问时，会发生如下事情：</p>
<ol>
<li>Application会问操作系统“Hey，我需要一些可用内存”</li>
<li>操作系统向MMU说，“能给我一些可以使用内存页不？”</li>
<li>MMU把一些可用的内存页给操作系统</li>
<li>操作系统把这些可用的内存页给Application。</li>
</ol>
<h4 id="2-3_分配内存">2.3 分配内存</h4><p>在2.2中，获取的那些内存，实际是可以分布在内存中的任何地方的（非连续），MMU在把这些内存给应用的时候会进行初始化操作，当然，当应用不再访问这些内存页的时候，也会MMU也会负责回收这些内存。</p>
<h4 id="2-4_加速访问">2.4 加速访问</h4><p>如果Application对内存的访问，每次都要都要从MMU获取的话，那太慢了，因此有个经验法则是：</p>
<blockquote>
<p>Always put storage/memory as close to the CPU as possible</p>
</blockquote>
<p>可以说在存储中，改善时间的限制是永恒不变的主题，然后访问DRAM的话，需要60-100ns的时间。我们需要更快的访问，甚至达到“0”时间访问。</p>
<h4 id="2-5_缓存的魔法">2.5 缓存的魔法</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232850/a8f5c67a-f9e9-11e5-8d4b-bc6f819e546a.png" alt="3"></p>
<p>于是在CPU中增加了一些缓存，当然缓存也是分级别的，对于L1缓存大概花费1ns以内，L2缓存大概花费3-6ns，没错，这使得每次访问从60-100ns提升了几十倍！</p>
<h4 id="2-6_更多的空间">2.6 更多的空间</h4><p>如果DRAM中也没有足够的空间时，这是你需要更多的持久化存储，比如说磁盘。当然直接去访问磁盘会非常的昂贵，当然这里指的是时间的花费非常昂贵。<br>在Jeff Dean大神的<a href="http://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="external">Software Engineering Advice from Building Large-Scale Distributed Systems</a>给出了数据：<br>L1缓存、L2缓存、主存、硬盘的访问分别是1ns、5ns、100ns、10,000,000ns级别;</p>
<p>举个比较形象的例子：你需要快递送个包裹，<br>快递一个1公里（L1）、5公里（L2）外的包裹，oops，可能马云爸爸保证当日达；<br>快递100公里（DRAM）的包裹，11点前下单，当日达，不能再快了！；<br>快递1000万公里（Disk）的快递，啊亲，你真的需要快递吗？这可是从地球到月球（38.4万公里）十几个来回的距离啊亲。</p>
<h4 id="2-7_下一站，使用存储设备">2.7 下一站，使用存储设备</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232851/b26c959e-f9e9-11e5-9ab0-191778aa8f94.png" alt="4"></p>
<p>存储设备和RAM不太一样，不会和CPU直接进行“对话”，而是有一些其他的部分来帮助他们完成对话，我们在存储视角进一步去讲述。</p>
<h3 id="3_Storage视角">3 Storage视角</h3><h4 id="3-1块设备的基本概念">3.1块设备的基本概念</h4><p><strong>块存储的IO流</strong><br>CPU和内存通过PCI总线（目前通常是PCIe）与存储进行连接，应用会向存储请求一段数据。系统会将数据转换成地址和位置信息，并转换成某种协议的形式。</p>
<p><strong>数据总线</strong><br><img src="https://cloud.githubusercontent.com/assets/1736354/14232852/b983a7e6-f9e9-11e5-9343-9d9461fdfbcf.png" alt="5"></p>
<p>CPU的指令需要转换或者说是进行适配，以便能够与存储设备进行“交流”，比如SCSI、IDE/ATA</p>
<p><strong>SCSI系统</strong><br>SCSI是一个很普遍、且向后兼容的，通常主要包含的组件有：</p>
<ul>
<li>Initiator：一些服务用它发起请求，可以视为登陆或者适配的一部分</li>
<li>Target：物理存储设备，可以是单个磁盘或者磁阵</li>
<li>Service Delivery Subsystem：Initiator和Target之间的通信（通常是网线）</li>
</ul>
<p><strong>块设备</strong><br><img src="https://cloud.githubusercontent.com/assets/1736354/14232855/c052f9dc-f9e9-11e5-932f-3c7df1db0fd6.png" alt="6"></p>
<p>Block：块是存储介质上的物理或者逻辑单元，也是文件系统或者磁盘写入的最小单元，所有的存储（包括文件存储、对象存储）最终都是需要与block进行对话。</p>
<p>磁盘包括了盘面（Platter）、磁道（Track）、扇区（Sector）。盘面是一个圆，磁道是一个环，扇区是环上的一段，数据的位置影响性能。块由扇区组成，每一个块也有一个唯一的号码，文件系统的一切操作都是由对blocks操作构成。</p>
<h4 id="3-2_文件与块">3.2 文件与块</h4><p>对于应用来说，他们看到的都是文件；而对于存储来说，看到是块。因此需要某种方式将他们联系起来。对于文件来说，应用看到的是一个连续的“空间”，然而实际上，文件是由很多块组成的，而这些块就是磁盘上的块，这些块分布在磁盘的不同区域。</p>
<h4 id="3-3_文件系统">3.3 文件系统</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232859/c7502796-f9e9-11e5-96af-ba7d703b11b4.png" alt="7"></p>
<p>在操作系统中，其内核中会有一个文件系统，文件系统维护着在磁盘上的文件名，文件系统知道这些文件与磁盘上块位置的对应关系，同时还需要管理着磁盘空间、权限、所属、加密、文件缓存等等。</p>
<p>驱动控制：硬盘被驱动控制来操控，接收文件系统的通过某种协议（比如SCSI）下发的一些I/O命令</p>
<p>卷管理：文件系统和设备驱动中间存在着卷管理，卷管理负责抽象出一层“假的”磁盘供操作系统使用.</p>
<h4 id="3-4_文件系统与驱动">3.4 文件系统与驱动</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232864/d20afa1c-f9e9-11e5-9ce6-2141048f2328.png" alt="8"><br>因此，对于文件系统来说，需要将应用程序所看到的“虚拟地址”翻译到真正的设备地址。例如访问一个文件时，文件系统会先会先在找到对应的逻辑块地址（Logical Block Adress, LBA），然后通过scsi系统进一步访问，对应到磁盘上的物理块地址。</p>
<h4 id="3-5_Inode">3.5 Inode</h4><p>Inode是文件的原数据，用来记录文件的所述、权限、block信息等。一个Inode会对应一个文件或目录，通过inode就可以将文件与某些block对应起来。</p>
<p>也就是说通过inode信息，就可以完全的找到一个文件，包括这个文件所对应的data block。<br>对于目录而言，data block包含了目录的内容，即该目录下文件及其这些文件对应inode的列表。<br>对于文件而言，data block则包含了文件的实际内容。</p>
<h4 id="3-3_举个例子">3.3 举个例子</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232879/210e7b70-f9ea-11e5-96aa-5f79cb5a2870.png" alt="9"></p>
<p>当执行<code>cat /home/foo.txt</code>命令时，会对foo.txt文件进行访问，经历了以下步骤：</p>
<ol>
<li>获取”/“内容；</li>
<li>查找”home”的node信息（inode 38）;</li>
<li>获取”home”目录内容；</li>
<li>查找”foo.txt”的inode信息（inode 40）；</li>
<li>根据inode获得block numbers；</li>
<li>文件系统将block number转换为真正的block number（data block 101）；</li>
<li>通过SCSI Controller读取block内容。</li>
</ol>
<p>至此，我们可以看到存储数据是这样走自己的路的：</p>
<ol>
<li>应用程序说我要获取/home/foo.txt的内容</li>
<li>操作系统依次检查L1、L2、RAM中是否存在，若均不存在则在文件系统中查找</li>
<li>文件系统先检查Unified Buffer Cache中是否存在该文件，如果不存在则去目录中查找“home”文件</li>
<li><strong>(访问磁盘)</strong>读取”home”目录的内容，并把inode信息放到buffer cache以便下次访问，最后根据目录内容查询到foo.txt的inode</li>
<li><strong>(访问磁盘)</strong>读取foo.txt的inode，获取到data block号</li>
<li><strong>(访问磁盘)</strong>文件系统读取data block，最终将数据返回给应用，并且把数据存储在L1、L2、RAM和UBC中，加速下次访问。</li>
</ol>
<p>我们可以看到，访问/home/foo.txt有3次磁盘访问：<br>第1次是读取home的inode，获取foo.txt的inode号<br>第2次是读取foo.txt的inode，获取data block号<br>第3次是读取data block，获取真正的内容</p>
<p>然而，我们对于机械硬盘来说，每次需要磁盘转到正确的地址才能访问到内容，尤其是这些data block若未按顺序存储，就需要“下一圈”的时候再访问，这样会很耗时，也就是说访问磁盘的时间和数据在磁盘上的位置非常相关。所以Flash技术(如flash-based SSD)就腾空出世了，可以做到任意数据的随机访问，就大大减少了数据访问时间。</p>
<h3 id="4-_Network视角">4. Network视角</h3><p>我们先回顾一下到网络这里都经历了什么：应用、操作系统、文件系统、缓冲缓存、卷管理、设备驱动、硬件控制、SCSI，一层一层递进访问。</p>
<h4 id="4-1_存储网络">4.1 存储网络</h4><p>应用和存储视角已经可以工作了，而在应用和存储之间加一层网络，因此目前的玩法主要包括以下几种形式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232884/329592ca-f9ea-11e5-858a-d51abd697d94.png" alt="10"></p>
<p>这些知识在之前的<a href="http://yikun.github.io/2016/02/03/%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">存储基础知识学习</a>中有大概的涉及过。</p>
<p>对于文件存储，常常使用NAS的架构，更灵活；而基于块的存储则常使用SAN的方式，保证性能。</p>
<h4 id="4-2_存储区域网络">4.2 存储区域网络</h4><p>下面是存储区域网络(SAN)常见的几种网络协议格式以及组网方式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232886/381735dc-f9ea-11e5-8155-ed14516287ab.png" alt="11"></p>
<h3 id="5-_最后的大招">5. 最后的大招</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png" alt="12"></p>
<p>至此，我们已经将整个数据存储相关的部分都进行了解析，这下对存储数据包的一生有所了解了吧。</p>
<h3 id="参考资料：">参考资料：</h3><ul>
<li>登州知府的微博</li>
<li>Jeff Dean <a href="https://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="external">Designs, Lessons and Advice from Building Large Distributed Systems</a></li>
<li>淘宝杨传辉：分布式系统工程实践</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/inode.html" target="_blank" rel="external">理解inode</a></li>
<li><a href="https://cseweb.ucsd.edu/classes/su09/cse120/lectures/Lecture10.pdf" target="_blank" rel="external">CSE 120: Principles of Computer Operating Systems, Lecture 10-Disks and File Systems</a></li>
<li><a href="https://www.brighttalk.com/webcast/663/169543" target="_blank" rel="external">“Life of a Storage Packet”</a></li>
<li><a href="http://www.snia.org/sites/default/files/ESF/Life_of_a_Storage_Packet_%28Walk%29_Final.pdf" target="_blank" rel="external">Life of a Storage Packet.ppt</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近认认真真学习了一个叫<a href="https://www.brighttalk.com/webcast/663/169543">《Life of a Storage Packet》</a>讲座，借助这个讲座将整个存储的过程理解了下，不放过任何一个有疑问的点。这篇文章算是对讲座的理解和自己收获的总结，同时也为那些对存储系统不够了解又想要了解的初学者，展现一个存储数据包的“生命”。这个演讲主要聚焦在“整体的存储”，强调存储系统中各个基本元素的关系，并且尽可能简单、清楚地用一种不同的方式可视化一些存储的概念。</p>
<p>先上一张大图，可以说这篇文章目的就是解释这个图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/14232888/3dc0f734-f9ea-11e5-877c-8b37b7addbdd.png" alt="12"><br>]]>
    
    </summary>
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack源码分析-Cinder中的调度机制]]></title>
    <link href="http://yikun.github.io/2016/03/05/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E4%B8%AD%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yikun.github.io/2016/03/05/OpenStack源码分析-Cinder中的调度机制/</id>
    <published>2016-03-04T16:45:44.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>整理了一下目前cinder中支持的调度的Filter和Weigher：<br><img src="https://cloud.githubusercontent.com/assets/1736354/15445332/29c1730c-1f2f-11e6-8706-4b38f5fc9e0d.png" alt="scheduler"><br>后面结合源码看下实现，留坑~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>整理了一下目前cinder中支持的调度的Filter和Weigher：<br><img src="https://cloud.githubusercontent.com/assets/1736354/15445332/29c1730c-1f2f-11e6-8706-4b38]]>
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack源码分析-Service启动流程]]></title>
    <link href="http://yikun.github.io/2016/03/05/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/03/05/OpenStack源码分析-Service启动流程/</id>
    <published>2016-03-04T16:38:21.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/1736354/13372372/d42f0c0a-dd7b-11e5-9656-1f2ff817e53a.png" alt="cinder service launcher"><br><a id="more"></a><br>如图所示，主要流程分为两大部分：</p>
<ol>
<li>创建Service<br>service.Service.create方法实现了这个过程。在创建服务的过程中，会根据host、binary、manager来创建服务，对于cinder-volume，则为cinder.service。</li>
<li>启动Service<br>launcher.launch_service会将第一步创建的服务启动起来，然后调用_start_child方法。<br>在_start_child方法中，会调用os.fork接口创建子进程，创建的进程数由launch_service的workers参数确定，目前默认为1个进程。<br>在子进程启动后，调用_child_process进行服务启动，调用common中的launch_service，此过程主要将service添加到线程池中，并启动。在启动时，会回调run_service进而调用Service.start方法。<br>Service正是cinder.service在此步中，会调用manager的init_host完成卷状态的检查。</li>
</ol>
<p>参考资料：<br><a href="http://blog.csdn.net/hackerain/article/details/7888686" target="_blank" rel="external">http://blog.csdn.net/hackerain/article/details/7888686</a><br><a href="http://www.openstack.cn/?p=437" target="_blank" rel="external">http://www.openstack.cn/?p=437</a><br><a href="http://lynnkong.iteye.com/blog/1829960" target="_blank" rel="external">http://lynnkong.iteye.com/blog/1829960</a><br><a href="http://docs.openstack.org/developer/nova/services.html" target="_blank" rel="external">http://docs.openstack.org/developer/nova/services.html</a><br><a href="http://www.cnblogs.com/sammyliu/p/4272611.html" target="_blank" rel="external">http://www.cnblogs.com/sammyliu/p/4272611.html</a><br><a href="http://www.cnblogs.com/littlebugfish/p/4022907.html" target="_blank" rel="external">http://www.cnblogs.com/littlebugfish/p/4022907.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://cloud.githubusercontent.com/assets/1736354/13372372/d42f0c0a-dd7b-11e5-9656-1f2ff817e53a.png" alt="cinder service launcher"><br>]]>
    
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack源码分析-挂载卷流程]]></title>
    <link href="http://yikun.github.io/2016/03/05/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8C%82%E8%BD%BD%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/03/05/OpenStack源码分析-挂载卷流程/</id>
    <published>2016-03-04T16:32:58.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_挂卷流程">1. 挂卷流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13493796/5a1fda3a-e17b-11e5-98be-2bca8a26e0bb.png" alt="volume attach"><br>    当Nova volume-attach server volume执行后，主要经过以下几步：<br>a.    Nova Client解析指令，通过RESTFUL接口访问nova-api；<br>b.    Nova API解析响应请求获取虚拟机的基本信息，然后向cinder-api发出请求保留，并向nova-compute发送RPC异步调用请求卷挂载；<br>c.    Nova-compute向cinder-api初始化信息，并根据初始化连接调用Libvirt的接口完成挂卷流程；<br>d.    进而调用cinder-volume获取连接，获取了连接后，通过RESTFUL请求cinder-api进行数据库更新操作。<br><a id="more"></a></p>
<h3 id="2-_源码详解">2. 源码详解</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13482134/b76e1680-e125-11e5-80d6-1e0f925fca48.png" alt="nova volume attach"></p>
<h4 id="1-_Nova_Client">1. Nova Client</h4><p>(1)    \nova\nova\api\openstack\compute\contrib\volumes.py<br>在Nova Client进程中，由VolumeAttachmentController接受挂载请求</p>
<h4 id="2-_Nova_API">2. Nova API</h4><p>(1)    \nova\nova\compute\api.py<br>VolumeAttachmentController的create函数用于响应卷挂载的请求。<br>(2)    \nova\nova\volume\cinder.py<br>compute.API调用attach_volume函数，分别获取卷信息、检查状态并做保留盘操作<br>(3)    \nova\nova\compute\rpcapi.py<br>通过attach_colume发送rpc调用Compute中的_attach_volume函数</p>
<h4 id="3-_Nova_Compute">3. Nova Compute</h4><p>(1)    \nova\nova\compute\manager.py<br>ComputeManager进行核心调用，首先获取initiator，然后初始化连接。<br>(2)    \nova\nova\virt\block_device.py<br>DriverVolumeBlockDevice初始化连接后调用connect_volume函数进行卷的挂载<br>(3)    \nova\nova\virt\libvirt\volume.py<br>LibvirtISCSIVolumeDriver的connect_volume是调用最核心流程，分为多路径和单路径两种情况，在单路径的调用中会执行login、检查session、设置自启动等操作，如果一次未连接成功则还会每tries ** 2秒重复调用，直到达到调用的限制。其中牵扯到的指令有：<br>a. 尝试连接<br>iscsiadm -m node -T target_iqn -p target_protal<br>b. 连接失败重新建立连接<br>iscsiadm -m node -T target_iqn -p target_protal -op new<br>iscsiadm -m node -T target_iqn -p target_protal —op update -n node.session.auth.authmethod -v auth_method<br>iscsiadm -m node -T target_iqn -p target_protal —op update -n node.session.auth.username -v auth_username<br>iscsiadm -m node -T target_iqn -p target_protal —op update -n node.session.auth.password -v auth_password<br>c. 检查session，登陆<br>iscsiadm -m session检查是否登录成功<br>iscsiadm –m node –T targetname –p ip —login 登陆建立session<br>d. 设置为随机器启动而启动<br>iscsiadm -m node -T target_iqn -p target_protal —op update -n node.startup -v automatic<br>iscsiadm -m node -T target_iqn -p target_protal –rescan</p>
<h4 id="4-_Cinder_API">4. Cinder API</h4><p>(1)    \cinder\cinder\volume\api.py<br>volume.API会继续调用VolumeAPI进行挂卷的数据库更新<br>(2)    \cinder\cinder\volume\rpcapi.py<br>VolumeAPI通过rpc调用VolumeManager</p>
<h4 id="5-_Cinder_Volume">5. Cinder Volume</h4><p>\cinder\cinder\volume\manager.py<br>VolumeManager会完成更新数据库的操作。</p>
<p><a href="http://aspirer.wang/?p=164" target="_blank" rel="external">http://aspirer.wang/?p=164</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_挂卷流程">1. 挂卷流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13493796/5a1fda3a-e17b-11e5-98be-2bca8a26e0bb.png" alt="volume attach"><br>    当Nova volume-attach server volume执行后，主要经过以下几步：<br>a.    Nova Client解析指令，通过RESTFUL接口访问nova-api；<br>b.    Nova API解析响应请求获取虚拟机的基本信息，然后向cinder-api发出请求保留，并向nova-compute发送RPC异步调用请求卷挂载；<br>c.    Nova-compute向cinder-api初始化信息，并根据初始化连接调用Libvirt的接口完成挂卷流程；<br>d.    进而调用cinder-volume获取连接，获取了连接后，通过RESTFUL请求cinder-api进行数据库更新操作。<br>]]>
    
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[优雅地调试OpenStack]]></title>
    <link href="http://yikun.github.io/2016/02/23/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%B0%83%E8%AF%95OpenStack/"/>
    <id>http://yikun.github.io/2016/02/23/优雅地调试OpenStack/</id>
    <published>2016-02-22T16:00:52.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>恩，题目首先要起的高逼格一些。2333。</p>
<p>在前面学习代码的过程中，主要通过源码来学习，开始学起来确实有点费劲，因为欠缺对OpenStack的整体的意识，于是<a href="http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/" target="_blank" rel="external">搭建OpenStack开发环境</a>对OpenStack的运行环境和使用有了初步认知。也看到了启动OpenStack后的一些相关进程，那么这些进程是如何与源码对应起来的呢？如何去调试OpenStack呢？本篇文章就讲下我的探索。<br><a id="more"></a></p>
<h3 id="1-_初识Python调试">1. 初识Python调试</h3><p>在<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/" target="_blank" rel="external">Python 代码调试技巧</a>一文中提到了pdb、PyCharm、PyDev、日志等几种常见的调试方法。具体可以看看这篇文章，写的很详细，不赘述。</p>
<p>因为PyCharm出色的用户体验（那写代码就是要开心嘛），所以决定使用PyCharm进行调试，但是问题来了，在远端（如虚拟机或者服务器）服务已经启动起来了，我们如何进行调试呢？答案就是Remote Debug。</p>
<h3 id="2-_启动OpenStack服务">2. 启动OpenStack服务</h3><p>在<a href="http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/" target="_blank" rel="external">搭建OpenStack开发环境</a>一文中，我们介绍了使用devstack启动开发环境，我们通过DevStack启动各个服务后：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ... ...</span><br><span class="line">This is your host IP <span class="string">address:</span> <span class="number">192.168</span>.56.101</span><br><span class="line">This is your host IPv6 <span class="string">address:</span> ::<span class="number">1</span></span><br><span class="line">Horizon is now available at <span class="string">http:</span><span class="comment">//192.168.56.101/dashboard</span></span><br><span class="line">Keystone is serving at <span class="string">http:</span><span class="comment">//192.168.56.101:5000/</span></span><br><span class="line">The <span class="keyword">default</span> users <span class="string">are:</span> admin and demo</span><br><span class="line">The <span class="string">password:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>使用screen来查看：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -x <span class="built_in">stack</span></span><br></pre></td></tr></table></figure></p>
<p>不得不说screen真是神器，虚拟了多个Terminal的Tab，使用”Ctrl+A+P”和”Ctrl+A+N”可以切换tab，使用”Ctrl+A+D”可以断开连接，在每个tab中可以使用“Ctrl+C”来中断进程：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224079/e3309ca4-d9c1-11e5-897a-04ed2b6c8e82.png" alt="qq20160223-0 2x"><br>我们看到在图中，有Nova和Cinder相关的进程，并且停在了cinder-api的进程上，每个tab中的进程都在运行着。</p>
<h3 id="3-_编辑代码">3. 编辑代码</h3><p>因为代码大部分都在远端的运行（比如虚拟机），而开发环境则在近端（比如宿主机），如果在远端和近端都维护一套代码，不可避免的会拷来拷去，有时拷错了还得找半天原因。所以得想办法把远端的代码“共享”到近端。因此，我们使用sshfs共享文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~  sshfs stack@<span class="number">192.168</span>.<span class="number">56.101</span>:/opt/stack /Users/jiangyikun/development/openstack/<span class="tag">code</span></span><br><span class="line">➜  ~  ls /Users/jiangyikun/development/openstack/<span class="tag">code</span></span><br><span class="line">cinder            heat              logs              noVNC             requirements</span><br><span class="line">data              heat-cfntools     neutron           nova              status</span><br><span class="line">devstack<span class="class">.subunit</span>  heat-templates    neutron-fwaas     os-apply-config   swift</span><br><span class="line">dib-utils         horizon           neutron-lbaas     os-collect-config tempest</span><br><span class="line">glance            keystone          neutron-vpnaas    os-refresh-config</span><br></pre></td></tr></table></figure></p>
<p>达到的目的就是，我们编辑<code>/Users/jiangyikun/development/openstack/code</code>的时候，就相当于在远端编辑<code>/opt/stack</code>。在Windows下，也有win-sshfs工具。</p>
<h3 id="4-_启动调试服务器">4. 启动调试服务器</h3><p>当我们修改好代码后，就可以进行调试了。调试的原理大致是在近端启动一个debug server，然后，在代码中添加连接服务器的动作，这样，当代码运行到那段调试代码时，便会和调试服务器建立连接。在我的实验环境中，调试环境是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13257974/1042affa-da8c-11e5-99a0-882e5b229354.png" alt="openstack"><br>可以看到在宿主机和虚拟机有2条通路，一条是NAT，作用是让虚拟机通过宿主机的公网IP上网，从而保证Devstack能够顺利启动OpenStack，第二条是Host Only，保证在宿主机内可以对虚拟机进行SSH访问、sshfs文件挂载以及调试。</p>
<p>因此我们先配置一下远程调试的配置：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224336/fab25a06-d9c2-11e5-8547-b284fe7df997.png" alt="qq20160223-1 2x"></p>
<p>然后，我们就可以把由于几个调试的服务都启动起来了，例如，我们要调试跟踪Cinder的创建过程，我们就首先建立三个远程调试，其次将调试代码添加到入口处并保存，最后增加断点：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224668/8e9949e0-d9c4-11e5-850f-357b0eaa41c1.png" alt="qq20160223-2 2x"><br>使用Ctrl+c把修改过代码的进程都结束，然后按“上”重新执行指令：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224732/db14a4ea-d9c4-11e5-8e83-706b35f507f5.png" alt="qq20160223-3 2x"><br>重启服务后，代码就生效了，当代码运行到我们需要连接到调试服务的代码后，就会进入断点了：<br><img src="https://cloud.githubusercontent.com/assets/1736354/13224833/4a55fed0-d9c5-11e5-8f60-38589e40c34c.png" alt="qq20160223-4 2x"><br>接下来就随心所欲的进行调试吧！</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://bingotree.cn/?p=687" target="_blank" rel="external">使用DEVSTACK搭建OPENSTACK可remote debug的开发测试环境</a><br><a href="http://kiwik.github.io/openstack/2013/12/21/DevStack-install-in-China/" target="_blank" rel="external">DevStack-install-in-China</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>恩，题目首先要起的高逼格一些。2333。</p>
<p>在前面学习代码的过程中，主要通过源码来学习，开始学起来确实有点费劲，因为欠缺对OpenStack的整体的意识，于是<a href="http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/">搭建OpenStack开发环境</a>对OpenStack的运行环境和使用有了初步认知。也看到了启动OpenStack后的一些相关进程，那么这些进程是如何与源码对应起来的呢？如何去调试OpenStack呢？本篇文章就讲下我的探索。<br>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack源码分析-Cinder删除卷流程]]></title>
    <link href="http://yikun.github.io/2016/02/21/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E5%88%A0%E9%99%A4%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/02/21/OpenStack源码分析-Cinder删除卷流程/</id>
    <published>2016-02-21T11:56:59.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_Cinder删除卷整体流程">1. Cinder删除卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130440/f8979c4c-d61e-11e5-8665-84b9d2f928f9.png" alt="delete"></p>
<p>删除卷流程比较简单，主要就是cinder-api解析Cilent的指令，并响应，发送RPC调用cinder-volume的delete操作，详细流程如下：<br>a. Client发送删除指令，通过RESTful接口访问cinder-api；<br>b. Cinder-api解析响应请求，通过RPC调用cinder-volume；<br>c. Cinder-volume通过调用Driver的delete函数进行删除。</p>
<h3 id="2-_源码详解">2. 源码详解</h3><p> <img src="https://cloud.githubusercontent.com/assets/1736354/13130451/0e77ce74-d61f-11e5-91e9-9b63918beef1.png" alt="cinder delete"></p>
<h4 id="2-1_Cinder_API">2.1 Cinder API</h4><p>(1) Cinder\api\v2\volumes.py<br>VolumeController的delete函数响应请求，首先从API获取Volume对象信息，然后，调用API的delete对对象进行删除；<br>(2) Cinder\volume\api.py<br>API.delete的对卷的状态进行检查，并更新状态为“deleting”，然后调用rpcapi的delete_volume函数</p>
<h4 id="2-2_Cinder_Volume">2.2 Cinder Volume</h4><p>(1) Cinder\volume\rpcapi.py<br>VolumeAPI函数投递一个远程消息，通过消息队列远程调用cinder volume的delete_volume函数。<br>(2) Cinder\volume\manager<br>最终通过VolumeManager调用dirver的delete_volume对卷进行删除。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_Cinder删除卷整体流程">1. Cinder删除卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130440/f8979c4c-d61e-11e5-8]]>
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack源码分析-Cinder创建卷流程]]></title>
    <link href="http://yikun.github.io/2016/02/14/OpenStack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cinder%E5%88%9B%E5%BB%BA%E5%8D%B7%E6%B5%81%E7%A8%8B/"/>
    <id>http://yikun.github.io/2016/02/14/OpenStack源码分析-Cinder创建卷流程/</id>
    <published>2016-02-14T09:43:30.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_Cinder创卷整体流程">1. Cinder创卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130372/71de5178-d61e-11e5-8d7c-6b9f0a244e41.png" alt="create"></p>
<p>如整体架构图所示，创建卷涉及的答题步骤主要有以下几步：<br>a. Client发送请求，通过RESTFUL接口访问cinder-api。<br>b. Api解析响应请求，api解析由Client发送来的请求，并通过rpc进一步调用cinder-scheduler。<br>c. Scheduler对资源进行调度，scheduler选择合适的节点进行。<br>d. Volume调用Driver创建卷，volume通过指定Driver进行卷的创建。</p>
<h3 id="2-_源码详解">2. 源码详解</h3><p>代码的整体流程如下所示：<br> <img src="https://cloud.githubusercontent.com/assets/1736354/13033012/82f1e54e-d342-11e5-835c-e8f6d3baff40.png" alt="cinder seq"><br>从上图可以看出，整体处理流程包括三大部分，分别是API、Scheduler、Volume三部分。</p>
<h4 id="2-1_Cinder_API部分">2.1 Cinder API部分</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130422/b4a5c3b0-d61e-11e5-8781-52c9586b9c7d.png" alt="create_api"></p>
<p>(1) cinder\api\v2\volumes.py<br>VolumeController. create函数对创建请求进行响应，首先函数对volume_type、metadata、snapshot等信息进行检查，然后调用Volume API的create进行创建。<br>(2) cinder\volume\api.py<br>API.create函数对source_volume、volume_type等参数进行进一步检查，并调用cinder.volume.flows.api.get_flow来创建。<br>(3) cinder\volume\flows\api\create_volume.py<br>get_flow函数检查Quata，最后创建EntryCreateTask及VolumeCastTask等任务，<br>其中EntryCreateTask会将卷的创建过程写入数据库，此时卷的状态为”creating”。<br>VolumeCastTask.excute函数会调用VoumeCastTask._cast_create_volume<br>VolumeCastTask._cast_create_volume函数，如果未传入host，则会经过调度进行创建卷，通过scheduler_rpcapi.create_volume创建卷；如果未传入host则直接交由Volume Manager去创建卷。</p>
<p>至此为止，Cinder API部分完成了自己的工作。</p>
<h4 id="2-2_Cinder_Scheduler">2.2 Cinder Scheduler</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130398/8ceff976-d61e-11e5-8ea7-08661eebb7af.png" alt="create_sche"></p>
<p>(1) cinder\scheduler\rpcapi.py（此步还属于cinder-api）<br>SchedulerAPI.create_volume函数会通过消息异步调用SchedulerManager.create_volume函数。<br>(2) cinder\scheduler\manager.py<br>SchedulerManager.create_volume函数，使用自己的flow来创建volume，其中还传入了Driver。<br>(3) cinder\scheduler\flows\create_volume.py<br>get_flow函数，创建ScheduleCreateVolumeTask<br>ScheduleCreateVolumeTask.execute函数，会调用driver_api.schedule_create_volume<br>(4) cinder\scheduler\filter_scheduler.py<br>FilterScheduler. schedule_create_volume函数，更新数据库，最后通过消息队列请求调用volume_rpcapi.create_volume。</p>
<h4 id="2-3_Cinder_Volume">2.3    Cinder Volume</h4><p> <img src="https://cloud.githubusercontent.com/assets/1736354/13130404/93c802e8-d61e-11e5-87e7-a01a64765a3b.png" alt="create_volume"><br>(1) /cinder/volume/rpcapi.py（此步还属于cinder-scheduler）<br>VolumeAPI.create_volume会通过消息队列远程调用VolumeManager.create_volume<br>(2) /cinder/volume/manager.py<br>VolumeManager函数也使用flow来创建volume，执行CreateVolumeFromSpecTask这个任务<br>(3) /cinder/volume/flows/manager/create_volume.py<br>CreateVolumeFromSpecTask.excute，这个函数会根据创建的不同类别，去创建卷，例如调用create_raw_volume，最终会调用具体的driver进行卷的创建。<br>在完成创卷后，CreateVolumeOnFinishTask这个任务，启动更新数据库，将卷更新为available状态。</p>
<p>我们可以看到在创建卷的过程中盘的状态会从“creating”状态变为“available”状态。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_Cinder创卷整体流程">1. Cinder创卷整体流程</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/13130372/71de5178-d61e-11e5-8d7]]>
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建OpenStack开发环境]]></title>
    <link href="http://yikun.github.io/2016/02/10/%E6%90%AD%E5%BB%BAOpenStack%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yikun.github.io/2016/02/10/搭建OpenStack开发环境/</id>
    <published>2016-02-09T16:10:09.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>前段时间主要了解了一些OpenStack相关的基础性东西，现在希望通过安装使用来增强一下对系统整体的认识，最近也读了一篇文章<a href="http://www.csdn.net/article/2014-04-10/2819247-how-to-learn-opensouce-project-&amp;-ceph" target="_blank" rel="external">如何学习开源项目</a>，基本和我的想法很类似，所以基本上也就是按照这个节奏来的。不说废话了，开始。<br><a id="more"></a></p>
<h3 id="1-_环境准备">1. 环境准备</h3><p>整体的环境安装是基于[devstack]来搭建，本来就是一个脚本一个配置文件就可以了，不过因为部分网络环境比较“艰苦”，所以需要做一些优化，所以需要做一些准备工作。</p>
<h4 id="1-1_安装系统">1.1 安装系统</h4><p>Virtual Box，<a href="https://www.virtualbox.org/" target="_blank" rel="external">下载</a><br>Ubuntu 14.04，<a href="http://www.ubuntu.com/download/desktop/install-ubuntu-desktop" target="_blank" rel="external">下载</a><br>网络的话，我是选择了NAT模式，保证虚拟机能够通过宿主机来上网，然后另设了一个Host Only网卡做SSH访问，最近突然发现还可以用NAT端口转发的方式（把22端口转发到主机）完成类似功能，这样就只需要一个网卡了。</p>
<h4 id="1-2_基本工具">1.2 基本工具</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#23433;&#35013;Git&#10;sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h4 id="1-3_加速Python源">1.3 加速Python源</h4><p>为了加速下载速度，对Python源进行优化，这里用豆瓣的源。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim ~/.pip/pip.conf</span></span><br><span class="line">[global]</span><br><span class="line"><span class="variable">timeout =</span> <span class="number">6000</span></span><br><span class="line"><span class="variable">trusted-host =</span> pypi.douban.com</span><br><span class="line"><span class="variable">index-url =</span> http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure></p>
<h4 id="1-4_加速Ubuntu源">1.4 加速Ubuntu源</h4><p>为了加速下载速度，对Ubuntu源进行优化，这里用网易的源。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># vim <span class="regexp">/etc/</span>apt/sources.list</span><br><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span></span><br><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span></span><br><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span></span><br><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br><span class="line">deb <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span></span><br><span class="line">deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty main restricted universe multiverse</span></span><br><span class="line">deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse</span></span><br><span class="line">deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse</span></span><br><span class="line">deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse</span></span><br><span class="line">deb-src <span class="string">http:</span><span class="comment">//mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-_下载Devstack">2. 下载Devstack</h3><p>使用Git安装脚本切换到自己需要的版本：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># 下载devstack</span></span><br><span class="line">git clone https:<span class="comment">//git.openstack.org/openstack-dev/devstack</span></span><br><span class="line"><span class="preprocessor"># 切换版本</span></span><br><span class="line">git checkout stable/liberty</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_创建Stack用户">3. 创建Stack用户</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devstack/tools/create-<span class="keyword">stack</span>-user.<span class="keyword">sh</span>; <span class="keyword">su</span> <span class="keyword">stack</span></span><br></pre></td></tr></table></figure>
<h4 id="4-_创建local-conf">4. 创建local.conf</h4><p>创建local.conf文件，并且写入自己的配置，可以参考官方的<a href="http://docs.openstack.org/developer/devstack/configuration.html#minimal-configuration" target="_blank" rel="external">Minimal configuration</a>，我的配置如下所示，参考<a href="http://www.chenshake.com/install-ubuntu-14-04-devstack/" target="_blank" rel="external">链接</a>做的。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vim ~/devstack/local.conf</span></span><br><span class="line">[local|localrc]]</span><br><span class="line"><span class="variable">GIT_BASE=</span>https://github.com</span><br><span class="line"><span class="comment"># Define images to be automatically downloaded during the DevStack built process.</span></span><br><span class="line"><span class="variable">IMAGE_URLS=</span><span class="string">"http://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img"</span></span><br><span class="line"><span class="comment"># Credentials</span></span><br><span class="line"><span class="variable">DATABASE_PASSWORD=</span><span class="number">1</span></span><br><span class="line"><span class="variable">ADMIN_PASSWORD=</span><span class="number">1</span></span><br><span class="line"><span class="variable">SERVICE_PASSWORD=</span><span class="number">1</span></span><br><span class="line"><span class="variable">SERVICE_TOKEN=</span><span class="number">1</span></span><br><span class="line"><span class="variable">RABBIT_PASSWORD=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="variable">HOST_IP=</span><span class="number">192.168</span>.<span class="number">56.102</span></span><br><span class="line"><span class="variable">SERVICE_HOST=</span><span class="number">192.168</span>.<span class="number">56.102</span></span><br><span class="line"><span class="variable">MYSQL_HOST=</span><span class="number">192.168</span>.<span class="number">56.102</span></span><br><span class="line"><span class="variable">RABBIT_HOST=</span><span class="number">192.168</span>.<span class="number">56.102</span></span><br><span class="line"><span class="variable">GLANCE_HOSTPORT=</span><span class="number">192.168</span>.<span class="number">56.102</span>:<span class="number">9292</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Work offline(不需要更新时打开)</span></span><br><span class="line"><span class="comment"># OFFLINE=True</span></span><br><span class="line"><span class="comment"># Reclone each time(需要更新时打开)</span></span><br><span class="line"><span class="variable">RECLONE=</span>yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Logging</span></span><br><span class="line"><span class="comment"># -------</span></span><br><span class="line"><span class="comment"># By default ``stack.sh`` output only goes to the terminal where it runs. It can</span></span><br><span class="line"><span class="comment"># be configured to additionally log to a file by setting ``LOGFILE`` to the full</span></span><br><span class="line"><span class="comment"># path of the destination log file. A timestamp will be appended to the given name.</span></span><br><span class="line"><span class="variable">LOGFILE=</span>/opt/stack/logs/stack.sh.log</span><br><span class="line"><span class="variable">VERBOSE=</span>True</span><br><span class="line"><span class="variable">LOG_COLOR=</span>True</span><br><span class="line"><span class="variable">SCREEN_LOGDIR=</span>/opt/stack/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># the number of days by setting ``LOGDAYS``.</span></span><br><span class="line"><span class="variable">LOGDAYS=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Database Backend MySQL</span></span><br><span class="line">enable_service mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># RPC Backend RabbitMQ</span></span><br><span class="line">enable_service rabbit</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Keystone - OpenStack Identity Service</span></span><br><span class="line">enable_service key</span><br><span class="line"></span><br><span class="line"><span class="comment"># Horizon - OpenStack Dashboard Service</span></span><br><span class="line">enable_service horizon</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Swift - Object Storage Service without replication.</span></span><br><span class="line">enable_service s-proxy s-object s-container s-account</span><br><span class="line"><span class="variable">SWIFT_HASH=</span><span class="number">66</span>a3d6b56c1f479c8b4e70ab5c2000f5</span><br><span class="line"><span class="variable">SWIFT_REPLICAS=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Glance - OpenStack Image service</span></span><br><span class="line">enable_service g-api g-reg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable Cinder - Block Storage service for OpenStack</span></span><br><span class="line">enable_service cinder c-api c-vol c-sch c-bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># Branches</span></span><br><span class="line"><span class="variable">KEYSTONE_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">NOVA_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">NEUTRON_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">SWIFT_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">GLANCE_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">CINDER_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">HEAT_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">TROVE_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">HORIZON_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">SAHARA_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">CEILOMETER_BRANCH=</span>stable/liberty</span><br><span class="line"><span class="variable">TROVE_BRANCH=</span>stable/liberty</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_开始安装">5. 开始安装</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> devstack; ./<span class="keyword">stack</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>最终安装完毕：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#... ...</span><br><span class="line">This is your host IP <span class="string">address:</span> <span class="number">192.168</span>.56.102</span><br><span class="line">This is your host IPv6 <span class="string">address:</span> ::<span class="number">1</span></span><br><span class="line">Horizon is now available at <span class="string">http:</span><span class="comment">//192.168.56.102/dashboard</span></span><br><span class="line">Keystone is serving at <span class="string">http:</span><span class="comment">//192.168.56.102:5000/</span></span><br><span class="line">The <span class="keyword">default</span> users <span class="string">are:</span> admin and demo</span><br><span class="line">The <span class="string">password:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="问题解决">问题解决</h3><p>问题： InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately [duplicate] 参考<a href="http://stackoverflow.com/questions/29134512/insecureplatformwarning-a-true-sslcontext-object-is-not-available-this-prevent" target="_blank" rel="external">链接</a>解决的：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> libffi-dev libssl-dev</span><br><span class="line">sudo pip <span class="keyword">install</span> requests[security]</span><br><span class="line">sudo pip <span class="keyword">install</span> <span class="comment">--upgrade pyopenssl ndg-httpsclient pyasn1 pip</span></span></span><br></pre></td></tr></table></figure></p>
<p>问题： ERROR: tox version is 2.1.1, required is at least 2.3.1<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62; sudo pip install &#39;tox==2.3.1&#39;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考链接">参考链接</h3><p><a href="http://www.chenshake.com/install-ubuntu-14-04-devstack/" target="_blank" rel="external">Ubuntu 14.04 Devstack安装Liberty</a><br><a href="http://bingotree.cn/?p=687" target="_blank" rel="external">使用DEVSTACK搭建OPENSTACK可remote debug的开发测试环境</a><br><a href="http://docs.openstack.org/developer/devstack/" target="_blank" rel="external">DevStack - an OpenStack Community Production</a><br><a href="http://docs.openstack.org/developer/devstack/stack.sh.html" target="_blank" rel="external">stack.sh</a><br><a href="http://docs.openstack.org/developer/devstack/configuration.html#minimal-configuration" target="_blank" rel="external">Minimal Configuration</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前段时间主要了解了一些OpenStack相关的基础性东西，现在希望通过安装使用来增强一下对系统整体的认识，最近也读了一篇文章<a href="http://www.csdn.net/article/2014-04-10/2819247-how-to-learn-opensouce-project-&amp;-ceph">如何学习开源项目</a>，基本和我的想法很类似，所以基本上也就是按照这个节奏来的。不说废话了，开始。<br>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[存储知识学习]]></title>
    <link href="http://yikun.github.io/2016/02/03/%E5%AD%98%E5%82%A8%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yikun.github.io/2016/02/03/存储知识学习/</id>
    <published>2016-02-03T14:46:58.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_磁盘基本知识">1. 磁盘基本知识</h2><p>磁盘大致由盘片、磁头、步进电机等几部分组成组成。<br>盘面：硬盘一般含有一个或多个盘片，一个盘片包含两个盘面。<br>磁道：每个盘面被划成多个狭窄的同心圆环，这样的圆环叫做磁道。<br>扇区：每个磁道的每段圆弧叫做一个扇区，是读写的最小单位。<br>柱面：所有盘面上的同一磁道，在竖直方向构成一个圆柱，称为柱面。<br>    读写过程：硬盘读取数据时，磁头先移动到读取扇区所在磁道的上方，这个过程耗时叫做磁盘寻道时间，平均时间为10ms。之后，通过盘片的旋转，使得扇区转到磁头的下方，这个过程耗时叫做旋转延迟时间，对于7200转/min的硬盘转一周为60*1000/7200=8.33ms，平均旋转延迟为4.17ms（半圈）。</p>
<h3 id="2-_RAID基本知识">2. RAID基本知识</h3><p>RAID（Redundant Array of Independent Disks），即由独立的磁盘组成的具有冗余特性的阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大的硬盘。<br>RAID 0，条带化存储，容量增加，并行化，但无冗余，容易单点故障。</p>
<p>RAID 1，镜像存储，写入速率慢，读取速率快，有冗余备份，优点是高可靠、高可用，缺点是高花费。</p>
<p>RAID 2，RAID 0的改进版，使用汉明码进行检测和纠错，适用于连续IO、大块IO（如视频流）。</p>
<p>RAID 3，RAID 3和RAID 2的思路比较相似，使用奇偶校验进行错误检测和纠错，但校验盘单点故障。</p>
<p>RAID 4，RAID 4和RAID 3思路一样，只不过是使用BLOCK进行存储。</p>
<p>RAID 5，校验信息交叉的存储在所有数据盘上，高冗余，高数据传输率，实现复杂。</p>
<p>RAID 6，相比RAID5增加块内的校验，允许同时坏2块硬盘而不丢失数据。</p>
<p>RAID 01，先做条带（0），再做镜像（1）。读写速度快，数据保护能力强，空间利用率50%。<br>RAID 10，先做镜像（1），再做条带（0）。</p>
<h3 id="3-_存储方式">3. 存储方式</h3><p>根据网上的资料和理解，用Visio整理了一张图对比了下几种方式：<br><img src="https://cloud.githubusercontent.com/assets/1736354/12811291/7906961c-cb66-11e5-89da-3f2bc2f00108.png" alt="das_nas_san"></p>
<p>DAS全称为Direct Attached Storage，即服务器直连存储。如图所示，文件系统直接通过RAID完成对硬件访问。优点是操作简便，经济，缺点是分散式存储，不可集中管理。<br>NAS全称为Network Attached Storage，即网络存储服务。如图所示，文件系统通过网络暴露出来给应用服务。优点是结构简单。配置使用管理非常方便，可实现跨平台的数据共享。缺点是需要占用网络资源、应用局限性大。<br>SAN全称为Storage Aera Network，即存储区域网络，如图所示，RAID接口通过网络暴露出来。优点是扩展性强，集中管理，缺点是成本较高，管理维护难度大。</p>
<h3 id="4-_IP_SAN与FC_SAN">4. IP SAN与FC SAN</h3><p>FC SAN指基于光纤通道（Fiber Channel）的存储区域网，在FC SAN中存在两张网，一张面向应用的网（IP网），另一张中则是存储网（FC网）。而IP SAN的出现则是为了寻求一种新的方式，用与应用网相同的体系架构来构造存储网，使用通用的IP网络及设备。<br>FC SAN性能好，价格高，但与主流的IP网络异构。适用于关键应用的几种存储、备份及容灾。<br>IP SAN则由于以太网MTU（1518字节）的限制，性能稍差，但基于通用的IP协议。适用于异地间的数据交换、备份容灾，非关键应用的集中存储。</p>
<h3 id="5-_LVM基本知识">5. LVM基本知识</h3><p>LVM的全称是Logical Volume Manager，逻辑卷轴管理，主要解决的问题是，弹性调整文件系统的容量。</p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/12811308/9e2cf4e0-cb66-11e5-91e4-5d375b576ae7.png" alt="lvm"></p>
<p>与传统的磁盘与分区相比，LVM为计算机提供了更高层次的存储，通过在磁盘分区和文件系统之间增加一个逻辑层，提供一个抽象的逻辑盘卷。</p>
<h3 id="参考资料">参考资料</h3><ol>
<li>《大话存储》</li>
<li>RAID技术介绍和总结<a href="http://blog.jobbole.com/83808/" target="_blank" rel="external">http://blog.jobbole.com/83808/</a></li>
<li>基于OpenStack的NAS服务<a href="https://www.ustack.com/blog/openstack-nas/" target="_blank" rel="external">https://www.ustack.com/blog/openstack-nas/</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-_磁盘基本知识">1. 磁盘基本知识</h2><p>磁盘大致由盘片、磁头、步进电机等几部分组成组成。<br>盘面：硬盘一般含有一个或多个盘片，一个盘片包含两个盘面。<br>磁道：每个盘面被划成多个狭窄的同心圆环，这样的圆环叫做磁道。<br>扇区：每个磁道的每段]]>
    </summary>
    
      <category term="Cinder" scheme="http://yikun.github.io/tags/Cinder/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Internationalization]]></title>
    <link href="http://yikun.github.io/2016/01/23/%E8%AF%91-Internationalization/"/>
    <id>http://yikun.github.io/2016/01/23/译-Internationalization/</id>
    <published>2016-01-22T16:43:37.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Nova uses the <strong>oslo.i18n library</strong> to <strong>support internationalization</strong>. The oslo.i18n library is built on top of <strong>gettext</strong> and provides functions that are used to enable user-facing strings such as log messages to appear in the <strong>appropriate language in different locales</strong>.</p>
<p>Nova exposes the oslo.i18n library support via the nova/i18n.py integration module. This module provides the functions needed to wrap translatable strings. It provides the _() wrapper for general user-facing messages and specific wrappers for messages used only for logging. DEBUG level messages do not need translation but CRITICAL, ERROR, WARNING and INFO messages should be wrapped with _LC(), _LE(), _LW() or _LI() respectively.</p>
</blockquote>
<p>理解：Nova是通过oslo.i18n来支持国际化的，oslo.i18n是基于getnext做的，这个库可以把面向用户的字符（比如日志）翻译成指定的语言。其中DEBUG信息不翻译，其他的信息会被翻译。</p>
<p>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># debug log</span></span><br><span class="line">LOG.debug(<span class="string">"block_device_mapping %(mapping)s"</span>,</span><br><span class="line">          &#123;<span class="string">'mapping'</span>: block_device_mapping&#125;)</span><br><span class="line"><span class="comment"># warn log</span></span><br><span class="line">LOG.warn(_LW(<span class="string">'Unknown base file %(img)s'</span>), &#123;<span class="string">'img'</span>: img&#125;)</span><br><span class="line"><span class="comment"># not log</span></span><br><span class="line"><span class="keyword">raise</span> nova.SomeException(_(<span class="string">'Invalid service catalogue'</span>))</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Do not use locals() for formatting messages because: 1. It is not as clear as using explicit dicts. 2. It could produce hidden errors during refactoring. 3. Changing the name of a variable causes a change in the message. 4. It creates a lot of otherwise unused variables.</p>
<p>If you do not follow the project conventions, your code may cause hacking checks to fail.</p>
</blockquote>
<p>另外，文中提到了不要使用<code>locals()</code>去格式化消息主要4点原因：1.不清楚是否有关键字. 2.重构时会有潜在的出错可能. 3.变量名变了消息就变. 4.创建很多无用的变量。</p>
<p>这些函数_(), _LC(), _LE(), _LW() and _LI()可以通过以下方法导入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LC</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LE</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LW</span><br><span class="line"><span class="keyword">from</span> nova.i18n <span class="keyword">import</span> _LI</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Nova uses the <strong>oslo.i18n library</strong> to <strong>support internationalization</strong>. The oslo.i18n library is ]]>
    </summary>
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Virtual Machine States and Transitions]]></title>
    <link href="http://yikun.github.io/2016/01/20/%E8%AF%91-Virtual-Machine-States-and-Transitions/"/>
    <id>http://yikun.github.io/2016/01/20/译-Virtual-Machine-States-and-Transitions/</id>
    <published>2016-01-20T15:46:59.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>虚拟机的状态及其转移，主要讲了一些虚拟机的状态以及在创建虚拟机时的状态转移情况，目前理解不够深刻，需要在后面看代码时，进一步深入理解。</p>
<a id="more"></a>
<h3 id="Allowed_State_Transitions">Allowed State Transitions</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/12451522/ee92a928-bfc4-11e5-89cf-cc39c09a7fea.png" alt="Allowed State Transitions"></p>
<h3 id="Create_Instance_States">Create Instance States</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/12451543/0a1f8fc6-bfc5-11e5-8f30-c893782b278e.png" alt="Create Instance States"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虚拟机的状态及其转移，主要讲了一些虚拟机的状态以及在创建虚拟机时的状态转移情况，目前理解不够深刻，需要在后面看代码时，进一步深入理解。</p>]]>
    
    </summary>
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015，再见]]></title>
    <link href="http://yikun.github.io/2016/01/02/2015%EF%BC%8C%E5%86%8D%E8%A7%81/"/>
    <id>http://yikun.github.io/2016/01/02/2015，再见/</id>
    <published>2016-01-01T16:05:42.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>2015年是很特殊的一年，是长达快20年的学生时代的终结。从年初最开始的时候，就对今年的会发生的事情做好了准备，也基本上按照自己的想法发生了。之前，也有一些计划，基本达到预期，现在想起这些目标都算是一些学生时代的梦想吧，这篇总结也大致的从这些方面展开。</p>
<a id="more"></a>
<h3 id="一个实习">一个实习</h3><p>年初的计划是百度，腾讯，阿里的任何一个地方实习。当时心中最想去的是腾讯或者阿里，对百度不感兴趣的原因主要是在北京呆了太久了，新鲜感没了：）。</p>
<p>对于实习整体对自己比较满意，算是把一个目标分解到执行实施的一个完整过程。从面试准备到拿到offer，从开始实习到实习转正，都有条不紊按照自己的计划一步一步地实施。有预判，有变化，提前准备，未雨绸缪，占据主动，值得再接再厉。</p>
<p>实习面试准备得还算充分，从过年那会儿就开始准备了，补Java的基础，看Collection的源码，刷leetcode。在三月，实习的提前批就拿到了蚂蚁金服支付宝研发的offer。</p>
<p>实习的过程中，也看到了一个互联网企业中人们的生活状态：苦逼而快乐。加班是常态，不过抱怨的人不多，大概是大家都有一颗为了自己或者阿里付出的心吧。组内的氛围很好，没有主管，组员什么的分别。总得来说，真的是开开心心地上班，每个人都有存在感，每个人都有机会，牛人有更大的舞台。和主管，师兄，师傅学到了很多做人处事的方法或者态度，谦逊努力，积极思考，善于沟通。</p>
<p>实习结束后的转正答辩也比较顺利，当时是拿到了HR的口头offer，不过预估自己可能不会留下，在走的时候，也没给主管一个确定的回复，感觉挺抱歉的，找完工作后也和师兄，师傅他们聊了一些，也得到了很多的发展和工作的建议，也算是解了自己的心结。</p>
<p>花名不改，江湖犹在，后悔有期，就像一弦哥说的那样：世界很小的，有心的话很快就会再见面。</p>
<h3 id="一台Macbook_Pro">一台Macbook Pro</h3><p>今年新添了个设备，13寸的Macbook Pro，惯例的，还是花自己的钱。</p>
<p>首先是自己对mac的印象比较好，促使我买mac主要有几点吧，一是大家都说mac是程序员的神器，买的人都说谁用谁知道；二是大致预料到可能今年不买以后会更犹豫。最后一点是，真的有买mac的钱了，是的，没错这才是最重要的一点。</p>
<p>于是，在北京的时候，用学生价在西单大悦城的实体店买的，从决定买到买到手大概就是一个早上。总体来说，比较满意，和预想的差不多，最开始的时候只有对command键不太适应，其他基本顺畅，基本平滑过度。现在的日用，技术博客，编码基本都适应了。最近配合着新买不久的数位板，也用漫画的形式了记录了一下研究生的生活，目前线稿基本搞定，该上色了。：）</p>
<p>总觉得年轻时应该有一些“意气用事”的决定，因为我们年轻，有承担失败的试错资本，也可以尽情地享受意外的惊喜，想到什么就去做吧，开心就好。</p>
<h3 id="一份工作">一份工作</h3><p>其实对于找工作来说，和其他大多数同学来说，不算太艰辛， 算下来面试过腾讯，百度，阿里，头条，华为，小米，IBM一共7家。</p>
<p>在实习的时候，有个周末去深圳参加了腾讯提前批的TST面试，顺利拿到offer，好的开始也奠定了后期找工作的心态，后面阿里这边也顺利转正拿到口头offer，因为觉得留在杭州的可能不大，所以走的时候就没和部门说定，发生了拥抱变化的故事后，也便不了了之。在随后的面试中，也拿到了北京小米的sp offer，比较意外的是居然还有北京户口，然后就是华为的sp offer。其中，百度和头条挂掉的原因总结一下也是因为算法面试准备的不充分，想想没有集齐BAT召唤神龙，有点可惜。然后IBM面试都搞定了，流程比较慢，有缘再会。最终，综合考虑各种因素，选择了西安华为作为工作开始的地方。</p>
<p>单从工作性质来讲，华为并不是最优选择， 其实拿到offer的这些在我心中都是很好的选择，都有很多诱惑的地方，留西安确实是一个很重要的因素，对于这个选择，原因只有三个字：不辜负。现在描述这些的时候真的很平静，也许是因为很早就想通的原因，也一定会既来之，则安之，化那些不甘为努力奋斗。</p>
<p>每个阶段都有自己的选择，也希望以后再做选择时，能够想清楚自己真正想要的是什么，选择自己最珍视的东西，不被诱惑，不被干扰，相信自己的感觉，自己满意就好。</p>
<h3 id="读书与博客">读书与博客</h3><p>计划是每月大概一本的样子，为了记录一下读书的过程，写了个<a href="https://github.com/Yikun/hexo-generator-douban" target="_blank" rel="external">插件</a>把豆瓣的读书记录同步到自己的<a href="http://yikun.github.io/douban/" target="_blank" rel="external">博客</a>了。</p>
<p>今年读了7本书，不过每本都是认认真真的读。今天还和室友聊起了读书数目的问题，大致达成的结论是：读书要有质量，要有感受，不要太盲目。</p>
<p>另外，自己的技术博客也慢慢积累起来了，期望在未来能够学有所思，不断积累。</p>
<p>2015，这一年<br>前面依着自己的计划，算是把2015这一年基本覆盖了，2015这一年待过不少城市，在北京科研，去芭提雅玩，去曼谷参加姐姐的婚礼，在杭州阿里实习，去上海找兄弟聚，去深圳腾讯面试，去三亚Outing，到成都和银川毕业旅行，总得来说是在忙碌中四处穿行。</p>
<p>2015对自己比较满意的是能够按照自己的思考一步一步地把一些事情做好，而这些事情主要归功于提前的计划和不断的思考，不过还是有些地方没有思考全面。2015对自己不太满意的是在一些有压力的时候会有些不知所措，遇到未知的事情不够淡定，犹豫不决，决策能力需要提升。 以后肯定会越来越忙的，希望自己能够不断思考总结，迎接变化，更重要的是在任何时候都不要迷失了自己。</p>
<h3 id="期望">期望</h3><p>未来一年对自己的期望是：技术更加专注有深度，做人更加靠谱有内涵，生活更加丰富有惊喜。</p>
<p>最后，2015，再见，2016，你好！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年是很特殊的一年，是长达快20年的学生时代的终结。从年初最开始的时候，就对今年的会发生的事情做好了准备，也基本上按照自己的想法发生了。之前，也有一些计划，基本达到预期，现在想起这些目标都算是一些学生时代的梦想吧，这篇总结也大致的从这些方面展开。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3源码学习-整型]]></title>
    <link href="http://yikun.github.io/2015/12/21/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E6%95%B4%E5%9E%8B/"/>
    <id>http://yikun.github.io/2015/12/21/Python3源码学习-整型/</id>
    <published>2015-12-21T13:48:29.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_引入">1. 引入</h3><p>我们先看看对整型变量i进行赋值，并对i进行显示的过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i=<span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在之前已经了解到对象是如何存储、组织的了，那么，整型是如何存储的呢？在Python 2中，整型是分Int和Long的，稍小一点的数直接用C语言中的long去存储，稍大一点的数（超过long的承受范围）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span>.10 (default, Jul <span class="number">14</span> <span class="number">2015</span>, <span class="number">19</span>:<span class="number">46</span>:<span class="number">27</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>type(<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>sys.maxsize</span><br><span class="line"><span class="comment"># 2**63-1</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>type(sys.maxsize)</span><br><span class="line">&lt;type <span class="string">'int'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>type(sys.maxsize+<span class="number">1</span>)</span><br><span class="line">&lt;type <span class="string">'long'</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>而在Python 3中，我们进行相同的操作：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Python 3.5.0 (default, Dec 20 2015, 21:24:49)</span><br><span class="line">&gt;&gt;&gt; sys.maxsize</span><br><span class="line"># 2**63-1</span><br><span class="line">9223372036854775807</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(1)</span><br><span class="line">&lt;class 'int'&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(sys.maxsize)</span><br><span class="line">&lt;class 'int'&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; type(sys.maxsize+1)</span><br><span class="line">&lt;class 'int'&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们发现不论这个数是“大”是“小”，都无差别的显示为“int”了。那么，在Python3中做了哪些变动呢？Python3如何“一统天下”大小，存储整型数据呢？在Python 2中，分别使用intobject和longobject去存储整型，而在Python 3中，则使用longobject统一的表示整型，并且将type也设为“int”，在<a href="https://www.python.org/dev/peps/pep-0237/" target="_blank" rel="external">PEP 237 — Unifying Long Integers and Integers</a>中，详细的阐述了这个改变，下面让我们详细看看Python 3中整型的实现。</p>
<h3 id="2-_整型的实现">2. 整型的实现</h3><p>我们先看看longobject.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _longobject PyLongObject; <span class="comment">/* Revealed in longintrepr.h */</span></span><br></pre></td></tr></table></figure></p>
<p>按着注释解释，发现了整型的庐山真面目在longintrepr.h中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Long integer representation.</span><br><span class="line">   The absolute value of a number is equal to</span><br><span class="line">   	SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</span><br><span class="line">   Negative numbers are represented with ob_size &lt; 0;</span><br><span class="line">   zero is represented by ob_size == 0.</span><br><span class="line">   In a normalized number, ob_digit[abs(ob_size)-1] (the most significant</span><br><span class="line">   digit) is never zero.  Also, in all cases, for all valid i,</span><br><span class="line">   	0 &lt;= ob_digit[i] &lt;= MASK.</span><br><span class="line">   The allocation function takes care of allocating extra memory</span><br><span class="line">   so that ob_digit[0] ... ob_digit[abs(ob_size)-1] are actually available.</span><br><span class="line"></span><br><span class="line">   CAUTION:  Generic code manipulating subtypes of PyVarObject has to</span><br><span class="line">   aware that ints abuse  ob_size's sign bit.</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _longobject &#123;</span><br><span class="line">	PyObject_VAR_HEAD</span><br><span class="line">	digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注释非常清楚，我们得到以下信息：</p>
<ol>
<li>整数的绝对值为<code>SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)</code>。</li>
<li>0值用<code>obsize==0</code>来表示。</li>
<li>对于正常的数，<code>ob_digit[abs(ob_size)-1]</code>非0。</li>
<li>对于有效的<code>i</code>，<code>ob_digit[i]</code>的范围在<code>[0, MASK]</code>。</li>
</ol>
<p>可以看到整型是借助柔性数组来实现的，柔性数组较指针来说，分配内存和释放内存时更为方便，且数组名本身不占用空间（指针需要占用1个int型的控件），柔性数组相关内容可以参考<a href="http://blog.csdn.net/fengbingchun/article/details/24185217" target="_blank" rel="external">链接</a>。</p>
<p>光看描述可能有点抽象，我们看一个具体的例子，在我的环境中，SHIFT为30，MASK则为2的30次方-1，<code>1152921506754330628</code>这个数字在代码中是这样存储的，ob_size为3，ob_digit为4-2-1，我们来看看具体的表示含义：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11933249/af84fe30-a835-11e5-8a09-257bb08b3c12.png" alt="int"><br>很熟悉吧，其实就是个进制转换过程：2的30次方进制转换为10进制！没错，就是这么简单。</p>
<h3 id="3-_常用整数的优化">3. 常用整数的优化</h3><p>我们再观察一个现象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i=<span class="number">10</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>j=<span class="number">10</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i <span class="keyword">is</span> j</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i=<span class="number">257</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>j=<span class="number">257</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i <span class="keyword">is</span> j</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>我们发现对于第一个来说，i和j是一个对象，而第二个例子i和j是不同的对象。<br>可以想象的，如果每个整型都需要使用对象来表示，那么每创建一个整型就需要创建一个对象，这显然是不合理的，因此设计者将[-5, 257)范围内的整型数据进行了特殊处理，即在初始化的时候就将这些对象产生好，以后需要这些对象时直接从对象池取就好。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef NSMALLPOSINTS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NSMALLPOSINTS           257</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#ifndef NSMALLNEGINTS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> NSMALLNEGINTS           5</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Small integers are preallocated in this array so that they</span><br><span class="line">   can be shared.</span><br><span class="line">   The integers that are preallocated are those in the range</span><br><span class="line">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">static</span> PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">get_small_int(sdigit ival)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *v;</span><br><span class="line">    assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS);</span><br><span class="line">    v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS];</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line"><span class="preprocessor">#ifdef COUNT_ALLOCS</span></span><br><span class="line">    <span class="keyword">if</span> (ival &gt;= <span class="number">0</span>)</span><br><span class="line">        quick_int_allocs++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        quick_neg_int_allocs++;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CHECK_SMALL_INT(ival) \</span><br><span class="line">    do <span class="keyword">if</span> (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \</span><br><span class="line">        return get_small_int((sdigit)ival); \</span><br><span class="line">    &#125; while(0)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-_Hack一下">4. Hack一下</h3><p>为了验证我们对整型实现理解的正确性，我们修改<code>long_to_decimal_string_internal</code>中加入一些代码，打印出整型变量的详情：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line"><span class="title">long_to_decimal_string_internal</span><span class="params">(PyObject *aa,</span><br><span class="line">                                PyObject **p_output,</span><br><span class="line">                                _PyUnicodeWriter *writer)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    PyLongObject *scratch, *a;</span><br><span class="line">    PyObject *str;</span><br><span class="line">    Py_ssize_t size, <span class="built_in">strlen</span>, size_a, i, j;</span><br><span class="line">    digit *pout, *pin, rem, tenpow;</span><br><span class="line">    <span class="keyword">int</span> negative;</span><br><span class="line">    <span class="keyword">enum</span> PyUnicode_Kind kind;</span><br><span class="line"></span><br><span class="line">    a = (PyLongObject *)aa;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"==== Hack Code ====\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ob_size     = %d\n"</span>, Py_SIZE(a));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ob_i = <span class="number">0</span>; ob_i &lt; Py_SIZE(a); ++ob_i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ob_digit[%d] = %d\n"</span>, ob_i, a-&gt;ob_digit[ob_i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"====    End    ====\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后，我们看到结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span>**<span class="number">60</span>+<span class="number">2</span>*<span class="number">2</span>**<span class="number">30</span>+<span class="number">4</span></span><br><span class="line">==== Hack Code ====</span><br><span class="line">ob_size     = <span class="number">3</span></span><br><span class="line">ob_digit[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">ob_digit[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">ob_digit[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">====    End    ====</span><br><span class="line"><span class="number">1152921506754330628</span></span><br></pre></td></tr></table></figure></p>
<p>我们看到，结果与我们预期的一样，ob_size为3，代表ob_digit的数组大小为3，ob_digit表述的数值为(2^60) x <code>1</code> + (2^30) x <code>2</code> + (2^0) x <code>4</code>。完整代码工程请见<a href="https://github.com/Yikun/Python3/commit/b816507f56ee14b730b7ab52a61eb17f9eb9d815" target="_blank" rel="external">链接</a></p>
<h3 id="参考链接">参考链接</h3><p><a href="https://www.python.org/dev/peps/pep-0237/" target="_blank" rel="external">PEP 237 — Unifying Long Integers and Integers</a><br><a href="http://stackoverflow.com/questions/2104884/how-does-python-manage-int-and-long" target="_blank" rel="external">How does Python manage int and long?</a><br><a href="http://stackoverflow.com/questions/22875067/how-does-python-represent-such-large-integers" target="_blank" rel="external">How does python represent such large integers?</a><br><a href="http://www.itsprite.com/pythonhow-does-c-implements-the-python-assignment-of-large-numbers/" target="_blank" rel="external">Python:How does C implements the Python assignment of large numbers</a><br><a href="https://ep2013.europython.eu/conference/talks/hacking-pylongobject-on-python-32" target="_blank" rel="external">HACKING PYLONGOBJECT ON PYTHON 3.2</a><br><a href="https://interma.wordpress.com/2012/10/11/py3_integral/" target="_blank" rel="external">py3源码-2-整数</a><br><a href="http://foofish.net/blog/89/python_int_implement" target="_blank" rel="external">Python 整数对象实现原理</a><br><a href="http://blog.csdn.net/fengbingchun/article/details/24185217" target="_blank" rel="external">结构体中最后一个成员为[0]或[1]长度数组(柔性数组成员)的用法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_引入">1. 引入</h3><p>我们先看看对整型变量i进行赋值，并对i进行显示的过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i=<span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>i</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3源码学习-类型]]></title>
    <link href="http://yikun.github.io/2015/12/20/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yikun.github.io/2015/12/20/Python3源码学习-类型/</id>
    <published>2015-12-20T15:03:21.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_类型">1. 类型</h3><p>我们在《Python3源码学习-对象》中提到了每个对象都含有一个type的属性，我们看看type是个什么东西，目光移到object.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以看到，PyTypeObject就是类型对象的定义了。其中，包含了一些和类型相关的重要信息：</p>
<ul>
<li><strong>类型名</strong>： <code>const char *tp_name</code>，例如对于整型对象，他的这个name就是“int”。</li>
<li><strong>开辟空间大小</strong>：<code>tp_basicsize</code>和<code>tp_itemsize</code>包含了创建该类型的对象所需要分配的控件大小。</li>
<li><strong>一些与对象相关联的操作</strong>：比如<code>tp_dealloc</code>用于销毁对象，<code>tp_hash</code>用于计算hash值，<code>tp_str</code>用于将对象转换为str。</li>
</ul>
<h3 id="2-_类型的类型">2. 类型的类型</h3><p>另外可以看到，由该类的属性<code>PyObject_VAR_HEAD</code>看出，类型也是一个对象。我们知道每个对象都会有一个类型，那么思考一个问题，类型对象的类型又是什么呢？这个问题在typeobject.c的文件中给出了答案：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyType_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">"type"</span>,                                     <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyHeapTypeObject),                   <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyMemberDef),                        <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    (destructor)type_dealloc,                   <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_reserved */</span></span><br><span class="line">    (reprfunc)type_repr,                        <span class="comment">/* tp_repr */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到类型对象的类型就是<code>PyType_Type</code>，而PyType_Type的类型则执行它本身。</p>
<h3 id="3-_对象图示">3. 对象图示</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11918443/66f1c2c6-a76c-11e5-8838-f742ec215af2.png" alt="type object"></p>
<p>如上图所示，是一个简单的整型对象的例子，我们可以看出：</p>
<ol>
<li>整型对象的类型是PyLong_Type。</li>
<li>PyLong_Type是一个类型对象，其类型为PyType_Type。</li>
<li>PyType_Type也是一个类型对象，其类型为它本身。</li>
</ol>
<p>我们也可以看出因为“万物皆对象”，不同的object虽然type不同，但是都有一个类型指针，通过类型指针ob_type即可完成对应方法的访问，Python也正是利用了指针的特性，从而实现了多态。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_类型">1. 类型</h3><p>我们在《Python3源码学习-对象》中提到了每个对象都含有一个type的属性，我们看看type是个什么东西，目光移到object.h：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _typeobject &#123;</span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format "&lt;module&gt;.&lt;name&gt;" */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;</span><br><span class="line">    reprfunc tp_str;</span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... ...</span></span><br><span class="line"></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3源码学习-编译Python源码]]></title>
    <link href="http://yikun.github.io/2015/12/20/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E7%BC%96%E8%AF%91Python%E6%BA%90%E7%A0%81/"/>
    <id>http://yikun.github.io/2015/12/20/Python3源码学习-编译Python源码/</id>
    <published>2015-12-20T12:36:58.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>在进行源码学习的时候，“实践出真知”。因此，在进行源码学习的过程中，我们首先需要对源码进行编译，然后，对我们感兴趣的点进行log，甚至debug。本篇文章记录了我在进行Python 3.5.0源码编译时的一些过程。<br><a id="more"></a></p>
<h3 id="1-_下载">1. 下载</h3><p>在官网<a href="https://www.python.org/downloads/" target="_blank" rel="external">下载</a>最新源码，为了方便跟踪源码的修改，借助git来管理Python源码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init&#10;git add .&#10;git commit -am &#34;Python 3.5.0 source.&#34;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-_配置">2. 配置</h3><p>在编译前需要使用configure对源码进行配置。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure></p>
<p>配置完源码后，使用git status观察一下变化：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  Python-<span class="number">3.5</span>.<span class="number">0</span> git:(master) ✗ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">	Makefile</span><br><span class="line">	Makefile<span class="class">.pre</span></span><br><span class="line">	Misc/python-config<span class="class">.sh</span></span><br><span class="line">	Misc/python<span class="class">.pc</span></span><br><span class="line">	Modules/Setup</span><br><span class="line">	Modules/Setup<span class="class">.config</span></span><br><span class="line">	Modules/Setup<span class="class">.local</span></span><br><span class="line">	Modules/config<span class="class">.c</span></span><br><span class="line">	Modules/ld_so_aix</span><br><span class="line">	config<span class="class">.log</span></span><br><span class="line">	config<span class="class">.status</span></span><br><span class="line">	pyconfig<span class="class">.h</span></span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure></p>
<p>我们看到产生了一些和make相关的配置文件，用来适配当前的环境。<br>用git提交一下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">add</span> .</span><br><span class="line">git commit -<span class="keyword">am</span> <span class="string">"After ./configure ."</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-编译">3.编译</h3><p>编译Python时，使用make进行编译<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br></pre></td></tr></table></figure></p>
<p>编译完成后，产生了一个python.exe文件，便是我们编译所得的执行文件。</p>
<blockquote>
<p>注<br>我是在OSX下进行编译的，在编译过程中遇到了<code>fatal error: &#39;lzma.h&#39; file not found</code>问题，把lzma包安上就可以了：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew <span class="keyword">install</span> xz</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="4-运行">4.运行</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./python.exe</span><br></pre></td></tr></table></figure>
<p>以上便完成了整个Python源码的编译。以后，在修改完代码以后，只需要<code>make;./python.exe</code>就好~那么，享受Hack python code的乐趣吧。：）</p>
<p>代码已上传，并根据学习过程不断更新：<a href="https://github.com/Yikun/Python3" target="_blank" rel="external">https://github.com/Yikun/Python3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在进行源码学习的时候，“实践出真知”。因此，在进行源码学习的过程中，我们首先需要对源码进行编译，然后，对我们感兴趣的点进行log，甚至debug。本篇文章记录了我在进行Python 3.5.0源码编译时的一些过程。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python3源码学习-对象]]></title>
    <link href="http://yikun.github.io/2015/12/03/Python3%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yikun.github.io/2015/12/03/Python3源码学习-对象/</id>
    <published>2015-12-03T07:07:19.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>最近开始看Python源码，大致看了看，发现Py2和Py3的部分实现差别挺大，《Python源码剖析》是根据Python 2写的。不过为了能激发主动性，便直接从Python 3（3.5.0）源码看起了，然后也会结合Python 2（2.7.10）的代码看看之前的实现，来对比学习~：）</p>
<h3 id="1-_万物皆对象">1. 万物皆对象</h3><p>在Python中，万物皆对象，那么对象又是什么结构，如何组织，怎样实现的呢？<br><a id="more"></a></p>
<blockquote>
<p>Objects are structures allocated on the heap.  Special rules apply to the use of objects to ensure they are properly garbage-collected. Objects are never allocated statically or on the stack; they must be accessed through special macros and functions only.(Type objects are exceptions to the first rule; the standard types are represented by statically initialized type objects, although work on type/class unification for Python 2.2 made it possible to have heap-allocated type objects too).</p>
</blockquote>
<p>从Python的源码注释可以得到以下信息点：</p>
<ul>
<li>对象一般就是开辟在堆上的结构体；</li>
<li>一些特殊的规则运用在对象上，以保证他们被正确的GC；</li>
<li>对象永远不会静态开辟或者在栈上；</li>
</ul>
<p>然后，还补充说，Type对象除外，标准的type对象是静态初始化的，Python 2.2把在堆上初始化type对象变成了现实。</p>
<h3 id="2-_对象的结构">2. 对象的结构</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11553779/03a14ebe-99cd-11e5-8640-dde569539e9d.png" alt="object"></p>
<p>Python中的对象，主要分为一般对象和变长对象（list、dict之类），一般的对象就是PyObject，然后变长对象其实就是给PyObject加了个size成为了PyVarObject。</p>
<p>对于所有对象来说，均有2个重要的元素：</p>
<ul>
<li><p>引用计数（reference count），对象中的引用计数用来记录引用对象的数目，会在指针指向或删除对该对象的引用时，相应的增加或者减少，当引用计数达到0，就代表这没有指针指向这个对象了，这个对象便会在堆中移除。从名字就可以看出来，这个域是为了支持垃圾回收而定义的。</p>
</li>
<li><p>类型（type），对象的类型表示对象包含数据的类型，每个对象中都有一个指向类型的指针。比较有意思的是，type也是一个对象，type对象的类型是它本身，所以type对象的类型指针就指向它自己了。</p>
</li>
</ul>
<p>对于可变长的对象（比如list，dict），会多一个域：</p>
<ul>
<li>大小（size），这个大小表示这个变长变量中元素的个数。注意，是元素的个数，不是字节个数。</li>
</ul>
<p>另外头部还有<code>_PyObject_HEAD_EXTRA</code>，这个宏定义了next和prev指针，用来支持用一个双链表把所有堆中的对象串起来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _PyObject_HEAD_EXTRA            \</span><br><span class="line">    struct _object *_ob_next;           \</span><br><span class="line">    struct _object *_ob_prev;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料">参考资料</h3><p>Python-3.5.0源码<br><a href="http://www.wklken.me/posts/2014/08/05/python-source-object.html#pyobject_head" target="_blank" rel="external">PYTHON 源码阅读 - 对象</a><br><a href="http://book.douban.com/subject/3117898/" target="_blank" rel="external">Python源码剖析</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近开始看Python源码，大致看了看，发现Py2和Py3的部分实现差别挺大，《Python源码剖析》是根据Python 2写的。不过为了能激发主动性，便直接从Python 3（3.5.0）源码看起了，然后也会结合Python 2（2.7.10）的代码看看之前的实现，来对比学习~：）</p>
<h3 id="1-_万物皆对象">1. 万物皆对象</h3><p>在Python中，万物皆对象，那么对象又是什么结构，如何组织，怎样实现的呢？<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络知识拾遗]]></title>
    <link href="http://yikun.github.io/2015/11/23/%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%8B%BE%E9%81%97/"/>
    <id>http://yikun.github.io/2015/11/23/网络知识拾遗/</id>
    <published>2015-11-23T13:19:23.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。</p>
<a id="more"></a>
<h2 id="1-_二层交换">1. 二层交换</h2><p>二层交换指的是传统的二层交换机实现的功能，主要的功能就是将以太网帧从一个端口接收，并从合适的端口发送出去。</p>
<h3 id="1-1_以太网帧">1.1 以太网帧</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11339369/29e0977e-9234-11e5-880f-8c03596d1246.png" alt="emac"></p>
<!--more-->
<p>以太网帧如上图所示，如此构造主要是为了表达这个帧：到哪去（目的MAC，6字节）、从哪来（源MAC，6字节）、什么帧（长度/类型，2字节）、有什么（数据，40~1500字节）、错没错（FCS，CRC，4字节）。</p>
<p>用户数据的长度不同，以太网帧的长度也不同，范围为64-1518字节。</p>
<h3 id="1-2_存储转发与地址学习">1.2 存储转发与地址学习</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11361099/a014666e-92c5-11e5-88b6-7aad7ff694f0.png" alt="l2 switch"></p>
<p><strong>存储转发</strong>：转发时，常用的方式为存储转发方式（store forward），即数据帧先入<strong>存储队列</strong>再根据<strong>转发表</strong>进行转发。使用存储转发，一来可以为多种速率端口的数据进行缓冲，二来也可以将残损、CRC错误等异常帧进行丢弃。小科普：除了存储转发外，还有直通转发（cut through，只读到DA后就转发，无法处理冲突帧、CRC错帧）、碎片隔离（fragment free，读一个slot共64字节，无冲突再转发，无法处理CRC帧）。</p>
<p><strong>地址学习</strong>：在完成存储转发时，需要查询转发表，从而得知数据帧应该从哪个端口发出，因此，转发表存的就是目的MAC地址与端口的映射，转发表生成的过程就是地址学习。大致过程就是，来一个帧，读他的源MAC，然后把源MAC和接收的端口号存下来。这样，交换机就知道了，从X端口来过MAC地址为Y的数据，当下次Y需要转发时，就可以把他转发到X端口了。从而，完成“从哪来去回哪去”的任务</p>
<h3 id="1-3_广播风暴">1.3 广播风暴</h3><p>在几个交换机构成环时，会产生广播风暴，造成广播风暴的根本原因是交换机之间不能感知到互相的存在，导致地址学习时，一个交换将某个MAC的转发端口学习成了另一个交换机的端口。可以通过STP协议进行抑制，从逻辑上“断开”环。</p>
<h3 id="1-4_VLAN">1.4 VLAN</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11356544/b0e3196c-9299-11e5-9bac-105198e8c31f.png" alt="vlan change"></p>
<p>VLAN可以将广播域分隔为多个逻辑网段。从帧格式上来看，增加了VLAN相关的域，VLAN相关域包括0x8100标志位，然后3bit的优先级，1bit的丢帧优先级，12bit的VLANID。在做转发学习时，通过SA+VLAN来学习转发端口。值得注意的是：当某个DA+VLAN查不到表时，仅在VLAN域广播。</p>
<p>换一种思想来看，可以认为VLAN是一种网络的虚拟化，将一个端口虚拟化成多个端口。</p>
<h2 id="2-_三层路由">2. 三层路由</h2><p>路由的主要功能是根据目的IP转发到相应的网络中。和二层中的转发表类似，三层路由也存在一个类似的表，叫做路由表。</p>
<p>也就是说如果一个LAN希望连接另一个LAN，那么需要借助路由完成。另外，在大型的LAN中，由于连接设备多，导致MAC多，导致广播负担大，因此切分子网来避免这一问题，而子网之间所属不同LAN所以也需要借助路由完成通信。</p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/11361093/8aff2fac-92c5-11e5-851b-d7aa866c73cf.png" alt="router"></p>
<p>在进行路由的时候，路由首先根据<strong>最长匹配原则</strong>在路由表中查找下一跳IP地址，之后，根据ARP表，获取下一跳的MAC信息，便进入ARP流程，最后，根据下一跳MAC地址生成以太网数据帧，并将该数据帧从接口转发至网络。</p>
<p>路由与三层交换有类似的地方，L3交换虽具有路由功能，但其核心功能主要在于数据交换上，而路由仅具有路由转发功能。</p>
<h3 id="2-1_NAT">2.1 NAT</h3><p>Network Adress Translator，网络地址转换。<br><img src="https://cloud.githubusercontent.com/assets/1736354/11362678/3f059748-92d0-11e5-8c13-2dec089260e3.png" alt="nat"></p>
<p>对于源地址NAT，主要用于内网访问外网，源地址进行转换；<br>对于目的地址NAT，一般用于外网访问内网，目的地址进行转换。</p>
<h2 id="3-_Linux网络">3. Linux网络</h2><p>由于目前大部分云计算服务器、网络设备都是运行在Linux上的，因此，学习一些和Linux网络底层相关的实现，有助于我们理解。如<a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/" target="_blank" rel="external">Linux 上的基础网络设备详解</a>一文中所述：</p>
<blockquote>
<p>Linux 用户想要使用网络功能，不能通过直接操作硬件完成，而需要直接或间接的操作一个 Linux 为我们抽象出来的设备，既通用的 Linux 网络设备来完成。一个常见的情况是，系统里装有一个硬件网卡，Linux 会在系统里为其生成一个网络设备实例，如 eth0，用户需要对 eth0 发出命令以配置或使用它了。</p>
</blockquote>
<p>另外，对于Linux网络中的数据流在<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/kernel_flow" target="_blank" rel="external">kernel  flow</a>中有所描述，文中更有一张<a href="http://www.linuxfoundation.org/images/1/1c/Network_data_flow_through_kernel.png" target="_blank" rel="external">神图</a>。</p>
<h3 id="3-1_网络驱动">3.1 网络驱动</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/11388055/783c4f74-936c-11e5-800f-ca51da63f23d.png" alt="linux driver"></p>
<p>之前，有做过网络驱动，其实回想起来，核心的实现就2个：发送函数和接收函数。</p>
<p><strong>1. 发送函数（回调）</strong></p>
<p>核心功能是将上层网络传来的帧，写入到网卡中；</p>
<p>在网络驱动初始化时，会通过注册的方式对网络驱动进行初始化，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> net_device_ops netdev_ops = &#123;</span><br><span class="line">    .ndo_open         = driver_open,</span><br><span class="line">    .ndo_stop         = driver_close,</span><br><span class="line">    .ndo_start_xmit   = driver_xmit,</span><br><span class="line">    .ndo_get_stats    = get_stats,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当上层有帧传来时，就会回调driver_xmit函数，因此，在driver_xmit函数中，就应当实现将帧写入到硬件，一般硬件会提供插入帧的接口，完成插入时帧会进入网卡硬件的插入队列中。</p>
<p><strong>2. 接收函数（中断）</strong><br>核心功能是将网卡中的帧，传送到上层协议栈中。</p>
<p>对于接收函数，则需要依靠硬件的中断，数据帧到达网卡，硬件以中断的方式告知系统，然后，接收函数回调，回调时，需通过硬件的接口读取数据帧，然后将其上传值上层接口。一般调用<code>netif_rx()</code>进行传输。</p>
<h3 id="3-2_Linux_Bridge">3.2 Linux Bridge</h3><p>Linux Bridge名释其意，像一个桥梁一样把网络设备桥接起来。Linux bridge是802.1D的实现，可以参考<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge" target="_blank" rel="external">链接</a>。</p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/11388062/8bd8b0b8-936c-11e5-86db-ac0d3db82f25.png" alt="linux bridge"></p>
<p>如上图所示是eth0和eth1加入到br0后的实现，可以看出，网桥向上屏蔽了桥下的网卡设备，从上层协议上来看，仅能看到网桥设备br0。</p>
<p>在<a href="http://book.douban.com/subject/1475839/" target="_blank" rel="external">《Understanding Linux Network Internals》</a>一书中，分析了Linux Bridge的实现：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11390343/3db29684-9384-11e5-9fb6-8791d5a56535.png" alt="linux br"></p>
<p>在br中有个链表来链net_device，每个net_device也反向链着br。在br中有个hash结构叫做fdb_entry，存储着转发表（forward databse），若某个MAC地址在fdb中，那么就直接发到某个net_device，如果没在的话，就广播给链接到该br的所有设备。</p>
<h3 id="3-3_Linux_VLAN">3.3 Linux VLAN</h3><p>交换与隔离是VLAN的两大功能，现实世界中的802.1q交换机存在多个VLAN，每个VLAN拥有多个端口，同一VLAN的端口可数据交换，不同VLAN的端口之间隔离。而Linux VLAN实现的是隔离，需要交换的话，需要在Linux Bridge上attach一个VLAN。即Linux Bridge加VLAN device能在功能层面完整模拟现实世界里的802.1.q交换机。</p>
<p>在<a href="http://www.kernelchina.org/node/214" target="_blank" rel="external">关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考</a>一文中，举了个例子，觉得很不错，画了个图加深理解：<br><img src="https://cloud.githubusercontent.com/assets/1736354/11397203/a6d78704-93b2-11e5-92dc-dfbd9ae07365.png" alt="br vlan"></p>
<blockquote>
<p>一个盒子有6个物理interface, eth0,eth1,eth2,eth3,eth4,eth5,eth6.<br>bridge0 { eth0, eth1, eth2 }, vlan id 是2<br>bridge1 { eth3, eth4, eth5 }, vlan id 是3<br>eth0,eth1,eth2,eth3,eth4,eth5都在混杂模式，并且没有ip地址，它们是bridge的port.<br>创建vlan interface, bridge0.2, bridge1.3。在bridge0.2和bridge1.3上配置ip地址。vlan 2的机器，把bridge0.2的地址设置为缺省网关；vlan 3的机器，把bridge1.3设置为缺省网关。当有包要从vlan 2发往vlan 3是，它将送到bridge0.2，然后，通过路由，找到bridge1.3，然后由bridge1.3发出去。这个过程中，packet里面的vlan id会发生改变。这个例子里面，要求从bridge port上收到的包都必须是打tag的，在bridge里面，并不能识别和处理tag，只有到三层的vlan interface才能识别并处理这些tag.</p>
</blockquote>
<p>另外，Linux VLAN则是802.1Q的实现，可以参考<a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="external">链接</a></p>
<h2 id="参考链接">参考链接</h2><p><a href="http://book.douban.com/subject/26333234/" target="_blank" rel="external">《云计算网络珠玑》</a><br><a href="http://book.douban.com/subject/25919428/" target="_blank" rel="external">《 图解网络硬件》</a><br><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/kernel_flow" target="_blank" rel="external">kernel  flow</a><br><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge" target="_blank" rel="external">linux bridge</a><br><a href="http://book.douban.com/subject/1475839/" target="_blank" rel="external">《Understanding Linux Network Internals》</a><br><a href="http://www.kernelchina.org/node/214" target="_blank" rel="external">关于linux 802.1d (bridge) 和 802.1q(vlan) 实现的再思考</a><br><a href="http://www.candelatech.com/~greear/vlan.html" target="_blank" rel="external">802.1Q VLAN implementation for Linux</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本科加上研究生大概有七年时间，一直都是学的通信，不过覆盖面不是很全，一直对一些网络相关的概念和实现有些模糊。最近补了补通信网络中的一些基础知识和盲点，有目的地看了看《云计算网络珠玑》、《图解网络硬件》等和网络相关的书和一些文章，做一下记录总结。主要包括了二层交换、三层路由、Linux网络相关的内容。</p>]]>
    
    </summary>
    
      <category term="网络" scheme="http://yikun.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Threading model]]></title>
    <link href="http://yikun.github.io/2015/11/19/%E8%AF%91-Threading-model/"/>
    <id>http://yikun.github.io/2015/11/19/译-Threading-model/</id>
    <published>2015-11-19T13:34:04.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Threading_model">Threading model</h1><blockquote>
<p>All OpenStack services use green thread model of threading, implemented through using the Python eventlet and greenlet libraries.</p>
<p>Green threads use a cooperative model of threading: thread context switches can only occur when specific eventlet or greenlet library calls are made (e.g., sleep, certain I/O calls). From the operating system’s point of view, each OpenStack service runs in a single thread.</p>
<p>The use of green threads reduces the likelihood of race conditions, but does not completely eliminate them. In some cases, you may need to use the @lockutils.synchronized(…) decorator to avoid races.</p>
<p>In addition, since there is only one operating system thread, a call that blocks that main thread will block the entire process.</p>
</blockquote>
<p>理解：OpenStack的所有服务都使用Green thread，使用eventlet和greenlet库，绿色线程使用协作并发模型，线程的切换只在eventlet或greenlet库调用一些切换时发生。从操作系统角度上来看，每个OpenStack运行在一个单一线程。用Green Thread的好处是能够减少race conditions，当然有些时候我们也必须使用@lockutils.synchronized(…)来完全避免。因为只用一个系统级别的单线程，所以调用一旦阻塞就会阻塞整个进程。</p>
<p>关于Python中的并发模型，可以参考<a href="http://www.oschina.net/translate/python-concurrency-model" target="_blank" rel="external">Python并发模型</a>一文，把Thread（线程切换耗资源）、MicroThread（依靠解释器调度）、Green thread（协作并发）的特点对比了下。</p>
<p>还有<a href="http://www.cnblogs.com/sevenyuan/archive/2010/12/08/1900386.html" target="_blank" rel="external">Python几种并发实现方案的性能比较</a>将Python中的集中并发方案进行了对比和说明。</p>
<h2 id="Yielding_the_thread_in_long-running_tasks">Yielding the thread in long-running tasks</h2><blockquote>
<p>If a code path takes a long time to execute and does not contain any methods that trigger an eventlet context switch, the long-running thread will block any pending threads.</p>
<p>This scenario can be avoided by adding calls to the eventlet sleep method in the long-running code path. The sleep call will trigger a context switch if there are pending threads, and using an argument of 0 will avoid introducing delays in the case that there is only a single green thread:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> eventlet <span class="keyword">import</span> greenthread</span><br><span class="line">...</span><br><span class="line">greenthread.sleep(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>理解：对于那些耗时很长的任务，需要我们添加一些yield方法，来避免在单个的调用中阻塞很久。</p>
<h2 id="MySQL_access_and_eventlet">MySQL access and eventlet</h2><blockquote>
<p>Queries to the MySQL database will block the main thread of a service. This is because OpenStack services use an external C library for accessing the MySQL database. Since eventlet cannot use monkey-patching to intercept blocking calls in a C library, the resulting database query blocks the thread.</p>
<p>The Diablo release contained a thread-pooling implementation that did not block, but this implementation resulted in a bug and was removed.</p>
</blockquote>
<p>理解：对于MySQL数据的查询会阻塞服务，因为eventlet对C库的调用是无法去做monkey-patching的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Threading_model">Threading model</h1><blockquote>
<p>All OpenStack services use green thread model of threading, implemented through]]>
    </summary>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Host Aggregates]]></title>
    <link href="http://yikun.github.io/2015/10/17/%E8%AF%91-Host-Aggregates/"/>
    <id>http://yikun.github.io/2015/10/17/译-Host-Aggregates/</id>
    <published>2015-10-17T03:15:40.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>先上一个自己画的图，非常有助于理解Host Aggregates:<br><img src="https://cloud.githubusercontent.com/assets/1736354/10556767/3a9f3156-74c0-11e5-94f2-1b8befff9aff.png" alt="host aggregates"></p>
<a id="more"></a>
<h1 id="Host_Aggregates">Host Aggregates</h1><blockquote>
<p>Host aggregates can be regarded as a mechanism to further partition an availability zone; while availability zones are visible to users, host aggregates are only visible to administrators. Host aggregates started out as a way to use Xen hypervisor resource pools, but has been generalized to provide a mechanism to allow administrators to assign key-value pairs to groups of machines. Each node can have multiple aggregates, each aggregate can have multiple key-value pairs, and the same key-value pair can be assigned to multiple aggregate. This information can be used in the scheduler to enable advanced scheduling, to set up xen hypervisor resources pools or to define logical groups for migration.</p>
</blockquote>
<p>理解：Host Aggregates可以视为是AZ(Avaliability Zone)的更进一步的划分，是对管理员可见的。每一个节点都可以属于多个Aggregates，这些Aggregates可以用作更高级的调度、配置Xen的资源池、或者定义用于升级的逻辑分组。可以理解为aggregate是一组具有相同属性主机的分组。</p>
<h2 id="Availability_Zones_(AZs)">Availability Zones (AZs)</h2><blockquote>
<p>Availability Zones are the end-user visible logical abstraction for partitioning a cloud without knowing the physical infrastructure. That abstraction doesn’t come up in Nova with an actual database model since the availability zone is actually a specific metadata information attached to an aggregate. Adding that specific metadata to an aggregate makes the aggregate visible from an end-user perspective and consequently allows to schedule upon a specific set of hosts (the ones belonging to the aggregate).</p>
<p>That said, there are a few rules to know that diverge from an API perspective between aggregates and availability zones:</p>
<ul>
<li>one host can be in multiple aggregates, but it can only be in one availability zone</li>
<li>by default a host is part of a default availability zone even if it doesn’t belong to an aggregate (the configuration option is named default_availability_zone)</li>
</ul>
</blockquote>
<p>理解：Availability Zones可以理解为将一个aggregate加了一些metadata信息，使得对用户可见。他和Aggregate最主要的区别是，一个节点只能属于一个AZ，默认一个主机属于一个默认的AZ。</p>
<h2 id="Xen_Pool_Host_Aggregates">Xen Pool Host Aggregates</h2><blockquote>
<p>Originally all aggregates were Xen resource pools, now an aggregate can be set up as a resource pool by giving the aggregate the correct key-value pair.</p>
<p>You can use aggregates for XenServer resource pools when you have multiple compute nodes installed (only XenServer/XCP via xenapi driver is currently supported), and you want to leverage the capabilities of the underlying hypervisor resource pools. For example, you want to enable VM live migration (i.e. VM migration within the pool) or enable host maintenance with zero-downtime for guest instances. Please, note that VM migration across pools (i.e. storage migration) is not yet supported in XenServer/XCP, but will be added when available. Bear in mind that the two migration techniques are not mutually exclusive and can be used in combination for a higher level of flexibility in your cloud management.</p>
</blockquote>
<p>理解：可以将Xen的划分到一个Aggregate，来支持Xen资源池的一些特性。</p>
<h2 id="Design">Design</h2><blockquote>
<p>The OSAPI Admin API is extended to support the following operations:</p>
<ul>
<li>Aggregates</li>
</ul>
<p>list aggregates: returns a list of all the host-aggregates (optionally filtered by availability zone)<br>create aggregate: creates an aggregate, takes a friendly name, etc. returns an id<br>show aggregate: shows the details of an aggregate (id, name, availability_zone, hosts and metadata)<br>update aggregate: updates the name and availability zone of an aggregate<br>set metadata: sets the metadata on an aggregate to the values supplied<br>delete aggregate: deletes an aggregate, it fails if the aggregate is not empty<br>add host: adds a host to the aggregate<br>remove host: removes a host from the aggregate</p>
<ul>
<li>Hosts</li>
</ul>
<p>start host maintenance (or evacuate-host): disallow a host to serve API requests and migrate instances to other hosts of the aggregate<br>stop host maintenance: (or rebalance-host): put the host back into operational mode, migrating instances back onto that host</p>
</blockquote>
<p>理解：对于Aggregate操作有：列出、创建、显示信息、更新、设置metadaa、删除、添加主机、移除主机。对于host的操作有：开启维护主机、停止维护主机。</p>
<p>参考资料：<br><a href="http://www.cnblogs.com/xingyun/p/4703325.html" target="_blank" rel="external">openstack中region、az、host aggregate、cell 概念</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先上一个自己画的图，非常有助于理解Host Aggregates:<br><img src="https://cloud.githubusercontent.com/assets/1736354/10556767/3a9f3156-74c0-11e5-94f2-1b8befff9aff.png" alt="host aggregates"></p>]]>
    
    </summary>
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Scope of the Nova project]]></title>
    <link href="http://yikun.github.io/2015/10/16/%E8%AF%91-Scope-of-the-Nova-project/"/>
    <id>http://yikun.github.io/2015/10/16/译-Scope-of-the-Nova-project/</id>
    <published>2015-10-16T12:02:54.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Scope_of_the_Nova_project">Scope of the Nova project</h1><blockquote>
<p>Nova is focusing on doing an awesome job of its core mission. This document aims to clarify that core mission.</p>
<p>This is a living document to help record where we agree about what Nova should and should not be doing, and why. Please treat this as a discussion of interesting, and hopefully useful, examples. It is not intended to be an exhaustive policy statement.</p>
</blockquote>
<p>理解：文档的主要内容是，理清Nova的核心使命。</p>
<a id="more"></a>
<h2 id="Misson">Misson</h2><blockquote>
<p>Our mission statement starts with:<br>To implement services and associated libraries to provide massively scalable, on demand, self service access to compute resources.</p>
<p>Our official mission statement also includes the following examples of compute resources: bare metal, virtual machines, and containers. For the full official mission statement see: <a href="http://governance.openstack.org/reference/projects/nova.html#mission" target="_blank" rel="external">http://governance.openstack.org/reference/projects/nova.html#mission</a></p>
<p>This document aims to help clarify what the mission statement means.</p>
</blockquote>
<p>理解：Nova的核心任务是：实现大规模可扩展地、按需地、自助地访问计算资源的服务和相关库。</p>
<h3 id="Compute_Resource">Compute Resource</h3><blockquote>
<p>Nova is all about access to compute resources. This section looks at the types of compute resource Nova works with.</p>
</blockquote>
<p>理解：Nova的一切都是和访问计算资源相关的。这节讲讲Nova主要能够在哪些计算资源上工作。</p>
<h3 id="Virtual_Servers">Virtual Servers</h3><blockquote>
<p>Nova was originally focused purely on providing access to virtual servers running on a variety of different hypervisors. The majority of users use Nova only to provide access to virtual servers from a single hypervisor, however, its possible to have a Nova deployment include multiple different types of hypervisors, while at the same time offering containers and bare metal servers.</p>
</blockquote>
<p>理解：Nova支持在不同hypervisor的虚拟服务器的访问，同时，也支持容器和裸金属服务器</p>
<h3 id="Containers">Containers</h3><blockquote>
<p>The Nova API is not a good fit for a lot of container use cases. The Magnum project intends to deliver a good container experience built on top of Nova.</p>
<p>Nova allows you to use containers in a similar way to how you would use on demand virtual machines. We want to maintain this distinction, so we maintain the integrity and usefulness of the existing Nova API.</p>
<p>For example, Nova is not designed to spin up new containers for every apache request, nor do we plan to control what goes on inside containers. They get the same metadata provided to them as virtual machines, to do with as they see fit.</p>
</blockquote>
<p>理解：</p>
<ul>
<li>Magnum项目用来统一容器访问接口。</li>
<li>Nova API提供统一的抽象层：用同样的方式去按需使用容器。</li>
</ul>
<h3 id="Bare_Metal_Servers">Bare Metal Servers</h3><blockquote>
<p>Ironic project has been pioneering the idea of treating physical machines in a similar way to on demand virtual machines.</p>
<p>Nova’s driver is able to allow a multi-tenant cloud style use of Ironic controlled resources.</p>
<p>While currently there are operations that are a fundamental part of our virtual machine abstraction that are not currently available in ironic, such as attaching iSCSI volumes, it does not fundamentally change the semantics of our API, and as such is a suitable Nova driver. Moreover, it is expected that gap with shrink over time.</p>
</blockquote>
<p>理解：Ironic项目项目用来统一不同物理机器的访问接口。</p>
<h3 id="Driver_Parity">Driver Parity</h3><blockquote>
<p>Our goal for the Nova API to provide a consistent abstraction to access on demand compute resources. We are not aiming to expose all features of all hypervisors. Where the details of the underlying hypervisor leak through our APIs, we have failed in this goal, and we must work towards better abstractions that are more interoperable. This is one reason why we put so much emphasis on the use of Tempest in third party CI systems.</p>
<p>The key tenant of driver parity is that if a feature is supported in a driver, it must feel the same to users, as if they where using any of the other drivers that also support that feature. The exception is that, if possible for widely different performance characteristics, but the effect of that API call must be identical.</p>
<p>Following on from that, should a feature only be added to one of the drivers, we must make every effort to ensure another driver could be implemented to match that behavior.</p>
<p>Its important that drivers support enough features, so the API actually provides a consistent abstraction. For example, being unable to create a server or delete a server, would severely undermine that goal. In fact, Nova only ever manages resources it creates.</p>
</blockquote>
<p>理解：</p>
<ul>
<li>Nova API的目标是提供一个一致的抽象来访问那些按需提供的计算资源。</li>
<li>支持一个驱动就要支持其他驱动，允许性能有差异</li>
</ul>
<h2 id="Upgrades">Upgrades</h2><blockquote>
<p>Nova is widely used in production. As such we need to respect the needs of our existing users. At the same time we need evolve the current code base, including both adding and removing features.</p>
<p>This section outlines how we expect people to upgrade, and what we do to help existing users that upgrade in the way we expect.</p>
</blockquote>
<p>理解：升级权衡兼容性和新功能增删</p>
<h3 id="Upgrade_expectations">Upgrade expectations</h3><blockquote>
<p>Our upgrade plan is to concentrate on upgrades from N-1 to the Nth release. So for someone running juno, they would have to upgrade to kilo before upgrading to liberty. This is designed to balance the need for a smooth upgrade, against having to keep maintaining the compatibility code to make that upgrade possible. We talk about this approach as users consuming the stable branch.</p>
<p>In addition, we also support users upgrading from the master branch. Technically, between any two between any two commits within the same release cycle. In certain cases, when crossing release boundaries, you must upgrade to the stable branch, before then upgrading to the tip of master. This is to support those that are doing some level of “Continuous Deployment” from the tip of master into production. Many of the public cloud provides running OpenStack use this approach so they are able to get access to bug fixes and features they work on into production sooner.</p>
<p>This becomes important when you consider reverting a commit that turns out to have been bad idea. We have to assume any public API change may have already been deployed into production, and as such cannot be reverted. In a similar way, a database migration may have been deployed.</p>
<p>Any commit that will affect an upgrade gets the UpgradeImpact tag added to the commit message, so there is no requirement to wait for release notes.</p>
</blockquote>
<p>理解：</p>
<ul>
<li>OpenStack的升级只支持N-1到N版本，主要考虑，一是平滑升级，二是节省时间。</li>
<li>支持master版本升级，保证bug和功能快速生效</li>
<li>同一版本，两个commit之间可以升；跨越版本，就得先升stable。</li>
<li>不能回退</li>
<li>影响升级需要打<code>UpgradeImpack</code>的标签</li>
</ul>
<h3 id="Don’t_break_existing_users">Don’t break existing users</h3><p>As a community we are aiming towards a smooth upgrade process, where users must be unaware you have just upgraded your deployment, except that there might be additional feature available and improved stability and performance of some existing features.</p>
<p>We don’t ever want to remove features our users rely on. Sometimes we need to migrate users to a new implementation of that feature, which may require extra steps by the deployer, but the end users must be unaffected by such changes. However there are times when some features become a problem to maintain, and fall into disrepair. We aim to be honest with our users and highlight the issues we have, so we are in a position to find help to fix that situation. Ideally we are able to rework the feature so it can be maintained, but in some rare cases, the feature no longer works, is not tested, and no one is stepping forward to maintain that feature, the best option can be to remove that feature.</p>
<p>When we remove features, we need warn users by first marking those features as deprecated, before we finally remove the feature. The idea is to get feedback on how important the feature is to our user base. Where a feature is important we work with the whole community to find a path forward for those users.</p>
<p>理解：</p>
<ul>
<li>不要干扰到已有用户的使用</li>
<li>如果一些功能，实在不能工作，而且确实没人维护了，就删掉它</li>
<li>删功能的时候，先deprecated，然后最终删除</li>
</ul>
<h2 id="API_Scope">API Scope</h2><blockquote>
<p>Nova aims to provide a highly interoperable and stable REST API for our users to get self-service access to compute resources.</p>
</blockquote>
<p>理解：Nova提供一个可操作性强、稳定的REST API</p>
<h3 id="No_more_API_Proxies">No more API Proxies</h3><blockquote>
<p>Nova API current has some APIs that are now (in kilo) mostly just a proxy to other OpenStack services. If it were possible to remove a public API, these are some we might start with. As such, we don’t want to add any more.</p>
<p>The first example is the API that is a proxy to the Glance v1 API. As Glance moves to deprecate its v1 API, we need to translate calls from the old v1 API we expose, to Glance’s v2 API.</p>
<p>The next API to mention is the networking APIs, in particular the security groups API. If you are using nova-network, Nova is still the only way to perform these network operations. But if you use Neutron, security groups has a much richer Neutron API, and if you use both Nova API and Neutron API, the miss match can lead to some very unexpected results, in certain cases.</p>
<p>Our intention is to avoid adding to the problems we already have in this area.</p>
</blockquote>
<p>理解：目前Nova API中有一些API只是其他服务的代理，以后不会再添加类似的代理服务了。</p>
<h3 id="No_more_Orchestration">No more Orchestration</h3><blockquote>
<p>Nova is a low level infrastructure API. It is plumbing upon which richer ideas can be built. Heat and Magnum being great examples of that.</p>
<p>While we have some APIs that could be considered orchestration, and we must continue to maintain those, we do not intend to add any more APIs that do orchestration.</p>
</blockquote>
<p>理解：Nova是一个低层次基础设施的API，不会有过多的编排的内容。</p>
<h3 id="Third_Party_APIs">Third Party APIs</h3><blockquote>
<p>Nova aims to focus on making a great API that is highly interoperable across all Nova deployments.</p>
<p>We have historically done a very poor job of implementing and maintaining compatibility with third party APIs inside the Nova tree.</p>
<p>As such, all new efforts should instead focus on external projects that provide third party compatibility on top of the Nova API. Where needed, we will work this those projects to extending the Nova API such that its possible to add that functionality on top of the Nova API. However, we do not intend to add API calls for those services to persist third party API specific information in the Nova database. Instead we want to focus on additions that enhance the existing Nova API.</p>
</blockquote>
<p>理解：Nova正在重视第三方API，尤其重视可以提高现有API的第三方API。</p>
<h2 id="Scalability">Scalability</h2><p>Our mission includes the text “massively scalable”. Lets discuss what that means.</p>
<p>Nova has three main axises of scale: Number of API requests, number of compute nodes and number of active instances. In many cases the number of compute nodes and active instances are so closely related, you rarely need to consider those separately. There are other items, such at the number of tenants, and the number of instances per tenant. But, again, these are very rarely the key scale issue. Its possible to have a small cloud with lots of requests for very short lived VMs, or a large cloud with lots of longer lived VMs. These need to scale out different components of the Nova system to reach their required level of scale.</p>
<p>Ideally all Nova components are either scaled out to match the number of API requests and build requests, or scaled out to match the number of running servers. If we create components that have their load increased relative to both of these items, we can run into inefficiencies or resource contention. Although it is possible to make that work in some cases, this should always be considered.</p>
<p>We intend Nova to be usable for both small and massive deployments. Where small involves 1-10 hypervisors and massive deployments are single regions with greater than 10,000 hypervisors. That should be seen as our current goal not an upper limit.</p>
<p>There are some features that would not scale well for either the small scale or the very large scale. Ideally we would not accept these features, but if there is a strong case to add such features, we must work hard to ensure you can run without that feature at the scale you are required to run.</p>
<p>理解：</p>
<ul>
<li>可扩展性在Nova中非常看重，Nova系统要适用小规模和大规模的部署。</li>
<li>对于Nova的扩展包括：API请求数的扩展或者服务器运行数量，或者两者均有</li>
<li>目前需求（比如大于10000的hypervisor）是目前的目标，但不是上限</li>
<li>新增功能要考虑可扩展性</li>
</ul>
<h2 id="IaaS_not_Batch_Processing">IaaS not Batch Processing</h2><blockquote>
<p>Currently Nova focuses on providing on-demand compute resources in the style of classic Infrastructure-as-a-service clouds. A large pool of compute resources that people can consume in a self-service way.</p>
<p>Nova is not currently optimized for dealing with a larger number of requests for compute resources compared with the amount of compute resource thats currently available. We generally assume a level of spare capacity is maintained for future requests. This is needed for users that want to quickly scale out, and extra capacity becomes available again as users scale in. While spare capacity is also not required, we are not optimizing for a system that aims to run at 100% capacity at all times. As such our quota system is more focused on limiting the current level of resource usage, rather than ensuring a fair balance of resources between all incoming requests. This doesn’t exclude adding features to support making a better use of spare capacity, such as “spot instances”.</p>
<p>There have been discussions around how to change Nova to work better for batch job processing. But the current focus is on how to layer such an abstraction on top of the basic primitives Nova currently provides, possibly adding additional APIs where that makes good sense. Should this turn out to be impractical, we may have to revise our approach.</p>
</blockquote>
<p>理解：Nova重视现有水平的资源利用，目前比较重视作为Iaas的API。</p>
<h2 id="Deployment_and_Packaging">Deployment and Packaging</h2><blockquote>
<p>Nova does not plan on creating its own packaging or deployment systems.</p>
<p>Our CI infrastructure is powered by Devstack. This can also be used by developers to test their work on a full deployment of Nova.</p>
<p>We do not develop any deployment or packaging for production deployments. Being widely adopted by many distributions and commercial products, we instead choose to work with all those parties to ensure they are able to effectively package and deploy Nova.</p>
</blockquote>
<p>理解：</p>
<ul>
<li>无计划创建独立的打包和部署</li>
<li>用Devstack持续集成</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Scope_of_the_Nova_project">Scope of the Nova project</h1><blockquote>
<p>Nova is focusing on doing an awesome job of its core mission. This document aims to clarify that core mission.</p>
<p>This is a living document to help record where we agree about what Nova should and should not be doing, and why. Please treat this as a discussion of interesting, and hopefully useful, examples. It is not intended to be an exhaustive policy statement.</p>
</blockquote>
<p>理解：文档的主要内容是，理清Nova的核心使命。</p>]]>
    
    </summary>
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Nova System Architecture]]></title>
    <link href="http://yikun.github.io/2015/10/15/%E8%AF%91-Nova-System-Architecture/"/>
    <id>http://yikun.github.io/2015/10/15/译-Nova-System-Architecture/</id>
    <published>2015-10-15T02:04:44.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Nova系统架构">Nova系统架构</h3><blockquote>
<p>Nova is built on a <strong>shared-nothing</strong>, <strong>messaging-based</strong> architecture. All of the major nova components can be run on <strong>multiple servers</strong>. This means that most component to component communication must go via <strong>message queue</strong>. In order to <strong>avoid blocking</strong> each component while waiting for a response, we use <strong>deferred objects</strong>, with a <strong>callback</strong> that gets triggered when a response is received.</p>
</blockquote>
<p>Nova建立在一个无共享，基于消息的架构。所有的nova主要组件都可以运行在不同的服务器。这就意味着大多数组件之间的通信必须通过消息队列。为了避免每个组件在等待响应时的阻塞，我们是用deferred对象，当一个响应接收时会触发相应的回调。</p>
<a id="more"></a>
<blockquote>
<p>Nova recently moved to using a sql-based central database that is shared by all components in the system. The amount and depth of the data fits into a sql database quite well. For small deployments this seems like an optimal solution. For larger deployments, and especially if security is a concern, nova will be moving towards multiple data stores with some kind of aggregation system.</p>
</blockquote>
<p>Nova最近正在迁移到一个基于SQL的中心数据库，系统中所有组件都共享一个数据库。大量的深度的数据非常适合存放在SQL数据库中。对于小型部署，这是一个最佳方案。对于大型部署，特别是非常看重安全的话，nova也将会进一步搬到不同集成系统中的多种数据库。</p>
<h3 id="组件">组件</h3><p>下面将看到两种不同的架构：<br><img src="https://cloud.githubusercontent.com/assets/1736354/10502572/14066a24-7320-11e5-9552-e230cd8fa5cb.png" alt="qq20151015-0 2x"></p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/10502582/2c4de97c-7320-11e5-9b33-2defabd49a7d.png" alt="qq20151015-1 2x"></p>
<ul>
<li>DB: 基于SQL的数据存储</li>
<li>API: 组件接收HTTP请求，可以通过osl.messaging和HTTP来转换指令和通信</li>
<li>Scheduler: 决定哪个host获得某个instance</li>
<li>Network: 管理IP转发、网桥、vlans</li>
<li>Compute: 管理hypervisor和virtual machines的通信</li>
<li>Conductor: 处理需要调整(build/resize)的请求，作为数据库代理，或者处理对象的转换</li>
</ul>
<blockquote>
<p>While all services are designed to be <strong>horizontally scalable</strong>, you should have significantly more computes then anything else.</p>
</blockquote>
<p>由于所有的服务都被设计为横向扩展的，你只需要更多的计算机就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Nova系统架构">Nova系统架构</h3><blockquote>
<p>Nova is built on a <strong>shared-nothing</strong>, <strong>messaging-based</strong> architecture. All of the major nova components can be run on <strong>multiple servers</strong>. This means that most component to component communication must go via <strong>message queue</strong>. In order to <strong>avoid blocking</strong> each component while waiting for a response, we use <strong>deferred objects</strong>, with a <strong>callback</strong> that gets triggered when a response is received.</p>
</blockquote>
<p>Nova建立在一个无共享，基于消息的架构。所有的nova主要组件都可以运行在不同的服务器。这就意味着大多数组件之间的通信必须通过消息队列。为了避免每个组件在等待响应时的阻塞，我们是用deferred对象，当一个响应接收时会触发相应的回调。</p>]]>
    
    </summary>
    
      <category term="Nova" scheme="http://yikun.github.io/tags/Nova/"/>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读《OpenStack设计与实现》]]></title>
    <link href="http://yikun.github.io/2015/10/08/%E8%AF%BB%E3%80%8AOpenStack%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
    <id>http://yikun.github.io/2015/10/08/读《OpenStack设计与实现》/</id>
    <published>2015-10-08T13:52:35.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="初始OpenStack和开发基础">初始OpenStack和开发基础</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10370055/daf455b2-6e0f-11e5-98c3-d3e17ee7d97d.PNG" alt="openstack_ch1ch2"></p>
<p>OpenStack起于RakeSpace和NASA的合作，相关知识涉及到了云计算和虚拟化，体系结构上来看OpenStack是处于Iaas层，目前来看，还是处于追随AWS的阶段。OpenStack的子项目从新项目、孵化项目最终发展成为核心及集成项目。</p>
<a id="more"></a>
<p>作者比较文艺，对于文档的重要性是这么描述的：</p>
<blockquote>
<p>每一个项目，每一个模块，甚至每一行代码都有着自己的故事，这些故事都应该被留存在自己的历史档案里，而我们大部分的时间都只是他们的过客而已。</p>
</blockquote>
<p>另外，还有一个重要的东西就是Code Review，核心思想：</p>
<blockquote>
<p>一旦一个问题被充分地描述了他的细节，那么解决方法也是显而易见的。</p>
</blockquote>
<p>OpenStack的代码质量保证体系大概就是以下几点：</p>
<ul>
<li>编码规范：编码规范遵循着PEP-8，使用Flake8进行代码静态检测；</li>
<li>代码评审：使用Gerrit进行代码评审，保证所有代码都Code Review后才能Merge；</li>
<li>单元测试：位于tests目录，使用tox执行；</li>
<li>持续集成：使用Jenkins来做自动化测试，测试例则用Tempest框架</li>
</ul>
<p>其实，整个过程还是比较清晰的，现在只是大致了解一下过程，后面真正开发的时候亲身体验一下再深入理解。最后，又介绍了一些关于贡献代码、文档、Review之类的一些说明，其中，Feature的贡献，需要先在Blueprint提出来一些想法和设计，然后通过后再在spec里详细描述一些细节。</p>
<p>对于阅读代码，也给了一个基本的思路，因为代码的脉络比较复杂，所以推荐先阅读setup.cfg，然后从entry point入手，逐个功能、服务去突破。OpenStack牵扯到的背景知识，主要有Python、Linux、网络基础、虚拟化、Git，除了虚拟化外，其他掌握的还行。所以，后面多看看虚拟化方面的内容。</p>
<h3 id="虚拟化">虚拟化</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10417118/0f341a10-7063-11e5-8e1d-63e13f5eadb4.png" alt="default"></p>
<p>对于OpenStack来说，虚拟化相关内容是非常核心的内容，自然本书的第三章独立出来介绍虚拟化的知识。<br>虚拟化的按照实现方式来说，主要分为Hypervisior模型和Hosted模型。</p>
<ul>
<li>Hypervisior模型，VMM直接运行在硬件平台上，控制所有硬件并管理客户操作系统。操作系统运行在VMM之上；</li>
<li>Hosted模型，VMM则是在操作系统之上，就想是操作系统的一个软件层。</li>
</ul>
<p>按照平台类型来说，则大致分为完全虚拟化和类虚拟化。</p>
<ul>
<li>完全虚拟化，最初是使用二进制翻译实现的，后期硬件支持后，也可以通过硬件辅助支持；</li>
<li>类虚拟化，通过修改系统内核来实现，通用性较差。<br>虚拟化包括了CPU虚拟化、内存虚拟化、I/O虚拟化、网络虚拟化，引入虚拟化后主要的特性为：动态迁移、快照、克隆，这些新特性对于目前对需要长时间稳定运行的系统来说，有非常重要的意义。</li>
</ul>
<p>对于虚拟化相关知识，有参考了一些其他资料：<br><a href="http://book.douban.com/subject/19986436/" target="_blank" rel="external">《虚拟化技术原理与实现》</a><br><a href="http://book.douban.com/subject/3619896/" target="_blank" rel="external">《系统虚拟化原理与实现》</a><br><a href="http://www.vmware.com/files/pdf/VMware_paravirtualization.pdf" target="_blank" rel="external">Understanding Full Virtualization, Paravirtualization, and Hardware Assist</a>(<a href="http://blog.csdn.net/flyforfreedom2008/article/details/45113635" target="_blank" rel="external">翻译</a>)</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="初始OpenStack和开发基础">初始OpenStack和开发基础</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10370055/daf455b2-6e0f-11e5-98c3-d3e17ee7d97d.PNG" alt="openstack_ch1ch2"></p>
<p>OpenStack起于RakeSpace和NASA的合作，相关知识涉及到了云计算和虚拟化，体系结构上来看OpenStack是处于Iaas层，目前来看，还是处于追随AWS的阶段。OpenStack的子项目从新项目、孵化项目最终发展成为核心及集成项目。</p>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenStack概览]]></title>
    <link href="http://yikun.github.io/2015/10/04/OpenStack%E6%A6%82%E8%A7%88/"/>
    <id>http://yikun.github.io/2015/10/04/OpenStack概览/</id>
    <published>2015-10-04T11:33:16.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概览">1. 概览</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10267380/3f2d8b74-6ac4-11e5-9372-6bc21c57f11f.png" alt="openstack-software-diagram"></p>
<blockquote>
<p>OpenStack is a <strong>cloud operating system</strong> that controls large pools of <strong>compute</strong>, <strong>storage</strong>, and <strong>networking</strong> resources throughout a datacenter, all managed through a <strong>dashboard</strong> that gives administrators control while empowering their users to provision resources through a web interface.</p>
</blockquote>
<a id="more"></a>
<p>正如OpenStack官方定义的那样，OpenStack是一个云操作系统，他管理这大量的计算、存储、网络资源，也提供了一个dashborad让管理员通过Web接口方便的管理资源。目前的版本已经是K版了，在看了<a href="https://www.youtube.com/v/y39CAXJAW3M" target="_blank" rel="external">OpenStack Kilo Overview Demo</a>的视频后，对OpenStack有了最初的了解。</p>
<h3 id="2-_核心功能">2. 核心功能</h3><p><strong>Compute</strong></p>
<blockquote>
<p><strong>Provision and manage large networks of virtual machines.</strong></p>
<p>The OpenStack cloud operating system enables enterprises and service providers to <strong>offer on-demand computing resources</strong>, by provisioning and managing large networks of virtual machines. Compute resources are accessible via <strong>APIs</strong> for developers building cloud applications and via <strong>web interfaces</strong> for administrators and users. The compute architecture is designed to <strong>scale horizontally</strong> on standard hardware, enabling the cloud economics companies have come to expect.</p>
</blockquote>
<p>几个关键信息：按需提供计算资源、提供API给开发者、提供Web接口给用户、横向扩展。然后又专门介绍了OpenStack的灵活的架构，它支持各种不同的硬件，比如普通的计算机可以，高性能计算机也可以；也支持不同的软件，比如支持各种不同的虚拟化技术，比如KVM、XEN、LXC等等。</p>
<p><strong>Storage</strong></p>
<blockquote>
<p>Object and block storage for use with servers and applications.</p>
<p>In addition to traditional enterprise-class storage technology, many organizations now have a variety of storage needs with varying performance and price requirements. OpenStack has support for both <strong>Object Storage</strong> and <strong>Block Storage</strong>, with many deployment options for each depending on the use case. </p>
<p>Object Storage is ideal for <strong>cost effective, scale-out</strong> storage. It provides a fully distributed, API-accessible storage platform that can be integrated directly into applications or used for backup, archiving and data retention. Block Storage allows block devices to be exposed and connected to compute instances for <strong>expanded storage, better performance and integration</strong> with enterprise storage platforms, such as NetApp, Nexenta and SolidFire.</p>
</blockquote>
<p>几个关键信息，提供了对象存储和块存储，对象存储有高效的成本，横向扩展性，块存储则为了更好的扩容、更好的性能以及和企业其他存储平台的集成。</p>
<p><strong>Network</strong></p>
<blockquote>
<p>Pluggable, scalable, API-driven network and ip management.</p>
<p>Today’s datacenter networks contain more devices than ever before servers, network equipment, storage systems and security appliances — many of which are further divided into virtual machines and virtual networks. The number of IP addresses, routing configurations and security rules can quickly grow into the millions. Traditional network management techniques fall short of providing a <strong>truly scalable, automated approach to managing these next-generation networks</strong>. At the same time, <strong>users expect more control and flexibility with quicker provisioning</strong>.</p>
<p>OpenStack Networking is a <strong>pluggable</strong>, <strong>scalable</strong> and <strong>API-driven</strong> system for managing networks and IP addresses. Like other aspects of the cloud operating system, it can be used by administrators and users to increase the value of existing datacenter assets. OpenStack Networking ensures the network will not be the bottleneck or limiting factor in a cloud deployment and gives users real self service, even over their network configurations.</p>
</blockquote>
<p>关键信息：现今数据中心的设备越来越多，配置也非常多，需要一个可扩展、自动化的管理下一代网络，同时用户也希望仅通过快速配置，掌控更多，更灵活。所以就有OpenStack Networking了，一个用于管理网络和IP的可插拔、可扩展、API驱动的系统。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://www.openstack.org/software/" target="_blank" rel="external">OpenStack官方介绍</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概览">1. 概览</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/10267380/3f2d8b74-6ac4-11e5-9372-6bc21c57f11f.png" alt="openstack-software-diagram"></p>
<blockquote>
<p>OpenStack is a <strong>cloud operating system</strong> that controls large pools of <strong>compute</strong>, <strong>storage</strong>, and <strong>networking</strong> resources throughout a datacenter, all managed through a <strong>dashboard</strong> that gives administrators control while empowering their users to provision resources through a web interface.</p>
</blockquote>]]>
    
    </summary>
    
      <category term="OpenStack" scheme="http://yikun.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见，北京]]></title>
    <link href="http://yikun.github.io/2015/06/18/%E5%86%8D%E8%A7%81%EF%BC%8C%E5%8C%97%E4%BA%AC/"/>
    <id>http://yikun.github.io/2015/06/18/再见，北京/</id>
    <published>2015-06-18T08:10:00.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="在北大">在北大</h2><p>一年多的时间，基本都在中国第一学府——北京大学。这里有未名湖畔的波光粼粼，也有博雅塔下的春风垂柳；有艺园吃腻很久的炒菜米饭，也有小白房冒菜不限量的芝麻酱和鳕鱼培根夹馍；有农园清淡爽口的菜肴和炸酱面，也有畅春园改善伙食的麻辣香锅。总之一切都还美好，只是有老校医院实验室中永远调不完的bug后，其他的一切又稍显黯淡。<br><a id="more"></a><br><img src="https://cloud.githubusercontent.com/assets/1736354/8226649/080762dc-15d3-11e5-84da-82fbe052541f.jpg" alt="img_20150407_144120"></p>
<h2 id="在古迹">在古迹</h2><p>周末的闲暇时光，也会去各个古迹去探索一番，从长城的一砖一瓦中，猜得出北京千年的文化的底蕴；故宫里的金瓦红墙，看得到旧朝的兴盛衰亡；圆明园的断壁残垣，见证着过往苍白的历史。这些古迹除了斑驳的历史以外，还有一个共同点，那就是人多。有时候想想也会觉得惊讶，北京的各个景点在任何的时候都充斥着络绎不绝的游客。</p>
<p>静静地坐落在京西的古刹龙泉寺，却又是以另一种沉静展现出新的世界。听说，行走在寺中的任何一个僧人都可能清华北大拿到全奖留美offer的才俊，也有人戏称这里是清华北大的分校。 一叶一菩提，一沙一世界，在这新的世界里，真的会让人有种沉寂身心，潜学求知的心境。</p>
<p>￼<img src="https://cloud.githubusercontent.com/assets/1736354/8226648/08050492-15d3-11e5-9393-3a723df17352.jpg" alt="img_20150406_121939"></p>
<h2 id="在四季">在四季</h2><p>一直觉得，来到一个城市，只有见过了她的四季才算来过。当我真真切切地感受到北京的春夏秋冬后，这座城的全部已经烙入我的心中：春天凌乱纷飞的迷乱柳絮，夏日说来就来的疯狂暴雨，秋季萧瑟苍凉的香山红叶，冬夜刺骨冻人的凛冽大风。当你在这时，她分明的四季演绎出这座城池的精彩，当你不在时，她同样会把更精彩的四季展示给其他千千万万的北漂人。</p>
<h2 id="在苏州街">在苏州街</h2><p>最开始的几个月，住在苏州街，这个有几分诗意的名字，却和她的忙碌一点儿也不相符。每天早上，看着疾步似飞的北漂人在梦想路上暴走。从酒店到北大的路也是分外的熟悉。晴好的夜晚，也会在中关村这片跑个几公里。相信明朝的太监们怎么也想不到，如今他们的故里已经成为中国IT的中心。中关村的环形天桥矗立在密密麻麻的互联网公司之上，下面也永远是车水马龙。行人满脸匆忙地在桥上穿梭，好像整个世界都按了快进。当你夜晚静静的驻足桥上，零星的装点竟然有种豪华的感觉。看着底下走走停停的车辆，别有一番说不出的滋味。</p>
<p>￼<img src="https://cloud.githubusercontent.com/assets/1736354/8226647/07ef1f6a-15d3-11e5-951b-47a5ea96913d.jpg" alt="img_20150425_230259"></p>
<h2 id="在“漂”">在“漂”</h2><p>转眼间已经在北京待了一年时间，渐渐地体会到了“漂”的内涵。不是在风中飘摇的飘，而是在水上漂泊的漂，而北京浑厚丰富地资源就像浩瀚无边的海洋。这座古韵十足而深藏活力的城池，永远都在这里等待着成千上万的创业者，成功失败都在这里发生。有的时候，你需要在让人喘不过气的雾霾中，奋力的挣扎去呼吸，去成长，当然了，让人喘不过气的东西也不仅仅是雾霾。北京承载了太多人的期望，或为生计，或为梦想。他们在这里，生根发芽，这里有太多太多的竞争者，也有太多太多的机会。</p>
<h2 id="再见">再见</h2><p>晚上，就要离开北京了，那么：再见，北京！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="在北大">在北大</h2><p>一年多的时间，基本都在中国第一学府——北京大学。这里有未名湖畔的波光粼粼，也有博雅塔下的春风垂柳；有艺园吃腻很久的炒菜米饭，也有小白房冒菜不限量的芝麻酱和鳕鱼培根夹馍；有农园清淡爽口的菜肴和炸酱面，也有畅春园改善伙食的麻辣香锅。总之一切都还美好，只是有老校医院实验室中永远调不完的bug后，其他的一切又稍显黯淡。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的网络数据包工具——Packet Assistant]]></title>
    <link href="http://yikun.github.io/2015/06/15/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Packet-Assistant/"/>
    <id>http://yikun.github.io/2015/06/15/一个简单的网络数据包工具——Packet-Assistant/</id>
    <published>2015-06-15T11:11:00.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_起因">1. 起因</h3><p>最近一段时间，总是有一些<strong>发数据包、抓数据包</strong>之类的需求，主要是需要定制以太网MAC层的源MAC地址、目的MAC地址、协议类型之类的东西。</p>
<p>之前实现这些都是用Winpcap实现的，然后用某基础类库去实现界面，实在是受不了“某基础类库”庞大冗余的结构了。这时，看到了PyQt，整个人一下清爽起来。所以，Packet Assistant就诞生了。</p>
<p>总而言之，言而总之：</p>
<blockquote>
<p>Packet Assistant是一个简单的发包、抓包工具。</p>
</blockquote>
<a id="more"></a>
<h3 id="2-_依赖">2. 依赖</h3><ul>
<li><a href="http://www.riverbankcomputing.com/software/pyqt/download" target="_blank" rel="external">PyQt 4</a></li>
</ul>
<p>Python底下其实有很多的GUI库，比如<a href="http://www.zhihu.com/question/27159913" target="_blank" rel="external">这里</a>提到的一些，因为之前对C++的Qt比较熟，所以，比较能够理解Qt的设计思想，用PyQt的时候，也觉得还好，和原生Qt没什么差，主要是考虑了需要一个类似Qt Designer的东西快速搭界面。所以就选了PyQt了。</p>
<ul>
<li><a href="https://github.com/CoreSecurity/pcapy/wiki/Compiling-Pcapy-on-Windows-Guide" target="_blank" rel="external">Pcapy</a></li>
</ul>
<p>Python网络抓包的库，Winpcap官网的<a href="https://www.winpcap.org/misc/links.htm" target="_blank" rel="external">友情链接</a>提到了这个库，比起<a href="https://github.com/dugsong/pypcap" target="_blank" rel="external">PyPcap</a>，Pcapy的例子、支持感觉更好些。</p>
<h3 id="3-_截图">3. 截图</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/8158460/d367be9a-138f-11e5-84ae-346611f8aa59.png" alt="packetassist"></p>
<h3 id="4-_最后">4. 最后</h3><p>Enjoy it! :+1: </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_起因">1. 起因</h3><p>最近一段时间，总是有一些<strong>发数据包、抓数据包</strong>之类的需求，主要是需要定制以太网MAC层的源MAC地址、目的MAC地址、协议类型之类的东西。</p>
<p>之前实现这些都是用Winpcap实现的，然后用某基础类库去实现界面，实在是受不了“某基础类库”庞大冗余的结构了。这时，看到了PyQt，整个人一下清爽起来。所以，Packet Assistant就诞生了。</p>
<p>总而言之，言而总之：</p>
<blockquote>
<p>Packet Assistant是一个简单的发包、抓包工具。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Python" scheme="http://yikun.github.io/tags/Python/"/>
    
      <category term="网络" scheme="http://yikun.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring IOC核心源码学习]]></title>
    <link href="http://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yikun.github.io/2015/05/29/Spring-IOC核心源码学习/</id>
    <published>2015-05-28T16:34:39.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_初始化">1. 初始化</h3><p>大致单步跟了下Spring IOC的初始化过程，整个脉络很庞大，初始化的过程主要就是<strong>读取XML资源，并解析，最终注册到Bean Factory中</strong>：</p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png" alt="flow"></p>
<a id="more"></a>
<p>在完成初始化的过程后，Bean们就在BeanFactory中蓄势以待地等调用了。下面通过一个具体的例子，来详细地学习一下初始化过程，例如当加载下面一个bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"XiaoWang"</span> <span class="attribute">class</span>=<span class="value">"com.springstudy.talentshow.SuperInstrumentalist"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"instruments"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"piano"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"saxophone"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>加载时需要读取、解析、注册bean，这个过程具体的调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7896285/8a488060-06e6-11e5-9ad9-4ddd3375984f.png" alt="load"></p>
<p>下面对每一步的关键的代码进行详细分析：</p>
<h4 id="1-1_准备">1.1 准备</h4><p><strong>保存配置位置，并刷新</strong><br>在调用ClassPathXmlApplicationContext后，先会将配置位置信息保存到configLocations，供后面解析使用，之后，会调用<code>AbstractApplicationContext</code>的refresh方法进行刷新：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, </span><br><span class="line">        ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 保存位置信息，比如`com/springstudy/talentshow/talent-show.xml`</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建载入BeanFactory</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>创建XMLBeanDefinitionReader</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span><br><span class="line">     <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2_读取">1.2 读取</h4><p><strong>创建处理每一个resource</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span></span><br><span class="line">     <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// 通过Location来读取Resource</span></span><br><span class="line">    Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">    <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        <span class="comment">// 载入每一个resource</span></span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>处理XML每个元素</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    NodeList nl = root.getChildNodes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">        Node node = nl.item(i);</span><br><span class="line">        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                <span class="comment">// 处理每个xml中的元素，可能是import、alias、bean</span></span><br><span class="line">                parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>解析和注册bean</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 注册</span></span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(</span><br><span class="line">			    bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本步骤中，通过<code>parseBeanDefinitionElement</code>将XML的元素解析为<code>BeanDefinition</code>，然后存在<code>BeanDefinitionHolder</code>中，然后再利用<code>BeanDefinitionHolder</code>将<code>BeanDefinition</code>注册，实质就是把<code>BeanDefinition</code>的实例put进<code>BeanFactory</code>中，和后面将详细的介绍解析和注册过程。</p>
<h4 id="1-3_解析">1.3 解析</h4><p><img src="https://cloud.githubusercontent.com/assets/1736354/7896302/eae02bc6-06e6-11e5-941a-d1f59e3b363f.png" alt="process"></p>
<p><strong>处理每个Bean的元素</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span><br><span class="line">        Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="comment">// 创建beandefinition</span></span><br><span class="line">    AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">    parseMetaElements(ele, bd);</span><br><span class="line">    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 处理“Constructor”</span></span><br><span class="line">    parseConstructorArgElements(ele, bd);</span><br><span class="line">    <span class="comment">// 处理“Preperty”</span></span><br><span class="line">    parsePropertyElements(ele, bd);</span><br><span class="line">    parseQualifierElements(ele, bd);</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>处理属性的值</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">parsePropertyValue</span><span class="params">(Element ele, BeanDefinition bd, String propertyName)</span> </span>&#123;</span><br><span class="line">    String elementName = (propertyName != <span class="keyword">null</span>) ?</span><br><span class="line">                    <span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</span><br><span class="line">                    <span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">    <span class="keyword">if</span> (hasRefAttribute) &#123;</span><br><span class="line">    <span class="comment">// 处理引用</span></span><br><span class="line">        String refName = ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">            error(elementName + <span class="string">" contains empty 'ref' attribute"</span>, ele);</span><br><span class="line">        &#125;</span><br><span class="line">        RuntimeBeanReference ref = <span class="keyword">new</span> RuntimeBeanReference(refName);</span><br><span class="line">        ref.setSource(extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(hasValueAttribute)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理值</span></span><br><span class="line">        TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">        valueHolder.setSource(extractSource(ele));</span><br><span class="line">        <span class="keyword">return</span> valueHolder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(subElement != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理子类型（比如list、map等）</span></span><br><span class="line">        <span class="keyword">return</span> parsePropertySubElement(subElement, bd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-4_注册">1.4 注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span><br><span class="line">        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="line">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将beanDefinition注册</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册过程中，最核心的一句就是：<code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>，也就是说注册的实质就是以beanName为key，以beanDefinition为value，将其put到HashMap中。</p>
<h3 id="2-_注入依赖">2. 注入依赖</h3><p>当完成初始化IOC容器后，如果bean没有设置lazy-init(延迟加载)属性，那么bean的实例就会在初始化IOC完成之后，及时地进行初始化。初始化时会先建立实例，然后根据配置利用反射对实例进行进一步操作，具体流程如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929429/615570ea-0930-11e5-8097-ae982ef7709d.png" alt="bean_flow"></p>
<p><strong>创建bean的实例</strong><br>创建bean的实例过程函数调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929379/cec01bcc-092f-11e5-81ad-88c285f33845.png" alt="create_bean"></p>
<p><strong>注入bean的属性</strong><br>注入bean的属性过程函数调用栈如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7929381/db58350e-092f-11e5-82a4-caaf349291ea.png" alt="inject_property"></p>
<p>在创建bean和注入bean的属性时，都是在doCreateBean函数中进行的，我们重点看下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, </span><br><span class="line">        <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建bean的实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化bean的实例，如注入属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>理解了以上两个过程，我们就可以自己实现一个简单的Spring框架了。于是，我根据自己的理解实现了一个简单的IOC框架<a href="https://github.com/Yikun/simple-spring" target="_blank" rel="external">Simple Spring</a>，有兴趣可以看看。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_初始化">1. 初始化</h3><p>大致单步跟了下Spring IOC的初始化过程，整个脉络很庞大，初始化的过程主要就是<strong>读取XML资源，并解析，最终注册到Bean Factory中</strong>：</p>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/7897341/032179be-070b-11e5-9ecf-d7befc804e9d.png" alt="flow"></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学习awk和sed]]></title>
    <link href="http://yikun.github.io/2015/05/24/%E5%AD%A6%E4%B9%A0awk%E5%92%8Csed/"/>
    <id>http://yikun.github.io/2015/05/24/学习awk和sed/</id>
    <published>2015-05-23T16:52:31.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<p>最近把awk和sed又系统地学习了下，使用<a href="http://naotu.baidu.com/" target="_blank" rel="external">百度脑图</a>简单地整理了一下大概的思路：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7785009/0d604ea2-01af-11e5-8fdc-b658a02e76bc.png" alt="awk sed"></p>
<p>参考资料<br><a href="http://book.douban.com/subject/1236944/" target="_blank" rel="external">《sed与awk》</a><br><a href="http://coolshell.cn/articles/9104.html" target="_blank" rel="external">sed 简明教程</a><br><a href="http://coolshell.cn/articles/9070.html" target="_blank" rel="external">awk 简明教程</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近把awk和sed又系统地学习了下，使用<a href="http://naotu.baidu.com/" target="_blank" rel="external">百度脑图</a>简单地整理了一下大概的思路：<br><img src="https://cloud.g]]>
    </summary>
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用Shell进行Web日志分析]]></title>
    <link href="http://yikun.github.io/2015/05/21/%E5%88%A9%E7%94%A8Shell%E8%BF%9B%E8%A1%8CWeb%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>http://yikun.github.io/2015/05/21/利用Shell进行Web日志分析/</id>
    <published>2015-05-20T16:24:48.000Z</published>
    <updated>2016-06-29T15:47:27.000Z</updated>
    <content type="html"><![CDATA[<h4 id="1-Web日志">1.Web日志</h4><p>Web日志由Web服务器产生，比如Nginx、Apache等。例如一条Nginx的日志格式可能是这样的：</p>
<blockquote>
<p>222.68.172.190 - - [18/Sep/2013:06:49:57 +0000] “GET /images/my.jpg HTTP/1.1” 200 19939<br> “<a href="http://www.angularjs.cn/A00n" target="_blank" rel="external">http://www.angularjs.cn/A00n</a>“ “Mozilla/5.0 (Windows NT 6.1)<br> AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36”</p>
</blockquote>
<p>可以拆解为以下8个变量</p>
<blockquote>
<p>remote_addr: 记录客户端的ip地址, 222.68.172.190<br>remote_user: 记录客户端用户名称, –<br>time_local: 记录访问时间与时区, [18/Sep/2013:06:49:57 +0000]<br>request: 记录请求的url与http协议, “GET /images/my.jpg HTTP/1.1″<br>status: 记录请求状态,成功是200, 200<br>body_bytes_sent: 记录发送给客户端文件主体内容大小, 19939<br>http_referer: 用来记录从那个页面链接访问过来的, “<a href="http://www.angularjs.cn/A00n”" target="_blank" rel="external">http://www.angularjs.cn/A00n”</a><br>http_user_agent: 记录客户浏览器的相关信息, “Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36″</p>
</blockquote>
<h4 id="提取最近10分钟的日志：">提取最近10分钟的日志：</h4><p>思路一：利用awk提取时间，并做字符串比较<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在OSX环境下，需要安装coreutils保证`date`等指令正常使用</span></span><br><span class="line"><span class="comment"># brew install coreutils</span></span><br><span class="line">tac <span class="built_in">log</span> | </span><br><span class="line">awk <span class="string">'BEGIN&#123;</span><br><span class="line">    # 获取时间至min10</span><br><span class="line">    "date -d \"-10 minute\" +\"%H:%M:%S\"" | getline min10 </span><br><span class="line">&#125; </span><br><span class="line">&#123;</span><br><span class="line">    # 日志时间和当前时间比较</span><br><span class="line">    if (substr($4,14) &gt; min10) </span><br><span class="line">        print ;</span><br><span class="line">    # 若一次不匹配则退出</span><br><span class="line">    else </span><br><span class="line">        exit;</span><br><span class="line">&#125;'</span> |</span><br><span class="line">tac</span><br></pre></td></tr></table></figure></p>
<p>思路二：利用grep的正则匹配，捕获满足条件的时刻<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | grep -E <span class="string">"19/Sep/2013:06:2[4-9]|19/Sep/2013:06:3[0-3]"</span></span><br></pre></td></tr></table></figure></p>
<p>思路三：使用sed的地址(时刻必须出现)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span> | sed -n <span class="string">'/19\/Sep\/2013:06:24/,//19\/Sep\/2013:06:33/p'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="统计某个接口(xxxapi)访问量和QPS">统计某个接口(xxxapi)访问量和QPS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat log | grep xxxapi | wc -l</span></span><br><span class="line">query=$(cat <span class="built_in">log</span> | grep -c xxxapi)</span><br><span class="line">t=<span class="number">60</span></span><br><span class="line">qps=$((query/<span class="variable">$time</span>))</span><br></pre></td></tr></table></figure>
<h4 id="参考资料">参考资料</h4><p><a href="http://blog.fens.me/hadoop-mapreduce-log-kpi/" target="_blank" rel="external">海量Web日志分析 用Hadoop提取KPI统计指标</a><br><a href="https://www.centos.bz/2012/11/shell-scrpit-auto-count-log/" target="_blank" rel="external">shell脚本每天自动统计网站访问日志</a><br><a href="http://www.oschina.net/question/42741_115440" target="_blank" rel="external">如何用Shell截取nginx最近10分钟的日志</a><br><a href="http://bbs.chinaunix.net/thread-4096403-1-1.html" target="_blank" rel="external">如何用awk从日志文件中找到时间范围的数据</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="1-Web日志">1.Web日志</h4><p>Web日志由Web服务器产生，比如Nginx、Apache等。例如一条Nginx的日志格式可能是这样的：</p>
<blockquote>
<p>222.68.172.190 - - [18/Sep/2013:06:]]>
    </summary>
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[重新学习Shell]]></title>
    <link href="http://yikun.github.io/2015/05/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Shell/"/>
    <id>http://yikun.github.io/2015/05/19/重新学习Shell/</id>
    <published>2015-05-19T04:42:23.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<p>之前，虽然已经对<code>Shell</code>比较熟悉了，但是遇到一些不太常用，但是却很有用的命令，还得搜个半天。所以，这几天准备把常用的指令重新过一下，然后再把基础的<code>Shell</code>流程控制、<code>awk</code>的操作等常用命令系统地学习一下，一方面作为总结，另一方面也作为一个Cheat Sheet，时不时的补充一下也是极好的，: )。</p>
<h4 id="基本语法">基本语法</h4><p><strong>传参</strong><br><code>$n</code> - 传递的第n个参数<br><code>$#</code> - 传递的参数个数<br><code>$*</code> - 所有参数<br><code>$@</code> - 所有参数，加引号为字符串数组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># var.sh arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arg1 arg2 arg3</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"></span><br><span class="line"><span class="comment"># @:arg1</span></span><br><span class="line"><span class="comment"># @:arg2</span></span><br><span class="line"><span class="comment"># @:arg3</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> @:<span class="string">"<span class="variable">$arg</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *:arg1 arg2 arg3</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> *:<span class="string">"<span class="variable">$arg</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p><strong>if条件控制</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> <span class="operator">-eq</span> <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a euqals b."</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> <span class="operator">-lt</span> <span class="variable">$b</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a little than b."</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$a</span> <span class="operator">-gt</span> <span class="variable">$b</span> ]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"a greater than b."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">str=<span class="string">"linux"</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$str</span>"</span> == <span class="string">"linux"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"str is linux."</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ -e filename]    判断文件存在</span></span><br><span class="line"><span class="comment"># [ -d pathname] 判断目录存在</span></span><br></pre></td></tr></table></figure>
<p><strong>循环控制</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr=(<span class="string">"hello"</span> <span class="string">"bash"</span> <span class="string">"shell"</span>)</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> <span class="variable">$&#123;arr[*]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h4 id="常用指令">常用指令</h4><p><strong><em>head/tail</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前5行</span></span><br><span class="line">head -<span class="number">5</span></span><br><span class="line">head -n <span class="number">5</span></span><br><span class="line"><span class="comment"># 前n-5行</span></span><br><span class="line">head -n -<span class="number">5</span></span><br><span class="line"><span class="comment"># 后n-5行</span></span><br><span class="line">tail -n +<span class="number">5</span></span><br><span class="line"><span class="comment"># 前5字节</span></span><br><span class="line">head -c <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>sort</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略起始空格(b)数值(n)去重(u)逆序(r)按照:分隔(-t ':')的第二列(-k 2)排序</span></span><br><span class="line">sort -bnur -t <span class="string">':'</span> -k <span class="number">2</span> somefile</span><br></pre></td></tr></table></figure></p>
<p><strong><em>grep</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前文件夹的所有文件递归(-r)搜索main</span></span><br><span class="line">grep -r <span class="string">"main"</span> *</span><br><span class="line"><span class="comment"># 搜索匹配正则(-E)的行数(-c)，（带main或者括弧的）</span></span><br><span class="line">grep -cE <span class="string">"main|\(\)"</span> *</span><br><span class="line"><span class="comment"># 搜索不包含extern的(-v --&gt; invert-match)</span></span><br><span class="line">grep -v <span class="string">"extern"</span></span><br></pre></td></tr></table></figure></p>
<p><strong><em>wc</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有.c文件的行数</span></span><br><span class="line">grep -r <span class="string">""</span> *.c | wc <span class="operator">-l</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前，虽然已经对<code>Shell</code>比较熟悉了，但是遇到一些不太常用，但是却很有用的命令，还得搜个半天。所以，这几天准备把常用的指令重新过一下，然后再把基础的<code>Shell</code>流程控制、<code>awk</code>的操作等常用命令系统地]]>
    </summary>
    
      <category term="Linux" scheme="http://yikun.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java CopyOnWriteArrayList工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/28/Java-CopyOnWriteArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/28/Java-CopyOnWriteArrayList工作原理及实现/</id>
    <published>2015-04-28T15:58:01.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。</p>
<p>因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。</p>
<p>增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。</p>
<p>因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git常用操作总结]]></title>
    <link href="http://yikun.github.io/2015/04/25/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://yikun.github.io/2015/04/25/Git常用操作总结/</id>
    <published>2015-04-24T17:13:25.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<p>用Git比较久了，之前一直在Win用的TortoiseGit，现在命令行用的比较多，所以把一些指令总结一下，以便回顾和查询。</p>
<p>理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。</p>
<h3 id="设置">设置</h3><pre><code>$ git config --global user<span class="class">.name</span> <span class="string">"Your Name"</span>
$ git config --global user<span class="class">.email</span> <span class="string">"email@example.com"</span>
</code></pre><h3 id="提交">提交</h3><p>git tracked的是修改，而不是文件</p>
<pre><code><span class="comment">#将“当前修改”移动到暂存区(stage)</span>
<span class="variable">$ </span>git add somfile.txt
<span class="comment">#将暂存区修改提交</span>
<span class="variable">$ </span>git commit -m <span class="string">"Add somfile.txt."</span>
</code></pre><h3 id="状态">状态</h3><pre><code><span class="variable">$ </span>git status
<span class="variable">$ </span>git diff
</code></pre><h3 id="回退">回退</h3><pre><code># 放弃工作区修改
$ git checkout <span class="comment">-- file.name</span>
$ git checkout <span class="comment">-- .</span>

# 取消<span class="operator"><span class="keyword">commit</span>(比如需要重写<span class="keyword">commit</span>信息)
$ git <span class="keyword">reset</span> <span class="comment">--soft HEAD</span>

# 取消<span class="keyword">commit</span>、<span class="keyword">add</span>(重新提交代码和<span class="keyword">commit</span>)
$ git <span class="keyword">reset</span> HEAD
$ git <span class="keyword">reset</span> <span class="comment">--mixed HEAD</span>

# 取消<span class="keyword">commit</span>、<span class="keyword">add</span>、工作区修改(需要完全重置)
$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD</span></span>
</code></pre><h3 id="记录">记录</h3><pre><code><span class="variable">$ </span>git reflog
<span class="variable">$ </span>git log
</code></pre><h3 id="删除">删除</h3><pre><code>$ <span class="keyword">rm</span> <span class="keyword">file</span>.name
$ git <span class="keyword">rm</span> <span class="keyword">file</span>.name
$ git commit -<span class="keyword">m</span> <span class="string">"Del"</span>
</code></pre><h3 id="远程操作">远程操作</h3><pre><code><span class="variable">$ </span>git remote add origin git<span class="variable">@github</span>.<span class="symbol">com:</span>michaelliao/learngit.git
<span class="comment"># 第一次推送，-u(--set-upstream)指定默认上游</span>
<span class="variable">$ </span>git push -u origin master
<span class="variable">$ </span>git push origin master
</code></pre><h3 id="克隆">克隆</h3><pre><code>$ git clone https:<span class="comment">//github.com/Yikun/yikun.github.com.git path</span>
$ git clone git@github<span class="class">.com</span>:Yikun/yikun<span class="class">.github</span><span class="class">.com</span><span class="class">.git</span> path
</code></pre><h3 id="分支操作">分支操作</h3><pre><code><span class="comment"># 产看当前分支</span>
<span class="variable">$ </span>git branch

<span class="comment"># 创建分支</span>
<span class="variable">$ </span>git branch dev
<span class="comment"># 切换分支</span>
<span class="variable">$ </span>git checkout dev

<span class="comment"># 创建并checkout分支</span>
<span class="variable">$ </span>git checkout -b dev


<span class="comment"># 合并分支</span>
<span class="variable">$ </span>git merge dev

<span class="comment"># 删除分支</span>
<span class="variable">$ </span>git branch -d dev
</code></pre><h3 id="标签">标签</h3><pre><code><span class="variable">$ </span>git tag <span class="number">0</span>.<span class="number">1.1</span>
<span class="variable">$ </span>git push origin --tags
</code></pre><h3 id="同步上游">同步上游</h3><pre><code><span class="comment">// 1. 添加上游</span>
git remote <span class="keyword">add</span> upstream
<span class="comment">// 2. 切换需要同步的分支</span>
git checkout XXX
<span class="comment">// 3. 更新上游</span>
git remote update upstream
git rebase upstream/<span class="comment">{branch name}</span>
<span class="comment">// 4. 解决冲突</span>
<span class="comment">// 手动解决冲突</span>
git <span class="keyword">add</span> .
git rebase --<span class="keyword">continue</span>
<span class="comment">// 5. push</span>
git push
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>用Git比较久了，之前一直在Win用的TortoiseGit，现在命令行用的比较多，所以把一些指令总结一下，以便回顾和查询。</p>
<p>理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管]]>
    </summary>
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java EnumMap工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/24/Java-EnumMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/24/Java-EnumMap工作原理及实现/</id>
    <published>2015-04-23T16:11:56.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-概述">1.概述</h3><blockquote>
<p>A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient.</p>
</blockquote>
<p>EnumMap是是一种键为枚举类型的特殊的Map实现。所有的Key也必须是一种枚举类型，EnumMap是使用数组来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Course, String&gt; map = <span class="keyword">new</span> EnumMap&lt;Course, String&gt;(Course.class);</span><br><span class="line">map.put(Course.ONE, <span class="string">"语文"</span>);</span><br><span class="line">map.put(Course.ONE, <span class="string">"政治"</span>);</span><br><span class="line">map.put(Course.TWO, <span class="string">"数学"</span>);</span><br><span class="line">map.put(Course.THREE, <span class="string">"英语"</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Course, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ONE</span>: <span class="string">政治</span></span><br><span class="line"><span class="attribute">TWO</span>: <span class="string">数学</span></span><br><span class="line"><span class="attribute">THREE</span>: <span class="string">英语</span></span><br></pre></td></tr></table></figure></p>
<p>其具体实现的结构如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7323140/1dc9a734-eadf-11e4-96f8-8df820f64590.png" alt="enummap"></p>
<h3 id="2-_put和get方法">2. put和get方法</h3><p>put方法通过key的ordinal将值存储到对应的地方，get方法则根据key的ordinal获取对应的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类型检查</span></span><br><span class="line">    typeCheck(key);</span><br><span class="line">    <span class="comment">// 获取key的序号</span></span><br><span class="line">    <span class="keyword">int</span> index = key.ordinal();</span><br><span class="line">    Object oldValue = vals[index];</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    vals[index] = maskNull(value);</span><br><span class="line">    <span class="comment">// 若之前的值为空，则size++</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>)</span><br><span class="line">        size++;</span><br><span class="line">    <span class="keyword">return</span> unmaskNull(oldValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (isValidKey(key) ?</span><br><span class="line">            unmaskNull(vals[((Enum&lt;?&gt;)key).ordinal()]) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_遍历">3. 遍历</h3><p>EnumMapIterator的迭代这样实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; vals.length &amp;&amp; vals[index] == <span class="keyword">null</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">return</span> index != vals.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Map.Entry&lt;K,V&gt; next() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNext())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    lastReturnedEntry = <span class="keyword">new</span> Entry(index++);</span><br><span class="line">    <span class="keyword">return</span> lastReturnedEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过hasNext跳过空的数组，也就是说，保证了遍历顺序与Enum中key的先后顺序一致。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://javarevisited.blogspot.jp/2012/09/what-is-enummap-in-java-example-tutorial.html" target="_blank" rel="external">What is EnumMap in Java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-概述">1.概述</h3><blockquote>
<p>A specialized Map implementation for use with enum type keys. All of the keys in an enum map must com]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言中移位操作符优先级的坑]]></title>
    <link href="http://yikun.github.io/2015/04/18/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%9D%91/"/>
    <id>http://yikun.github.io/2015/04/18/C语言中移位操作符优先级的坑/</id>
    <published>2015-04-18T09:16:55.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<p>今天和tiancai交流他腾讯面试题目的时候，有这么一个题目，大致是这样描述的：</p>
<blockquote>
<p>有一个函数f，可以等概率产生0,1，写一个函数g，可以等概率地产生0~7中的数。</p>
</blockquote>
<p>于是，我写出了如下一个错误的解法：</p>
<blockquote>
<p>f()+f()&lt;&lt;1+f()&lt;&lt;2</p>
</blockquote>
<p>而正确的应该是：</p>
<blockquote>
<p>f() + (f()&lt;&lt;1) + (f()&lt;&lt;2)</p>
</blockquote>
<p>之前一直有误解，而实际情况是是<strong>移位操作符的优先级低于加减法的优先级</strong>。为了验证和加深记忆，又写了一个小测试：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1&lt;&lt;1+2&lt;&lt;1:     %d\n"</span>, <span class="number">1</span>&lt;&lt;<span class="number">1</span>+<span class="number">2</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1&lt;&lt;(1+2)&lt;&lt;1:   %d\n"</span>, <span class="number">1</span>&lt;&lt;(<span class="number">1</span>+<span class="number">2</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"(1&lt;&lt;1)+(2&lt;&lt;1): %d\n"</span>, (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)+(<span class="number">2</span>&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出为:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&lt;&lt;<span class="number">1</span><span class="number">+2</span>&lt;&lt;<span class="number">1</span>:     <span class="number">16</span></span><br><span class="line"><span class="number">1</span>&lt;&lt;<span class="comment">(1+2)</span>&lt;&lt;<span class="number">1</span>:   <span class="number">16</span></span><br><span class="line"><span class="comment">(1&lt;&lt;1)</span>+<span class="comment">(2&lt;&lt;1)</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>其中编译的时候，也有一个友情提示：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.<span class="string">c:</span><span class="number">4</span>:<span class="number">36</span>: <span class="string">warning:</span> operator <span class="string">'&lt;&lt;'</span> has lower precedence than <span class="string">'+'</span>; <span class="string">'+'</span> will be</span><br><span class="line">      evaluated first [-Wshift-op-parentheses]</span><br><span class="line">        printf(<span class="string">"1&lt;&lt;1+2&lt;&lt;1:     %d\n"</span>, <span class="number">1</span>&lt;&lt;<span class="number">1</span>+<span class="number">2</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">                                       ~~~^~</span><br><span class="line">main.<span class="string">c:</span><span class="number">4</span>:<span class="number">36</span>: <span class="string">note:</span> place parentheses around the <span class="string">'+'</span> expression to silence <span class="keyword">this</span></span><br><span class="line">      warning</span><br><span class="line">        printf(<span class="string">"1&lt;&lt;1+2&lt;&lt;1:     %d\n"</span>, <span class="number">1</span>&lt;&lt;<span class="number">1</span>+<span class="number">2</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">                                          ^</span><br><span class="line">                                         (  )</span><br><span class="line"><span class="number">1</span> warning generated.</span><br></pre></td></tr></table></figure></p>
<p>最后，</p>
<blockquote>
<p>希望自己永远保持一颗怀疑的心。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天和tiancai交流他腾讯面试题目的时候，有这么一个题目，大致是这样描述的：</p>
<blockquote>
<p>有一个函数f，可以等概率产生0,1，写一个函数g，可以等概率地产生0~7中的数。</p>
</blockquote>
<p>于是，我写出了如下一个错误的]]>
    </summary>
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java ArrayDeque工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/11/Java-ArrayDeque%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/11/Java-ArrayDeque工作原理及实现/</id>
    <published>2015-04-11T10:50:32.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>Resizable-array implementation of the <strong>Deque interface</strong>. Array deques have no capacity restrictions; they <strong>grow as necessary to support usage</strong>. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue.</p>
</blockquote>
<p><img src="https://cloud.githubusercontent.com/assets/1736354/7120880/13a5b9a4-e243-11e4-8a63-33c4852c268c.png" alt="arrayqueue"></p>
<blockquote>
<p>以循环数组实现的双向Queue。大小是2的倍数，默认是16。</p>
<p>普通数组只能快速在末尾添加元素，为了支持FIFO，从数组头快速取出元素，就需要使用循环数组：有队头队尾两个下标：弹出元素时，队头下标递增；加入元素时，如果已到数组空间的末尾，则将元素循环赋值到数组<a href="如果此时队头下标大于0，说明队头弹出过元素，有空位">0</a>，同时队尾下标指向0，再插入下一个元素则赋值到数组[1]，队尾下标指向1。如果队尾的下标追上队头，说明数组所有空间已用完，进行双倍的数组扩容。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>Resizable-array implementation of the <strong>Deque interface</strong>. Array deques have no capaci]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java TreeSet工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/10/Java-TreeSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/10/Java-TreeSet工作原理及实现/</id>
    <published>2015-04-10T09:05:12.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-概述">1.概述</h3><blockquote>
<p>A NavigableSet implementation based on a <strong>TreeMap</strong>. The elements are ordered using their natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used.This implementation provides guaranteed <strong>log(n)</strong> time cost for the basic operations (add, remove and contains).</p>
</blockquote>
<p>TreeSet是基于TreeMap实现的，也非常简单，同样的只是用key及其操作，然后把value置为dummy的object。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; tset = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line">tset.add(<span class="string">"1语文"</span>);</span><br><span class="line">tset.add(<span class="string">"3英语"</span>);</span><br><span class="line">tset.add(<span class="string">"2数学"</span>);</span><br><span class="line">tset.add(<span class="string">"4政治"</span>);</span><br><span class="line">tset.add(<span class="string">"5历史"</span>);</span><br><span class="line">tset.add(<span class="string">"6地理"</span>);</span><br><span class="line">tset.add(<span class="string">"7生物"</span>);</span><br><span class="line">tset.add(<span class="string">"8化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : tset) &#123;</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其具体的结构是：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7085286/d0b1658c-dfa7-11e4-972c-d1d07e5fadfd.png" alt="treeset"></p>
<p>利用TreeMap的特性，实现了set的有序性(通过红黑树实现)。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" target="_blank" rel="external">TreeSet(Java Platform SE 8)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-概述">1.概述</h3><blockquote>
<p>A NavigableSet implementation based on a <strong>TreeMap</strong>. The elements are ordered using the]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java LinkedHashSet工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/09/Java-LinkedHashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/09/Java-LinkedHashSet工作原理及实现/</id>
    <published>2015-04-09T14:50:16.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p><strong>Hash table and linked list implementation of the Set interface</strong>, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.)</p>
</blockquote>
<p>LinkedHashSet是基于HashMap和双向链表的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;String&gt; lset = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">lset.add(<span class="string">"语文"</span>);</span><br><span class="line">lset.add(<span class="string">"数学"</span>);</span><br><span class="line">lset.add(<span class="string">"英语"</span>);</span><br><span class="line">lset.add(<span class="string">"历史"</span>);</span><br><span class="line">lset.add(<span class="string">"政治"</span>);</span><br><span class="line">lset.add(<span class="string">"地理"</span>);</span><br><span class="line">lset.add(<span class="string">"生物"</span>);</span><br><span class="line">lset.add(<span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(String str : lset) &#123;</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用链表来记录，保证了迭代输出的有序性。其具体结构如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7082382/14d44b8e-df86-11e4-8e50-1e925f430b6e.png" alt="hashset"><br>可以看出，其实现基本和LinkedHashMap一样。</p>
<h3 id="2-_关键实现">2. 关键实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p>从继承关系来看就知道LinkedHashMap的实现非常简单，就是集成HashSet的接口，并且在构造时调用的是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">	map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，结构也便是如HashSet于HashMap一样，LinkedHashSet也便如LinkedHashMap一样，只是将Value做了一个dummy的object。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html" target="_blank" rel="external">LinkedHashSet</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p><strong>Hash table and linked list implementation of the Set interface</strong>, with predictable i]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java HashSet工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/08/Java-HashSet%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/08/Java-HashSet工作原理及实现/</id>
    <published>2015-04-08T15:31:28.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>This class implements the Set interface, backed by a hash table (actually a <strong>HashMap</strong> instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element.</p>
</blockquote>
<p>HashSet是基于HashMap来实现的，操作很简单，更像是对HashMap做了一次“封装”，而且只使用了HashMap的key来实现各种特性，我们先来感性的认识一下这个结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">"语文"</span>);</span><br><span class="line">set.add(<span class="string">"数学"</span>);</span><br><span class="line">set.add(<span class="string">"英语"</span>);</span><br><span class="line">set.add(<span class="string">"历史"</span>);</span><br><span class="line">set.add(<span class="string">"政治"</span>);</span><br><span class="line">set.add(<span class="string">"地理"</span>);</span><br><span class="line">set.add(<span class="string">"生物"</span>);</span><br><span class="line">set.add(<span class="string">"化学"</span>);</span><br></pre></td></tr></table></figure></p>
<p>其大致的结构是这样的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7060522/0bcfd890-deb5-11e4-97b3-d4e811766893.png" alt="hashset"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p><code>map</code>是整个HashSet的核心，而<code>PRESENT</code>则是用来造一个假的value来用的。</p>
<h3 id="2-_基本操作">2. 基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本操作也非常简单，就是调用HashMap的相关方法，其中value就是之前那个dummy的Object。所以，只要了解#7 HashMap的实现就可以了。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="external">HashSet(Java Platform 8)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>This class implements the Set interface, backed by a hash table (actually a <strong>HashMap</strong]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java PriorityQueue工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/07/Java-PriorityQueue%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/07/Java-PriorityQueue工作原理及实现/</id>
    <published>2015-04-07T14:25:48.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="参考资料">参考资料</h3><p><a href="http://www.iteye.com/topic/1061958" target="_blank" rel="external">基于最小堆（小根堆）的topn算法</a><br><a href="http://my.oschina.net/leejun2005/blog/135085" target="_blank" rel="external">基于堆实现的优先级队列：PriorityQueue 解决 Top K 问题</a><br><a href="http://www.importnew.com/6932.html" target="_blank" rel="external">Java优先队列（PriorityQueue）示例</a><br><a href="http://wlh0706-163-com.iteye.com/blog/1850125" target="_blank" rel="external">JDK源码研究PriorityQueue（优先队列）</a><br><a href="http://cuisuqiang.iteye.com/blog/2019157" target="_blank" rel="external">优先级队列：PriorityQueue</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="参考资料">参考资料</h3><p><a href="http://www.iteye.com/topic/1061958" target="_blank" rel="external">基于最小堆（小根堆）的topn算法</a><br><a href="http]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java TreeMap工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/06/Java-TreeMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/06/Java-TreeMap工作原理及实现/</id>
    <published>2015-04-06T15:10:15.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>A <strong>Red-Black tree</strong> based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.<br>This implementation provides guaranteed <strong>log(n) time cost</strong> for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest’s Introduction to Algorithms.</p>
</blockquote>
<p>之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Integer, String&gt; tmap = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">tmap.put(<span class="number">1</span>, <span class="string">"语文"</span>);</span><br><span class="line">tmap.put(<span class="number">3</span>, <span class="string">"英语"</span>);</span><br><span class="line">tmap.put(<span class="number">2</span>, <span class="string">"数学"</span>);</span><br><span class="line">tmap.put(<span class="number">4</span>, <span class="string">"政治"</span>);</span><br><span class="line">tmap.put(<span class="number">5</span>, <span class="string">"历史"</span>);</span><br><span class="line">tmap.put(<span class="number">6</span>, <span class="string">"地理"</span>);</span><br><span class="line">tmap.put(<span class="number">7</span>, <span class="string">"生物"</span>);</span><br><span class="line">tmap.put(<span class="number">8</span>, <span class="string">"化学"</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其大致的结构如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7041463/05ee676a-de0c-11e4-9412-4c6964931e43.png" alt="treemap"><br>使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考<a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="external">数据结构之红黑树</a>、<a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">wikipedia-红黑树</a>等的实现。</p>
<h3 id="2-_put函数">2. put函数</h3><blockquote>
<p>Associates the specified value with the specified key in this map.If the map previously contained a mapping for the key, the old value is replaced.</p>
</blockquote>
<p>如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; t = root;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">		compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">		root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">		size = <span class="number">1</span>;</span><br><span class="line">		modCount++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cmp;</span><br><span class="line">	Entry&lt;K,V&gt; parent;</span><br><span class="line">	<span class="comment">// split comparator and comparable paths</span></span><br><span class="line">	Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">        <span class="comment">// 如果该节点存在，则替换值直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">		do &#123;</span><br><span class="line">			parent = t;</span><br><span class="line">			cmp = cpr.compare(key, t.key);</span><br><span class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">				t = t.left;</span><br><span class="line">			<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(cmp &gt; <span class="number">0</span>)</span></span><br><span class="line">				t </span>= t.right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">		&#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">			Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">		do &#123;</span><br><span class="line">			parent = t;</span><br><span class="line">			cmp = k.compareTo(t.key);</span><br><span class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">				t = t.left;</span><br><span class="line">			<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(cmp &gt; <span class="number">0</span>)</span></span><br><span class="line">				t </span>= t.right;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> t.setValue(value);</span><br><span class="line">		&#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">// 如果该节点未存在，则新建</span></span><br><span class="line">	Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">		parent.left = e;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		parent.right = e;</span><br><span class="line">        <span class="comment">// 红黑树平衡调整</span></span><br><span class="line">	fixAfterInsertion(e);</span><br><span class="line">	size++;</span><br><span class="line">	modCount++;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-_get函数">3. get函数</h3><p>get函数则相对来说比较简单，以log(n)的复杂度进行get<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">	<span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">	<span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">	<span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">	Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="comment">// 按照二叉树搜索的方式进行搜索，搜到返回</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">		<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">			p = p.left;</span><br><span class="line">		<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(cmp &gt; <span class="number">0</span>)</span></span><br><span class="line">			p </span>= p.right;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">	<span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-_successor后继">4. successor后继</h3><p>TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.2" target="_blank" rel="external">The enhanced for statement</a>，for语句会做如下转换为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123;</span><br><span class="line">	Entry&lt;Integer, String&gt; entry = it.next();</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<strong>it.next()</strong>的调用中会使用<strong>nextEntry</strong>调用<code>successor</code>这个是过的后继的重点，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(t.right != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有右子树的节点，后继节点就是右子树的“最左节点”</span></span><br><span class="line">        <span class="comment">// 因为“最左子树”是右子树的最小节点</span></span><br><span class="line">		Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">		<span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">			p = p.left;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点</span></span><br><span class="line">        <span class="comment">// 因为左子树找完了，根据LDR该D了</span></span><br><span class="line">		Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">		Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="comment">// 保证左子树</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">			ch = p;</span><br><span class="line">			p = p.parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下：</p>
<blockquote>
<p><strong>a. 空节点，没有后继</strong><br><strong>b. 有右子树的节点，后继就是右子树的“最左节点”</strong><br><strong>c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点</strong></p>
</blockquote>
<p>a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了！</p>
<p><strong>有右子树的节点</strong>，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是<strong>右子树的“最左节点”</strong>，就好像下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/7045283/652d00c4-de2f-11e4-8475-1a2f46afc380.png" alt="treemap1"></p>
<p><strong>无右子树的节点</strong>，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。<br><img src="https://cloud.githubusercontent.com/assets/1736354/7045284/68279686-de2f-11e4-8310-c9f76b3f52ab.png" alt="treemap2"></p>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="external">TreeMap (Java Platform SE 8)</a><br><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="external">浅谈算法和数据结构: 九 平衡查找树之红黑树</a><br><a href="http://blog.csdn.net/chenssy/article/details/26668941" target="_blank" rel="external">Java提高篇（二七）——-TreeMap</a><br><a href="http://dongxicheng.org/structure/red-black-tree/" target="_blank" rel="external">数据结构之红黑树</a><br><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="external">wikipedia-红黑树</a><br><a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" target="_blank" rel="external">Red-Black Trees</a><br><a href="http://stackoverflow.com/questions/18063394/how-treemap-searches-successor-for-given-entry" target="_blank" rel="external">How TreeMap searches successor for given Entry?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>A <strong>Red-Black tree</strong> based NavigableMap implementation. The map is sorted according to]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java LinkedList工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/05/Java-LinkedList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/05/Java-LinkedList工作原理及实现/</id>
    <published>2015-04-05T14:19:28.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</p>
<p>按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。</p>
<p>插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。</p>
</blockquote>
<p>LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。</p>
<blockquote>
<p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 1"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 2"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 3"</span>);</span><br></pre></td></tr></table></figure>
<p>结构也相对简单一些，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6997435/92fab224-dbed-11e4-932a-4c5593a2abb7.png" alt="linkedlist"></p>
<h3 id="2-_set和get函数">2. set和get函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	checkElementIndex(index);</span><br><span class="line">	<span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数都调用了<code>node</code>函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="external">LinkedList (Java Platform SE 8)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><blockquote>
<p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</p>
<p>按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java ArrayList工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/04/Java-ArrayList%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/04/Java-ArrayList工作原理及实现/</id>
    <published>2015-04-04T13:22:27.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="external">关于Java集合的小抄</a>中是这样描述的：</p>
<blockquote>
<p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p>
<p>按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p>
<p>直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
</blockquote>
<p>然后再来学习一下官方文档：</p>
<blockquote>
<p><strong>Resizable-array</strong> implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p>
</blockquote>
<p>ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。<br>来看一段简单的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"语文: 99"</span>);</span><br><span class="line">list.add(<span class="string">"数学: 98"</span>);</span><br><span class="line">list.add(<span class="string">"英语: 100"</span>);</span><br><span class="line">list.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>在执行这四条语句时，是这么变化的：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6993037/5d4ba306-db19-11e4-85fb-61b0154d0d96.png" alt="arraylist"><br>其中，<code>add</code>操作可以理解为直接将数组的内容置位，<code>remove</code>操作可以理解为删除index为0的节点，并将后面元素移到0处。</p>
<h3 id="2-_add函数">2. add函数</h3><p>当我们在ArrayList中增加元素的时候，会使用<code>add</code>函数。他会将元素放到末尾。具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到他的实现其实最核心的内容就是<code>ensureCapacityInternal</code>。这个函数其实就是<strong>自动扩容机制的核心</strong>。我们依次来看一下他的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 扩展为原来的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果扩为1.5倍还不满足需求，直接扩为需求值</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们<code>add</code>10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6993129/e892246e-db1c-11e4-9ae8-f9719688a1ca.png" alt="arraylistadd"></p>
<h3 id="3_set和get函数">3 set和get函数</h3><p>Array的put和get函数就比较简单了，先做index检查，然后执行赋值或访问操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4_remove函数">4 remove函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 把后面的往前移</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 把最后的置null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释很清楚：</p>
<blockquote>
<p>Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).</p>
</blockquote>
<h3 id="参考资料">参考资料</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#add-E-" target="_blank" rel="external">Class ArrayList</a><br><a href="http://www.cnblogs.com/dongying/p/4013271.html" target="_blank" rel="external">ArrayList其实就那么一回事儿之源码浅析</a><br><a href="http://my.oschina.net/tunie/blog/122530" target="_blank" rel="external">关于ArrayList</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="external">关于Java集合的小抄</a>中是]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何设计实现一个LRU Cache？]]></title>
    <link href="http://yikun.github.io/2015/04/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/"/>
    <id>http://yikun.github.io/2015/04/03/如何设计实现一个LRU-Cache？/</id>
    <published>2015-04-03T15:35:02.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_什么是LRU_Cache？">1. 什么是LRU Cache？</h3><p>之前，在LeetCode上看到一个LRU Cache实现的题目，题目描述是这样的：</p>
<blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <strong>get</strong> and <strong>set</strong>.<br><strong>get(key)</strong> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br><strong>set(key, value)</strong> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
</blockquote>
<p>简单的说，就是保证基本的get和set的功能的同时，还要保证最近访问(get或put)的节点保持在限定容量的Cache中，如果超过容量则应该把LRU(近期最少使用)的节点删除掉。</p>
<p>那么我们思考一个问题：如何设计实现一个LRU Cache？<br>那么，我们可能需要使用类似这样的数据结构去实现这个LRU Cache：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6984935/92033a96-da60-11e4-8754-66135bb0d233.png" alt="lru"><br>这不就是LinkedHashMap吗！<br>这样做的好处是，<code>get</code>和<code>set</code>在不冲突的情况下可以保证O(1)的复杂度，同时，也可以通过双向链表来保证LRU的<code>删除</code>和<code>更新</code>操作也能保证O(1)的复杂度。</p>
<h3 id="2-实现思路">2.实现思路</h3><p>在学习了HashMap(#7 )和LinkedHashMap(#8 )后，是不是觉得这俩数据结构简直太适合做LRU Cache了！那么动手实现一下：<br><strong>基于HashMap和双向链表的实现</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    	Node pre;</span><br><span class="line">    	Node next;</span><br><span class="line">    	Integer key;</span><br><span class="line">    	Integer val;</span><br><span class="line">    	</span><br><span class="line">    	Node(Integer k, Integer v) &#123;</span><br><span class="line">    		key = k;</span><br><span class="line">    		val = v;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, Node&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Node&gt;();</span><br><span class="line">    <span class="comment">// The head (eldest) of the doubly linked list.</span></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="comment">// The tail (youngest) of the doubly linked list.</span></span><br><span class="line">    Node tail;</span><br><span class="line">    <span class="keyword">int</span> cap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        	n.pre.next = n.next;</span><br><span class="line">        	n.next.pre = n.pre;</span><br><span class="line">        	appendTail(n);</span><br><span class="line">        	<span class="keyword">return</span> n.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        <span class="comment">// existed</span></span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="keyword">null</span>) &#123;</span><br><span class="line">	        n.val = value;</span><br><span class="line">	        map.put(key, n);</span><br><span class="line">        	n.pre.next = n.next;</span><br><span class="line">        	n.next.pre = n.pre;</span><br><span class="line">        	appendTail(n);</span><br><span class="line">        	<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(map.size() == cap) &#123;</span><br><span class="line">        	Node tmp = head.next;</span><br><span class="line">        	head.next = head.next.next;</span><br><span class="line">        	head.next.pre = head;</span><br><span class="line">        	map.remove(tmp.key);</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="comment">// youngest node append taill</span></span><br><span class="line">        appendTail(n);</span><br><span class="line">        map.put(key, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">    	n.next = tail;</span><br><span class="line">    	n.pre = tail.pre;</span><br><span class="line">    	tail.pre.next = n;</span><br><span class="line">    	tail.pre = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>基于LinkedHashMap的实现</strong><br>HashMap+双向链表？这不就是LinkedHashMap吗！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> java.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 定义put后的移除规则，大于容量就删除eldest</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> size() &gt; capacity;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_什么是LRU_Cache？">1. 什么是LRU Cache？</h3><p>之前，在LeetCode上看到一个LRU Cache实现的题目，题目描述是这样的：</p>
<blockquote>
<p>Design and implement a data ]]>
    </summary>
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java LinkedHashMap工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/02/Java-LinkedHashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/02/Java-LinkedHashMap工作原理及实现/</id>
    <published>2015-04-02T15:01:37.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>在理解了#7 介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap&lt;String, Integer&gt; lmap = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</span><br><span class="line">lmap.put(<span class="string">"语文"</span>, <span class="number">1</span>);</span><br><span class="line">lmap.put(<span class="string">"数学"</span>, <span class="number">2</span>);</span><br><span class="line">lmap.put(<span class="string">"英语"</span>, <span class="number">3</span>);</span><br><span class="line">lmap.put(<span class="string">"历史"</span>, <span class="number">4</span>);</span><br><span class="line">lmap.put(<span class="string">"政治"</span>, <span class="number">5</span>);</span><br><span class="line">lmap.put(<span class="string">"地理"</span>, <span class="number">6</span>);</span><br><span class="line">lmap.put(<span class="string">"生物"</span>, <span class="number">7</span>);</span><br><span class="line">lmap.put(<span class="string">"化学"</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是：</p>
<blockquote>
<p>语文: 1<br>数学: 2<br>英语: 3<br>历史: 4<br>政治: 5<br>地理: 6<br>生物: 7<br>化学: 8</p>
</blockquote>
<p>我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6981649/03eb9014-da38-11e4-9cbf-03d9c21f05f2.png" alt="linkedhashmap"></p>
<p>没错，正如官方文档所说：</p>
<blockquote>
<p><strong>Hash table</strong> and <strong>linked list</strong> implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a <strong>doubly-linked list</strong> running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (<strong>insertion-order</strong>).</p>
</blockquote>
<p>LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。</p>
<h3 id="2-_三个重点实现的函数">2. 三个重点实现的函数</h3><p>在HashMap中提到了下面的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。</p>
<p><strong>afterNodeAccess函数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="comment">// 如果定义了accessOrder，那么就保证最近访问节点放到最后</span></span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。</p>
<p><strong>afterNodeInsertion函数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="comment">// 如果定义了移除规则，则执行相应的溢出</span></span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果用户定义了<code>removeEldestEntry</code>的规则，那么便可以执行相应的移除操作。</p>
<p><strong>afterNodeRemoval函数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></span><br><span class="line">    <span class="comment">// 从链表中移除节点</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数是在移除节点后调用的，就是将节点从双向链表中删除。</p>
<p>我们从上面3个函数看出来，基本上都是为了<strong>保证双向链表中的节点次序或者双向链表容量</strong>所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。</p>
<h3 id="3-_put和get函数">3. put和get函数</h3><p><code>put</code>函数在LinkedHashMap中未重新实现，只是实现了<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>两个回调函数。<code>get</code>函数则重新实现并加入了<code>afterNodeAccess</code>来保证访问顺序，下面是<code>get</code>函数的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生<code>structural modification</code>。官方文档是这么描述的：</p>
<blockquote>
<p>A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. <strong>In access-ordered linked hash maps, merely querying the map with get is a structural modification</strong>.</p>
</blockquote>
<p>不要犯了像<a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833" target="_blank" rel="external">ConcurrentModificationException with LinkedHashMap</a>类似的问题。</p>
<p>总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。:-)</p>
<h3 id="参考链接">参考链接</h3><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="external">Class LinkedHashMap</a><br><a href="http://stackoverflow.com/questions/16180568/concurrentmodificationexception-with-linkedhashmap/16180833" target="_blank" rel="external">ConcurrentModificationException with LinkedHashMap</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>在理解了#7 介绍的HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序：<br><figure class="highlight java]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java HashMap工作原理及实现]]></title>
    <link href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/</id>
    <published>2015-04-01T08:53:14.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>从本文你可以学习到：</p>
<blockquote>
<ol>
<li>什么时候会使用HashMap？他有什么特点？</li>
<li>你知道HashMap的工作原理吗？</li>
<li>你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</li>
<li>你知道hash的实现吗？为什么要这样实现？</li>
<li>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</li>
</ol>
</blockquote>
<p>当我们执行下面的操作时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">"语文"</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">"数学"</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">"英语"</span>, <span class="number">3</span>);</span><br><span class="line">map.put(<span class="string">"历史"</span>, <span class="number">4</span>);</span><br><span class="line">map.put(<span class="string">"政治"</span>, <span class="number">5</span>);</span><br><span class="line">map.put(<span class="string">"地理"</span>, <span class="number">6</span>);</span><br><span class="line">map.put(<span class="string">"生物"</span>, <span class="number">7</span>);</span><br><span class="line">map.put(<span class="string">"化学"</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">": "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是</p>
<blockquote>
<p>政治: 5<br>生物: 7<br>历史: 4<br>数学: 2<br>化学: 8<br>语文: 1<br>英语: 3<br>地理: 6</p>
</blockquote>
<p>发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957741/0c039b1c-d933-11e4-8c1e-7558a8766272.png" alt="hashmap"></p>
<p>在官方文档中是这样描述HashMap的：</p>
<blockquote>
<p>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is <strong>unsynchronized</strong> and <strong>permits nulls</strong>.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p>
</blockquote>
<p>几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p>
<h3 id="2-_两个重要的参数">2. 两个重要的参数</h3><p>在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor)</p>
<blockquote>
<ul>
<li><strong>Initial capacity</strong> The capacity is <strong>the number of buckets</strong> in the hash table, The initial capacity is simply the capacity at the time the hash table is created.</li>
<li><strong>Load factor</strong> The load factor is <strong>a measure of how full the hash table is allowed to get</strong> before its capacity is automatically increased.</li>
</ul>
</blockquote>
<p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话不要把<code>capacity</code>设置过大，也不要把<code>load factor</code>设置过小。当bucket中的entries的数目大于<code>capacity*load factor</code>时就需要调整bucket的大小为当前的2倍。</p>
<h3 id="3-_put函数的实现">3. put函数的实现</h3><p>put函数大致的思路为：</p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ol>
<p>具体代码的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span><br><span class="line">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算index，并对null做处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 节点存在</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 该链为树</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(p <span class="keyword">instanceof</span> TreeNode)</span></span><br><span class="line">            e </span>= ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写入</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过load factor*current capacity，resize</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-_get函数的实现">4. get函数的实现</h3><p>在理解了put之后，get就很简单了。大致思路如下：</p>
<ol>
<li>bucket里的第一个节点，直接命中；</li>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry<br>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ol>
<p>具体代码的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; getNode(<span class="keyword">int</span> hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 直接命中</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 未命中</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-_hash函数的实现">5. hash函数的实现</h3><p>在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6957712/293b52fc-d932-11e4-854d-cb47be67949a.png" alt="hash"></p>
<p>在对hashCode()计算hash时具体实现是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的：</p>
<blockquote>
<p>Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between <strong>speed, utility, and quality</strong> of bit-spreading. Because many common sets of hashes are already <strong>reasonably distributed</strong> (so don’t benefit from spreading), and because <strong>we use trees to handle large sets of collisions in bins</strong>, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p>
</blockquote>
<p>在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用<code>&amp;</code>位操作，而非<code>%</code>求余)：</p>
<pre><code><span class="list">(<span class="keyword">n</span> - <span class="number">1</span>)</span> &amp; hash
</code></pre><p>设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。</p>
<p>因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用<code>O(logn)</code>的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<p>如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在<a href="http://openjdk.java.net/jeps/180" target="_blank" rel="external">JEP-180</a>中，描述了这个问题：</p>
<blockquote>
<p>Improve the performance of java.util.HashMap under high hash-collision conditions by <strong>using balanced trees rather than linked lists to store map entries</strong>. Implement the same improvement in the LinkedHashMap class.</p>
</blockquote>
<p>之前已经提过，在获取HashMap的元素时，基本分两步：</p>
<ol>
<li>首先根据hashCode()做hash，然后确定bucket的index；</li>
<li>如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。</li>
</ol>
<p>在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。</p>
<p>因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在<a href="http://www.importnew.com/14417.html" target="_blank" rel="external">Java 8：HashMap的性能提升</a>一文中有性能测试的结果。</p>
<h4 id="6-_resize的实现">6. resize的实现</h4><p>当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的：</p>
<blockquote>
<p>Initializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either <strong>stay at same index</strong>, or <strong>move with a power of two offset</strong> in the new table.</p>
</blockquote>
<p>大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。</p>
<p>怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958256/ceb6e6ac-d93b-11e4-98e7-c5a5a07da8c4.png" alt="rehash"></p>
<p>因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958301/519be432-d93c-11e4-85bb-dff0a03af9d3.png" alt="resize"></p>
<p>因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图：<br><img src="https://cloud.githubusercontent.com/assets/1736354/6958677/d7acbad8-d941-11e4-9493-2c5e69d084c0.png" alt="resize16-32"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p>
<p>下面是代码的具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">((newCap = oldCap &lt;&lt; <span class="number">1</span>)</span> &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;</span>= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(oldThr &gt; <span class="number">0</span>)</span> <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap </span>= oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(e <span class="keyword">instanceof</span> TreeNode)</span></span><br><span class="line">                    <span class="params">((TreeNode&lt;K,V&gt;)</span>e).<span class="title">split</span><span class="params">(<span class="keyword">this</span>, newTab, j, oldCap)</span></span>;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-_总结">7. 总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p>
<p><strong>1. 什么时候会使用HashMap？他有什么特点？</strong><br>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
<p><strong>2. 你知道HashMap的工作原理吗？</strong><br>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
<p><strong>3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</strong><br>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
<p><strong>4. 你知道hash的实现吗？为什么要这样实现？</strong><br>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
<p><strong>5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong><br>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p>
<p><a href="http://calvin1978.blogcn.com/articles/collection.html" target="_blank" rel="external">关于Java集合的小抄</a>中是这样描述的：</p>
<blockquote>
<p>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。</p>
<p>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。</p>
<p>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。</p>
<p>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。</p>
<p>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。</p>
<p>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p>
<p>在JDK8里，新增默认为8的閥值，当一个桶里的Entry超过閥值，就不以单向链表而以红黑树来存放以加快Key的查找速度。</p>
</blockquote>
<h3 id="参考资料">参考资料</h3><p><a href="http://www.importnew.com/7099.html" target="_blank" rel="external">HashMap的工作原理</a><br><a href="http://www.importnew.com/14417.html" target="_blank" rel="external">Java 8：HashMap的性能提升</a><br><a href="http://openjdk.java.net/jeps/180" target="_blank" rel="external">JEP 180: Handle Frequent HashMap Collisions with Balanced Trees</a><br><a href="http://www.importnew.com/7166.html" target="_blank" rel="external">ConurrentHashMap和Hashtable的区别</a><br><a href="http://www.importnew.com/7010.html" target="_blank" rel="external">HashMap和Hashtable的区别</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>从本文你可以学习到：</p>
<blockquote>
<ol>
<li>什么时候会使用HashMap？他有什么特点？</li>
<li>你知道HashMap的工作原理吗？</li>
<li>你知道get和put的原理吗？e]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java集合框架]]></title>
    <link href="http://yikun.github.io/2015/03/31/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>http://yikun.github.io/2015/03/31/Java集合框架/</id>
    <published>2015-03-31T06:27:13.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="概述">概述</h3><h4 id="什么是集合？">什么是集合？</h4><p>这Java官方的<a href="https://docs.oracle.com/javase/tutorial/collections/intro/index.html" target="_blank" rel="external">入门文档</a>是这样描述集合的：</p>
<blockquote>
<p>Collection(有时候也叫container)是一个简单的对象，它把多个元素组织成一个单元。集合可以用来存储、检索、操作、通信。通常情况下，集合代表了一个自然数据项，比如一组手牌(牌的集合)、邮件文件夹(邮件的集合)、电话目录(姓名到电话的映射)。如果你使用过Java或者其他语言，你应该很熟悉集合。</p>
</blockquote>
<h4 id="什么是集合框架？">什么是集合框架？</h4><blockquote>
<p>Collections Framework是一个用来表示和操作集合的统一的架构。集合的框架包括了：</p>
<ul>
<li><strong>Interfaces:</strong><br>这些是表示集合的抽象数据类型，接口允许集合完成操作，独立与其详细的实现。在面向对象的语言中，接口构成了体系架构；</li>
<li><strong>Implementations:</strong><br>这些是接口的具体实现。本质上，是一些可复用的数据结构；</li>
<li><strong>Algorithms:</strong><br>这些方法可以对接口实现的对象进行有用的计算，比如搜索、排序。这些算法是具有多态性的：也就是说，同样的方法可以用在合适的接口的不同实现。本质上，是一些可复用的函数。</li>
</ul>
<p>除了Java的集合框架，还有一些著名的集合框架的例子：比如C++的STL和Smalltalk的集合架构。从历史上来看，集合框架可能比较复杂，也可能有一些很陡峭的学习曲线。不过我们相信Java的集合框架会突破这样的传统，在这章你就可以自己学会。</p>
</blockquote>
<h4 id="使用集合框架有什么好处？">使用集合框架有什么好处？</h4><blockquote>
<p>Java的集合框架提供了一下优点：</p>
<ul>
<li><strong>减少编程的工作量</strong>：通过提供有用的数据结构和算法，集合框架能让你更专注的实现程序的核心功能，而不是去做一个底层的“管道工”。Java框架通过促进无关API的互操作性，使得你不用自己去实现不同API的适配</li>
<li><strong>提高程序的速度与质量</strong>：集合框架提供了一些有用数据结构和算法的高性能、高质量的实现。每个接口的不同的实现也是可以互换的，所以程序可以通过切换集合来做一些调整。正因为你从实现数据结构的那些苦差事中脱离出来，你才可以有更多的实现去改善你自己程序的性能和质量</li>
<li><strong>允许无关APIs的互操作</strong>：集合接口是API之间传递集合的一个“方言”，比如我的网络管理API有一个节点名的集合，而GUI工具需要一个列标题的集合，即使是分开实现它们，我们的APIs也可以无缝的接合。</li>
<li><strong>省力地学习和使用新API</strong>：<br>这是另一个领先的优势，设计者和实现者没必要在每次都重新设计API的时候都“推倒重来”地实现集合，而是直接使用标准的集合接口就好了。</li>
<li><strong>促进软件的复用</strong>：符合标准集合接口的新数据结构本质上是可以复用的。对于操作这些新数据结构算法也是一样可以复用的。</li>
</ul>
</blockquote>
<p>因此，后面也便从接口、实现、算法几方面结合着代码和官方的文档学习总结一下。</p>
<h3 id="接口">接口</h3><p><img src="https://cloud.githubusercontent.com/assets/1736354/6912860/5a9ea472-d7aa-11e4-9002-8e2c90d0ca58.png" alt="java interface"><br>在Java中所有的核心集合接口都是generic的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说在声明一个Collection的时候，应该指定一种类型。官方是这样解释原因的：</p>
<blockquote>
<p>Specifying the type allows the compiler to verify (at compile-time) that the type of object you put into the collection is correct, thus reducing errors at runtime.</p>
</blockquote>
<p>下面就来介绍一下几种接口：</p>
<ul>
<li><strong>Collection</strong>： 集合层次中的根。一个集合表示一组对象。有些有序，有些无序。有些重复，有些重复。Collection没有直接的实现，而只有它的子接口的对应的实现。</li>
<li><strong>Set</strong>：<strong>不能包含重复的元素</strong>，比如扑克手牌、学生选课计划、计算机的进程。</li>
<li><strong>List</strong>：有序的集合，也可以包含重复的元素。用于对每个元素精确的控制，比如插入、用index来索引。</li>
<li><strong>Queue</strong>：用于多元素有优先级的处理，可以用做FIFO</li>
<li><strong>Deque</strong>：用于多元素有优先级的处理，double ended queue，可以用作FIFO，LIFO</li>
<li><strong>Map</strong>：用于keys到values的映射，不能包含重复元素<br>另外还提供了2个带排序的Set和Map。</li>
<li><strong>SortedSet</strong>：<strong>元素升序</strong></li>
<li><strong>SortedMap</strong>：<strong>key升序</strong></li>
</ul>
<p>在1.6版本开始，还有两种新的接口<strong>NavigableSet</strong>、<strong>NavigableMap</strong>。</p>
<blockquote>
<p>A SortedMap/SortedSet extended with navigation methods reporting closest matches for given search targets.</p>
</blockquote>
<p>提供诸如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回第一个大于e的元素</span></span><br><span class="line"><span class="function">E <span class="title">higher</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>之类的“导航性质”的便捷操作。</p>
<p>以上便是Java集合框架与接口的相关内容。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="概述">概述</h3><h4 id="什么是集合？">什么是集合？</h4><p>这Java官方的<a href="https://docs.oracle.com/javase/tutorial/collections/intro/index.html" targ]]>
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[定时器管理实现与初探]]></title>
    <link href="http://yikun.github.io/2015/03/08/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%AE%A1%E7%90%86%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%9D%E6%8E%A2/"/>
    <id>http://yikun.github.io/2015/03/08/定时器管理实现与初探/</id>
    <published>2015-03-08T05:52:10.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_背景">1. 背景</h3><p>最近需要实现一个简单的定时器管理，背景是硬件只有一个定时中断器，每100ms给一个时钟中断，我们需要利用它及相关代码实现整个协议中的定时器管理。然后大概看了看Linux的定时器、Nginx的定时器、Tegine的定时器，把一些思路和收获记一下。</p>
<h3 id="2-_思路">2. 思路</h3><p>思路本身很简单，用硬件时钟计数，每次检查，有定时器该执行就调用就行了。</p>
<p>具体的来说就是</p>
<ol>
<li><strong>记录滴答数jiffies</strong>。用于记录当前时间；</li>
<li><strong>加入定时器事件</strong>。用户需要启动一个定时器时，我们将该定时器事件(触发时间timeout、回调函数timeout_handler)加入到某种数据结构中;</li>
<li><strong>检查执行事件</strong>。每次更新当前滴答数N时，去检查这个定时器结构中的每个定时器事件是否应该溢出，如果定时器没到，就啥也不做，时间到了的话(timeout&lt;=jiffies)就触发该定时器事件F。本步大致的代码逻辑是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (jiffies &lt; timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we did not timed out, do noting</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we timed out</span></span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-_问题">3. 问题</h3><h4 id="1_关于滴答数溢出的问题">1 关于滴答数溢出的问题</h4><p>首先，遇到的第一个问题就是滴答数溢出的问题，在无符号数到达最大值时，会从0开始重新累加。</p>
<p>例如，我们用<code>unsigned char</code>计数，那么滴答数会从<code>0(0x00)-&gt;1(0x01)-&gt;....-&gt;254(0xFE)-&gt;255(0xFF)-&gt;0(0x00)-&gt;1(0x01)-&gt;...</code>如此循环计数。<br>那么问题出现了，在254时刻出现了一个A事件(+4后执行)，即时间溢出为0x02，那么如果我们做判定时，很显然，在254滴答的时候就把2滴答(实际上我们指的是254+4=258)的事件执行了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">254</span> &lt; <span class="number">2</span>) <span class="comment">//false</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// but</span></span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实问题的根本原因是<strong>事件发生滴答和当前时间滴答使用的不是一个参考系</strong>。然而在Linux代码实现中，利用<strong>无符号转有符号</strong>的巧妙方式解决了上面那个问题，<a href="https://github.com/torvalds/linux/blob/4f671fe2f9523a1ea206f63fe60a7c7b3a56d5c7/include/linux/jiffies.h#L101" target="_blank" rel="external">linux/include/linux/jiffies.h</a>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time_after(a,b) returns true if the time a is after time b.</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> time_after(a,b)		\</span><br><span class="line">	(typecheck(unsigned long, a) &amp;&amp; \</span><br><span class="line">	 typecheck(unsigned long, b) &amp;&amp; \</span><br><span class="line">	 ((long)(b) - (long)(a) &lt; 0))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> time_before(a,b)	time_after(b,a)</span></span><br></pre></td></tr></table></figure></p>
<p>用了这个宏以后，巧妙的一幕发生了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">char</span>(<span class="number">254</span>) &lt; <span class="keyword">char</span>(<span class="number">1</span>)) <span class="comment">//true =&gt; -2 &lt; -1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后呢，在Linux 3.12的一个<a href="https://github.com/torvalds/linux/commit/5a581b367b5df0531265311fc681c2abd377e5e6#diff-2610861e923003988c4c2aa213affc7d" target="_blank" rel="external">patch</a>中，又修改了下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> time_after(a,b)		\</span><br><span class="line">	(typecheck(unsigned long, a) &amp;&amp; \</span><br><span class="line">	 typecheck(unsigned long, b) &amp;&amp; \</span><br><span class="line">	 ((long)((b) - (a)) &lt; 0))</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> time_before(a,b)	time_after(b,a)</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">According to the C standard 3.4.3p3, overflow of a signed integer results</span><br><span class="line">in undefined behavior.  This commit therefore changes the definitions</span><br><span class="line">of time_after(), time_after_eq(), time_after64(), and time_after_eq64()</span><br><span class="line">to avoid this undefined behavior.  The trick is that the subtraction</span><br><span class="line">is done using unsigned arithmetic, which according to 6.2.5p9 cannot</span><br><span class="line">overflow because it is defined as modulo arithmetic.  This has the added</span><br><span class="line">(though admittedly quite small) benefit of shortening four lines of code</span><br><span class="line">by four characters each.</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure></p>
<p>大致意思就是C语言标准里面，有符号整型的溢出在C语言的标准中是未定义的blabla但是减法不会溢出，所以我这个改法是正确的blabla。哦对了，于是，我们对比时间代码编程了下面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(time_before(jiffies, timeout))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// we suppose</span></span><br><span class="line">    nothing();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    timeout_handler();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的<a href="https://github.com/alibaba/tengine/blob/master/src/event/ngx_event_timer.c#L98" target="_blank" rel="external">Tegine/Nginx</a>也是使用的类似的实现方法，而且有趣的是nginx也出现过类似的<a href="https://github.com/alibaba/tengine/commit/246f4133f6a1048dce36d3e55a5c748228288da1#diff-646868bfaeca38df552b086ec7cbf4e0L70" target="_blank" rel="external">patch</a>。</p>
<h4 id="2_关于定时器存储结构的问题">2 关于定时器存储结构的问题</h4><p>因为我们的定时器个数比较少，所以用有序链表(按照expire时间)就差不多了。插入、删除都是O(n)，查找O(1)；</p>
<p>在Linux使用的是双向链表实现的；</p>
<p>在Nginx的实现中，则使用的是红黑树，类似的每次都要log(n)去查找最小节点；</p>
<p><a href="tengine.taobao.org/download/programmer-201209-Tengine.pdf">据说</a>Tengine要使用四叉最小堆(4-heap)去改进，在查找的时候能O(1)，其他操作可以O(log(n))，不过我看<a href="https://github.com/alibaba/tengine/blob/tengine-2.1.0/src/event/ngx_event_timer.c" target="_blank" rel="external">tengine -2.1.0</a>的代码中，还是用的红黑树实现的。</p>
<h3 id="参考资料">参考资料</h3><p><a href="http://stackoverflow.com/questions/8206762/how-does-linux-handle-overflow-in-jiffies" target="_blank" rel="external">How does linux handle overflow in jiffies?</a><br><a href="http://blog.chinaunix.net/uid-23215128-id-2521293.html" target="_blank" rel="external">jiffies溢出与时间先后比较</a><br><a href="http://blog.csdn.net/mrpre/article/details/27890415" target="_blank" rel="external">linux内核计算时间差以及jiffies溢出</a><br><a href="http://www.cnblogs.com/xiaohuo/archive/2012/06/19/2555056.html" target="_blank" rel="external">nginx学习 - timer</a><br><a href="tengine.taobao.org/download/programmer-201209-Tengine.pdf">淘宝 Tengine易运维的高性能Nginx服务器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_背景">1. 背景</h3><p>最近需要实现一个简单的定时器管理，背景是硬件只有一个定时中断器，每100ms给一个时钟中断，我们需要利用它及相关代码实现整个协议中的定时器管理。然后大概看了看Linux的定时器、Nginx的定时器、Tegine的定时器，把一]]>
    </summary>
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
      <category term="系统" scheme="http://yikun.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自增运算符的反汇编]]></title>
    <link href="http://yikun.github.io/2015/02/08/%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://yikun.github.io/2015/02/08/自增运算符的反汇编/</id>
    <published>2015-02-08T11:19:11.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="i++">i++</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j = i++;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov         eax,dword ptr [i]  &#10;mov         dword ptr [j],eax  ;&#23558;i&#20540;&#36171;&#20540;&#32473;j&#10;mov         ecx,dword ptr [i]  &#10;add         ecx,1                    &#10;mov         dword ptr [i],ecx  ;i&#33258;&#22686;</span><br></pre></td></tr></table></figure>
<h3 id="++i">++i</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j = ++i;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov         eax,dword ptr [i]  &#10;add         eax,1  &#10;mov         dword ptr [i],eax ;i&#33258;&#22686; &#10;mov         ecx,dword ptr [i]  &#10;mov         dword ptr [j],ecx  ;&#23558;&#33258;&#22686;&#21518;i&#20540;&#32473;j</span><br></pre></td></tr></table></figure>
<p>很清晰了。: )</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="i++">i++</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</spa]]>
    </summary>
    
      <category term="C/C++" scheme="http://yikun.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建Git服务器]]></title>
    <link href="http://yikun.github.io/2015/02/05/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yikun.github.io/2015/02/05/搭建Git服务器/</id>
    <published>2015-02-05T05:11:46.000Z</published>
    <updated>2016-06-29T15:47:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在服务器上安装git">在服务器上安装git</h1><h3 id="1-_安装git">1. 安装git</h3><p>sudo apt-get install git</p>
<h3 id="2-_增加git用户">2. 增加git用户</h3><p>sudo adduser git</p>
<h3 id="3-_将用户的公钥添加">3. 将用户的公钥添加</h3><p>cat id_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys</p>
<h3 id="4-_新建一个库">4. 新建一个库</h3><p>sudo git init —bare sample.git<br>sudo chown -R git:git sample.git</p>
<h3 id="5-_禁止git登陆">5. 禁止git登陆</h3><p>vim /etc/passwd<br>把<code>git:X:1001:1001:,,,:/home/git:/bin/bash</code>换为下面的<br>git:X:1001:1001:,,,:/home/git:/usr/bin/git-shell</p>
<p>git clone git@server:/srv/sample.git</p>
<h1 id="在客户端上安装git">在客户端上安装git</h1><h3 id="1-_在windows下安装git">1. 在windows下安装git</h3><p><a href="http://www.git-scm.com/downloads" target="_blank" rel="external">下载地址</a></p>
<h3 id="2-_安装可视化界面(可选)">2. 安装可视化界面(可选)</h3><p><a href="https://code.google.com/p/tortoisegit/wiki/Download?tm=2" target="_blank" rel="external">下载地址</a><br>鼠标邮件，选择“TortoiseGit”-&gt;“Settings”，在“User Info”输入Name和Email</p>
<h3 id="3-_生成公钥">3. 生成公钥</h3><p>在命令行和tortoisegit中稍有不同：<br><strong>In shell</strong><br>a. win+r —&gt; Git Bash —&gt;  ssh-keygen.exe<br>b. 一路回车，将生成“c:/Users/XXX/.ssh/id_rsa.pub”<br>c. (公钥)把id_rsa.pub重命名为id_rsa.XXX.pub, 例如id_rsa.jiangyikun.pub<br>d. (私钥)也已经生成到<code>c:/Users/XXX/.ssh/id_rsa</code>了<br>e. 将id_rsa.XXX.pub发送给git管理员</p>
<p><strong>In tortoisegit</strong><br>a. 打开Puttygen，SSH-2 RSA，点击Generate<br>b. 使用鼠标生成随机key<br>c. (公钥)复制Key到id_rsa.XXX.pub<br>d. (私钥)Save private key为XXX.ppk，并将Load Putty Key设为XXX.ppk<br>e. 将id_rsa.XXX.pub发送给git管理员</p>
<h3 id="(git管理员操作)_4-添加公钥的服务器">(git管理员操作) 4.添加公钥的服务器</h3><p>以root权限登陆， 注意是“&gt;&gt;”追加<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.XXX.pub &#62;&#62; /home/git/.ssh/authorized_keys&#10;# drwx------. 2 git  git  4096 Apr 15 13:17 .ssh&#10;# -rw-------. 1 git git 1189 Apr 15 13:17 authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>在客户端测试：ssh git@XXX.XXX.XXX.XXX，不再输入密码即可。</p>
<h3 id="5-_简单学习">5. 简单学习</h3><p>这是一个用于测试的repo你可以拿他来做做测试</p>
<p>a. 克隆仓库<br>git clone git@xxx.xxx.xxx.xxx:/yikun/sample.git<br>或者使用tortoisegit，在某个文件夹，右键—&gt;Git Clone…—&gt; URL填写“git@xxx.xxx.xxx.xxx:/yikun/sample.git”—&gt; 输入密码</p>
<p>b. 修改文件并提交</p>
<ol>
<li>在sample目录下简历一个文件比如，XXX.txt</li>
<li>右键 Git Commit -&gt; “Master”</li>
<li>填写Commit Message，并选择需要提交的文件，双击可以可视化的查看diff</li>
</ol>
<p>c. 点击push， ok</p>
<h3 id="6-_学习git">6. 学习git</h3><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></p>
<p>Enjoy it! :)</p>
<h3 id="附：">附：</h3><h4 id="1-_如何将一个现有的本地git库上传到服务器上？">1. 如何将一个现有的本地git库上传到服务器上？</h4><p>从现有repo新建server repo的时候(服务器)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir newrepo.git&#10;cd newrepo.git&#10;git --bare init&#10;# Initialized empty Git repository in /yikun/newrepo.git/.git/</span><br></pre></td></tr></table></figure>
<p>在现有的repo中（客户端）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd newrepo.git  &#10;git remote add origin git@xxx.xxx.xxx.xxx:/yikun/newrepo.git&#10;git push origin master</span><br></pre></td></tr></table></figure></p>
<h4 id="2-_如何克隆服务器上现有库？">2. 如何克隆服务器上现有库？</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#20174;&#26381;&#21153;&#22120;&#20811;&#38534;&#10;git clone git@xxx.xxx.xxx.xxx:/yikun/newrepo.git&#10;# &#20462;&#25913;&#24182;&#26412;&#22320;&#25552;&#20132;&#10;git commit -am &#34;commitmessage&#34;&#10;# &#19978;&#20256;&#33267;&#26381;&#21153;&#22120;&#10;git push origin master</span><br></pre></td></tr></table></figure>
<h4 id="3-_常见问题">3. 常见问题</h4><p>1 <strong>权限问题</strong></p>
<pre><code>Counting objects: <span class="number">179</span>, done.
Delta compression using up <span class="keyword">to</span> <span class="number">4</span> threads.
Compressing objects: <span class="number">100</span>% (<span class="number">176</span>/<span class="number">176</span>), done.
fatal: Unable <span class="keyword">to</span> create temporary <span class="type">file</span>: Permission denied
fatal: sha1 <span class="type">file</span> '&lt;stdout&gt;' <span class="command">write</span> <span class="keyword">error</span>: Broken pipe
<span class="keyword">error</span>: failed <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> 'git@xxx.xxx.xxx.xxx:/yikun/newrepo.git'
git did <span class="keyword">not</span> <span class="keyword">exit</span> cleanly (<span class="keyword">exit</span> code <span class="number">1</span>) (<span class="number">3261</span> ms @ <span class="number">2015</span>/<span class="number">2</span>/<span class="number">5</span> <span class="number">11</span>:<span class="number">17</span>:<span class="number">39</span>)
</code></pre><p>可以试试：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R git *&#10;chgrp -R git *&#10;```    &#10;&#10;2 **&#25552;&#20132;&#38382;&#39064;**&#10;&#10;    error: refusing to update checked out branch: refs/heads/master&#10;    error: By default, updating the current branch in a non-bare repository&#10;    error: is denied, because it will make the index and work tree inconsistent&#10;    error: with what you pushed, and will require &#39;git reset --hard&#39; to match&#10;    error: the work tree to HEAD.&#10;    error: &#10;    error: You can set &#39;receive.denyCurrentBranch&#39; configuration variable to&#10;    error: &#39;ignore&#39; or &#39;warn&#39; in the remote repository to allow pushing into&#10;    error: its current branch; however, this is not recommended unless you&#10;    error: arranged to update its work tree to match what you pushed in some&#10;    error: other way.&#10;    error: &#10;    error: To squelch this message and still keep the default behaviour, set&#10;    error: &#39;receive.denyCurrentBranch&#39; configuration variable to &#39;refuse&#39;.&#10;    &#10;&#21487;&#20197;&#35797;&#35797;&#65306;&#10;&#10;```shell&#10;git config &#39;receive.denyCurrentBranch&#39; warn</span><br></pre></td></tr></table></figure></p>
<h3 id="参考">参考</h3><p><a href="http://blog.163.com/clevertanglei900@126/blog/static/111352259201011655837986/" target="_blank" rel="external">小组级git服务器搭建</a><br><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="external">搭建Git服务器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在服务器上安装git">在服务器上安装git</h1><h3 id="1-_安装git">1. 安装git</h3><p>sudo apt-get install git</p>
<h3 id="2-_增加git用户">2. 增加git用户</h3><p>sudo]]>
    </summary>
    
      <category term="Git" scheme="http://yikun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <link href="http://yikun.github.io/2014/11/20/algorithm_sort/"/>
    <id>http://yikun.github.io/2014/11/20/algorithm_sort/</id>
    <published>2014-11-19T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="1-_排序算法汇总">1. 排序算法汇总</h3><h3 id="1-_概述">1. 概述</h3><table>
<thead>
<tr>
<th>算法名称</th>
<th>复杂度</th>
<th>实现关键</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>（有序区，无序区）。在无序区里选择一个最小的元素跟在有序区的后面。</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。</td>
</tr>
<tr>
<td>希尔排序</td>
<td>nlog^2(n)</td>
<td>每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1(插入)。</td>
</tr>
<tr>
<td>快速排序</td>
<td>nlog(n)</td>
<td>（小数，枢纽元，大数）。</td>
</tr>
<tr>
<td>堆排序</td>
<td>nlog(n)</td>
<td></td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n)</td>
<td>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</td>
</tr>
</tbody>
</table>
<p>不稳定的排序：<br>稳定性一个形象的比喻，本来有两个并列第三，一排序把原来并列的顺序给变了。<br>比如：选择排序、快速排序、堆排序、希尔排序；<br><a href="http://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">参考链接</a><br><!--more--></p>
<h3 id="2-_冒泡排序">2. 冒泡排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Bubble_sort_animation.gif" alt=""></p>
<p>每次都把未排序的第一个作为起始点，然后逐渐冒泡上升，之后未排序区越来越少，最终排序完成</p>
<p><img src="http://yikun.github.io/assets/post/algorithm/sort/bubble_sort.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n-<span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 比较相邻元素，若a[j]比a[j+1]大，则交换</span></span><br><span class="line">		<span class="comment">// a[j]就像一个气泡一样“浮”到合适位置了</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n-<span class="number">1</span>-i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-_选择排序">3. 选择排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Selection_sort_animation.gif" alt=""></p>
<p>每一趟从待排序的数据元素中<strong>选出最小（或最大）的一个元素</strong>，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</p>
<p><img src="http://yikun.github.io/assets/post/algorithm/sort/select_sort.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,min=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		min = i;</span><br><span class="line">		<span class="comment">// 找到最小值</span></span><br><span class="line">		<span class="keyword">for</span> (j=i+<span class="number">1</span>; j &lt;= n-<span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[min] &gt; a[j])</span><br><span class="line">				min = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(min != i)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;a[min], &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_插入排序">4. 插入排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/Insertion_sort_animation.gif" alt=""></p>
<p>每次排序从未排序区取一个“牌”，然后往前插入(包括了两步：大的往后移，把牌放到合适位置)。<br><img src="http://yikun.github.io/assets/post/algorithm/sort/Insert-sort-animation.gif" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 取牌</span></span><br><span class="line">		tmp = a[i];</span><br><span class="line">		<span class="comment">// 往前插的起始位置</span></span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 大的a[j]都放后面，寻找出j</span></span><br><span class="line">		<span class="keyword">while</span> ((j &gt;= <span class="number">0</span>) &amp;&amp; a[j] &gt; tmp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 往后放一个</span></span><br><span class="line">			a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 放到该放的位置</span></span><br><span class="line">		a[j+<span class="number">1</span>]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有种思路，把数据后移的过程换成交换的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，选中的牌冒泡向前插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort_2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//通过i选牌</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 冒泡向前插入(i-1 --&gt; 0)</span></span><br><span class="line">		<span class="keyword">for</span> (j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span> &amp;&amp; a[j] &gt; a[j + <span class="number">1</span>]; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(&amp;a[j], &amp;a[j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	print_a(a, n);</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<h3 id="5-_希尔排序">5. 希尔排序</h3><p>对插入排序再加一个步长的循环就是希尔排序了，例如<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">13</span> <span class="number">14</span> <span class="number">94</span> <span class="number">33</span> <span class="number">82</span> <span class="number">25</span> <span class="number">59</span> <span class="number">94</span> <span class="number">65</span> <span class="number">23</span> <span class="number">45</span> <span class="number">27</span> <span class="number">73</span> <span class="number">25</span> <span class="number">39</span> <span class="number">10</span> ]</span><br></pre></td></tr></table></figure></p>
<p>按照5步长排序，则相当于按列先进行排序(实际是通过下标实现的)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>排序后结果为<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure></p>
<p>多次循环后，只需要<strong>最终步长为1</strong>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> gap=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (gap &lt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">		gap = gap*<span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (gap &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 取牌</span></span><br><span class="line">		<span class="keyword">for</span> (i = gap; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 冒泡向前插入(i-gap : gap : 0), 保证每列ok</span></span><br><span class="line">			<span class="keyword">for</span> (j = i - gap; (j &gt;= <span class="number">0</span>) &amp;&amp; (a[j] &gt; a[j + gap]); j = j - gap)</span><br><span class="line">			&#123;</span><br><span class="line">				swap(&amp;a[j], &amp;a[j+gap]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		gap = (gap-<span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-_快速排序">6. 快速排序</h3><p><img src="http://yikun.github.io/assets/post/algorithm/sort/quicksort.gif" alt=""><br>每次迭代都选出一个基准，左边放小的，右边放大的，最终迭代完成。</p>
<p><img src="http://yikun.github.io/assets/post/algorithm/sort/quick_sort.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序分区</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">// x为基准</span></span><br><span class="line">	x = a[r];</span><br><span class="line">	<span class="comment">// i为界限,发现小于x的，就i++，再放到i处</span></span><br><span class="line">	i = p-<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (j=p; j&lt;= r-<span class="number">1</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[j]&lt;=x)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">			swap(&amp;a[i], &amp;a[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 至此，所有小于x的都到i左边了(a[0]~a[i-1])，a[r]是x，因此交换a[i+1]和a[r]</span></span><br><span class="line">	swap(&amp;a[i+<span class="number">1</span>], &amp;a[r]);</span><br><span class="line">	<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (p &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 在数据集之中，选择一个元素作为"基准"（pivot）</span></span><br><span class="line">		<span class="comment">// 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边</span></span><br><span class="line">		q = partition(a, p, r);</span><br><span class="line">		<span class="comment">// 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</span></span><br><span class="line">		quick_sort(a, p, q-<span class="number">1</span>);</span><br><span class="line">		quick_sort(a, q+<span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<h3 id="1-_排序算法汇总">1. 排序算法汇总</h3><h3 id="1-_概述">1. 概述</h3><table>
<thead>
<tr>
<th>算法名称</th>
<th>复杂度</th>
<th>实现关键</th>
</]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx的连接池]]></title>
    <link href="http://yikun.github.io/2014/04/17/nginxconnections/"/>
    <id>http://yikun.github.io/2014/04/17/nginxconnections/</id>
    <published>2014-04-16T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近，有些忙，没看nginx代码，前几天去阿里实习面试了，结果还不错。:)让我激动的是二面面试我的居然是褚霸！面完了以后，还和他握了手。简直是激动得不能再激动啦。面试的时候也有很大收获，至少知道自己的路是对的，也应该加强自己后台开发的相关项目经历。加油吧！</p>
<a id="more"></a>
<h3 id="1-_连接池的初始化">1. 连接池的初始化</h3><p>首先，初始化连接池，</p>
<pre><code>cycle<span class="subst">-&gt;</span>connections <span class="subst">=</span>
    ngx_alloc(sizeof(ngx_connection_t) <span class="subst">*</span> cycle<span class="subst">-&gt;</span>connection_n, cycle<span class="subst">-&gt;</span><span class="keyword">log</span>);
<span class="keyword">if</span> (cycle<span class="subst">-&gt;</span>connections <span class="subst">==</span> <span class="built_in">NULL</span>) {
    <span class="keyword">return</span> NGX_ERROR;
}
</code></pre><p>我们可以看到cycle-&gt;connections被分配了一个足够的空间。</p>
<pre><code>i = cycle-&gt;connection_n;
<span class="keyword">next</span> = <span class="constant">NULL;</span>

<span class="keyword">do</span> {
    i--;

    c[i].data = <span class="keyword">next</span>;
    c[i].read = &amp;cycle-&gt;read_events[i];
    c[i].write = &amp;cycle-&gt;write_events[i];
    c[i].fd = (ngx_socket_t) -<span class="number">1</span>;

    <span class="keyword">next</span> = &amp;c[i];
} <span class="keyword">while</span> (i);

cycle-&gt;free_connections = <span class="keyword">next</span>;
cycle-&gt;free_connection_n = cycle-&gt;connection_n;
</code></pre><p>初始化完成后，连接池的样子就想一个前一个元素的一个数组。最后，free_connection指向第一个元素。我们可以看下<br>我们可以看下，初始化后连接池情况：</p>
<p><img src="/assets/post/2014-04-17-nginxconnections/connections_init.png" alt="connections_init"></p>
<p>现在的结果就是，沿着free—&gt;connection—&gt;connection就连成了一串，然后get的时候直接把free_connection拿出来就可以了，然后free_connection指向原来的那个next。</p>
<h3 id="2-_连接的获取">2. 连接的获取</h3><pre><code>ngx_connection_t *
ngx_get_connection(ngx_socket_t s, ngx_log_t *log)
{
    ngx_uint_t         instance;
    ngx_event_t       *rev, *wev;
    ngx_connection_t  *c;

    <span class="comment">/* disable warning: Win32 SOCKET is u_int while UNIX socket is int */</span>

    <span class="keyword">if</span> (ngx_cycle-&gt;files &amp;&amp; (ngx_uint_t) s &gt;= ngx_cycle-&gt;files_n) {
        ngx_log_error(NGX_LOG_ALERT, log, <span class="number">0</span>,
                      <span class="string">"the new socket has number %d, "</span>
                      <span class="string">"but only %ui files are available"</span>,
                      s, ngx_cycle-&gt;files_n);
        <span class="keyword">return</span> <span class="keyword">NULL</span>;
    }

    <span class="comment">/* ngx_mutex_lock */</span>

    <span class="comment">//把free_connections给c，最后会返回c</span>
    c = ngx_cycle-&gt;free_connections;

    <span class="comment">//连接池不够了</span>
    <span class="keyword">if</span> (c == <span class="keyword">NULL</span>) {
        ngx_drain_connections();
        c = ngx_cycle-&gt;free_connections;
    }

    <span class="keyword">if</span> (c == <span class="keyword">NULL</span>) {
        ngx_log_error(NGX_LOG_ALERT, log, <span class="number">0</span>,
                      <span class="string">"%ui worker_connections are not enough"</span>,
                      ngx_cycle-&gt;connection_n);

        <span class="comment">/* ngx_mutex_unlock */</span>

        <span class="keyword">return</span> <span class="keyword">NULL</span>;
    }
    <span class="comment">// free_connections指向下一个可用连接</span>
    ngx_cycle-&gt;free_connections = c-&gt;data;
    ngx_cycle-&gt;free_connection_n--;

    <span class="comment">/* ngx_mutex_unlock */</span>

    <span class="keyword">if</span> (ngx_cycle-&gt;files) {
        ngx_cycle-&gt;files[s] = c;
    }

    rev = c-&gt;read;
    wev = c-&gt;write;

    ngx_memzero(c, sizeof(ngx_connection_t));

    c-&gt;read = rev;
    c-&gt;write = wev;
    c-&gt;fd = s;
    c-&gt;log = log;

    instance = rev-&gt;instance;

    ngx_memzero(rev, sizeof(ngx_event_t));
    ngx_memzero(wev, sizeof(ngx_event_t));

    rev-&gt;instance = !instance;
    wev-&gt;instance = !instance;

    rev-&gt;index = NGX_INVALID_INDEX;
    wev-&gt;index = NGX_INVALID_INDEX;

    rev-&gt;data = c;
    wev-&gt;data = c;

    wev-&gt;write = <span class="number">1</span>;

    <span class="keyword">return</span> c;
}
</code></pre><p>我们可以看下，get了三次后的连接池情况：</p>
<p><img src="/assets/post/2014-04-17-nginxconnections/connections_get.png" alt="connections_get"></p>
<h3 id="3-_连接的释放">3. 连接的释放</h3><p>下面是free_connection的过程，连接释放后，重新加入到连接池的过程很像链表在头指针后插入节点的操作(其实就是)，free之后，可能连接池的整体情况不像开始那样“整齐”，不过，我们把他当做链表来看，free_connection是头指针，通过c-&gt;data把指针一个一个串了起来，保证下次get的时候，get头节点的，free的时候，也是free头节点。</p>
<pre><code><span class="literal">void</span>
ngx_free_connection(ngx_connection_t <span class="subst">*</span>c)
{
    <span class="comment">/* ngx_mutex_lock */</span>
    <span class="comment">//free节点next指向</span>
    c<span class="subst">-&gt;</span><span class="built_in">data</span> <span class="subst">=</span> ngx_cycle<span class="subst">-&gt;</span>free_connections;
    ngx_cycle<span class="subst">-&gt;</span>free_connections <span class="subst">=</span> c;
    ngx_cycle<span class="subst">-&gt;</span>free_connection_n<span class="subst">++</span>;

    <span class="comment">/* ngx_mutex_unlock */</span>

    <span class="keyword">if</span> (ngx_cycle<span class="subst">-&gt;</span>files) {
        ngx_cycle<span class="subst">-&gt;</span>files<span class="preprocessor">[</span>c<span class="subst">-&gt;</span>fd<span class="preprocessor">]</span><span class="markup"> = NULL;
    }
}</span>
</code></pre><p>我们可以看下，free了三次后的连接池情况：</p>
<p><img src="/assets/post/2014-04-17-nginxconnections/connections_free.png" alt="connections_free"></p>
<p>以上就是连接池的基本操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近，有些忙，没看nginx代码，前几天去阿里实习面试了，结果还不错。:)让我激动的是二面面试我的居然是褚霸！面完了以后，还和他握了手。简直是激动得不能再激动啦。面试的时候也有很大收获，至少知道自己的路是对的，也应该加强自己后台开发的相关项目经历。加油吧！</p>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx建立连接过程分析]]></title>
    <link href="http://yikun.github.io/2014/04/01/nginxaccept/"/>
    <id>http://yikun.github.io/2014/04/01/nginxaccept/</id>
    <published>2014-03-31T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>本文主要学习了nginx连接accept的步骤，以及nginx的负载均衡的方法。<br><a id="more"></a></p>
<h3 id="2-_建立连接过程">2. 建立连接过程</h3><p>处理新链接事件的回调函数是ngx_event_accept函数，当处理建立连接事件的时候就调用ngx_event_accept函数。该函数的具体步骤如下所示。</p>
<p>1.调用accpet方法。</p>
<pre><code>s=<span class="function"><span class="title">accept</span><span class="params">(lc-&gt;fd, (struct sockaddr *)</span><span class="title">sa</span></span>, &amp;socklen)
</code></pre><p>2.设置负载均衡的阈值。</p>
<pre><code>ngx_accept_disabled = ngx_cycle-&gt;connection_n/<span class="number">8</span> - ngx_cycle-&gt;free_connection_n;
</code></pre><p>3.从连接池获取连接。</p>
<pre><code>c <span class="subst">=</span> ngx_get_connection(s, ev<span class="subst">-&gt;</span><span class="keyword">log</span>);
</code></pre><p>4.给连接分配内存空间。</p>
<p>5.设置套接字属性，设置非阻塞<br>        ngx_nonblocking(s)</p>
<p>6.将连接加入事件循环。<br>        ngx_add_conn(c)</p>
<pre><code><span class="hexcolor">#def</span>ine ngx_add_conn         ngx_event_actions.add_conn
</code></pre><p>7.调用监听对象的回调方法。</p>
<h3 id="3-_负载均衡问题">3. 负载均衡问题</h3><p>在建立连接前需要使用ngx_trylock_accept_mutex()去“抢锁”，抢到锁了之后，才有资格去accept连接。</p>
<p>代码比较简单，拿出来分析一下</p>
<pre><code>ngx_int_t
ngx_trylock_accept_mutex(ngx_cycle_t <span class="subst">*</span>cycle)
{
    <span class="comment">//尝试锁，无论取到还是未取到，均立即返回，取到返回1，否则返回0。</span>
    <span class="keyword">if</span> (ngx_shmtx_trylock(<span class="subst">&amp;</span>ngx_accept_mutex)) {

        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle<span class="subst">-&gt;</span><span class="keyword">log</span>, <span class="number">0</span>,
                       <span class="string">"accept mutex locked"</span>);

        <span class="keyword">if</span> (ngx_accept_mutex_held
            <span class="subst">&amp;&amp;</span> ngx_accept_events <span class="subst">==</span> <span class="number">0</span>
            <span class="subst">&amp;&amp;</span> <span class="subst">!</span>(ngx_event_flags <span class="subst">&amp;</span> NGX_USE_RTSIG_EVENT))
        {
            <span class="keyword">return</span> NGX_OK;
        }
        <span class="comment">//将所有读事件加入epoll</span>
        <span class="keyword">if</span> (ngx_enable_accept_events(cycle) <span class="subst">==</span> NGX_ERROR) {
            ngx_shmtx_unlock(<span class="subst">&amp;</span>ngx_accept_mutex);
            <span class="keyword">return</span> NGX_ERROR;
        }

        ngx_accept_events <span class="subst">=</span> <span class="number">0</span>;
        ngx_accept_mutex_held <span class="subst">=</span> <span class="number">1</span>;

        <span class="keyword">return</span> NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle<span class="subst">-&gt;</span><span class="keyword">log</span>, <span class="number">0</span>,
                   <span class="string">"accept mutex lock failed: %ui"</span>, ngx_accept_mutex_held);
    <span class="comment">//未取到锁，ngx_accept_mutex_held还为1，则删除所有监听的读事件</span>
    <span class="keyword">if</span> (ngx_accept_mutex_held) {
        <span class="keyword">if</span> (ngx_disable_accept_events(cycle) <span class="subst">==</span> NGX_ERROR) {
            <span class="keyword">return</span> NGX_ERROR;
        }

        ngx_accept_mutex_held <span class="subst">=</span> <span class="number">0</span>;
    }

    <span class="keyword">return</span> NGX_OK;
}
</code></pre><p>总结一下就是说，拿到锁了，就监听事件，拿不到就不能监听。若ngx_accept_mutex_held为1，则拥有了把accept事件加入到自己的ngx_posted_accept_events的权利。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>本文主要学习了nginx连接accept的步骤，以及nginx的负载均衡的方法。<br>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx的事件主体分析]]></title>
    <link href="http://yikun.github.io/2014/03/26/nginxevent/"/>
    <id>http://yikun.github.io/2014/03/26/nginxevent/</id>
    <published>2014-03-25T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>在上篇文章中，介绍了事件模块的初始化工作，其中ngx_event_process_init会调用module-&gt;actions.init(对应epoll为ngx_epoll_init)，该步调用的是epoll的初始化函数，之后，将rev的回调函数指向ngx_event_accept函数，这样便会accept新的链接。那么，本文将以epoll为例，来学习一下事件机制的主体。<br><a id="more"></a></p>
<h3 id="2-_事件主体">2. 事件主体</h3><p>我们的重点还是放在ngx_worker_process_cycle，处理事件的核心则是ngx_process_events_and_timers，其基本机制如下图所示，<br><img src="/assets/post/2014-03-26-nginxevent/nginx_epoll.png" alt="eventcore"></p>
<p>在ngx_worker_process_cycle最开始的初始化中，epoll模块会调用epoll_creat初始化，之后便进入事件的循环中，然后epoll_wait有事件就加入到队列中，然后集中处理，如果拿到锁了就可以处理accept的事件，然后处理完accept后就解锁，之后再去处理普通读写事件。</p>
<p>事件的主循环主要分为三步</p>
<p>1.调用ngx_process_events。</p>
<pre><code><span class="hexcolor">#def</span>ine ngx_process_events   ngx_event_actions.process_events
</code></pre><p>而对于epoll来说就是调用ngx_epoll_process_events函数。</p>
<p>2.调用ngx_event_process_posted处理事件队列中的事件。</p>
<p>ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);<br>ngx_event_process_posted(cycle, &amp;ngx_posted_events);<br>我们可以看见处理的网络事件主要牵扯到2个队列，一个是ngx_posted_accept_events，另一个是ngx_posted_events。其中，一个队列用于放accept的事件，另一个则是普通的读写事件；<br>ngx_event_process_posted会处理事件队列，其实就是调用每个事件的回调函数，然后再让这个事件出队。<br>例如，我们在开始的时候，已经把accept事件的回调函数指定为ngx_event_accept，那么当处理accept事件的时候便会调用这个函数。</p>
<p>我么可以看到，每个worker进程先抢锁，抢到锁的worker就获得所有监听的事件，这个worker来“接待”新的”accept”，当接待完ngx_posted_accept_events队列里面的连接后，就解锁。没拿到锁的，会更频繁的拿锁。最终实现了负载均衡。</p>
<p>3.处理定时器事件。</p>
<p>以上便是整个事件机制的实现。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>在上篇文章中，介绍了事件模块的初始化工作，其中ngx_event_process_init会调用module-&gt;actions.init(对应epoll为ngx_epoll_init)，该步调用的是epoll的初始化函数，之后，将rev的回调函数指向ngx_event_accept函数，这样便会accept新的链接。那么，本文将以epoll为例，来学习一下事件机制的主体。<br>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx的事件初始化与框架]]></title>
    <link href="http://yikun.github.io/2014/03/21/nginxeventinit/"/>
    <id>http://yikun.github.io/2014/03/21/nginxeventinit/</id>
    <published>2014-03-20T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>因为开始对nginx的模块机制不是很了解，所以开始看事件模块的这部分还是云里来，雾里去的，最后，算是理清了，我觉得应该抓几个核心的数据结构，无论是初始化，还是在事件循环中，都和这些数据结构息息相关。我们需要抓住这两个结构体，搞清楚他们在什么时候初始化，什么时候起作用，这样就可以理清大概的<br><a id="more"></a><br>nginx的事件机制最重要的牵扯到几个结构体，当然niginx的事件的初始化也围绕着这几个模块进行。</p>
<h3 id="2-_事件模块配置的初始化">2. 事件模块配置的初始化</h3><p>事件模块配置的初始化，主要是所有事件模块的配置创建与初始化的过程，与事件模块息息相关的是ngx_events_module结构体，定义了对<code>events</code>的“兴趣”，以及初始化events的回调函数ngx_events_block。</p>
<p>首先，最重要的结构体是</p>
<pre><code>ngx_module_t  ngx_events_module = {
    NGX_MODULE_V1,
    &amp;ngx_events_module_ctx,                /<span class="keyword">*</span> module context <span class="keyword">*</span>/
    ngx_events_commands,                   /<span class="keyword">*</span> module directives <span class="keyword">*</span>/
    NGX_CORE_MODULE,                       /<span class="keyword">*</span> module type <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init master <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init module <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init process <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init thread <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit thread <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit process <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit master <span class="keyword">*</span>/
    NGX_MODULE_V1_PADDING
};
</code></pre><p>该结构提为nginx的核心模块(NGX_CORE_MODULE)，主要用于events配置的解析，那么初始化的时候围绕着这个结构体进行的当然也便是配置解析的相关工作了。</p>
<p>其次，这个模块还需要管理所有时间模块的配置，最后还有就是对各个事件模块的配置进行统一管理。</p>
<pre><code><span class="keyword">static</span> ngx_command_t  ngx_events_commands[] = {
    { ngx_string(<span class="string">"events"</span>),
      NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
      ngx_events_block,
      <span class="number">0</span>,
      <span class="number">0</span>,
      <span class="keyword">NULL</span> },

      ngx_null_command
};


<span class="keyword">static</span> ngx_core_module_t  ngx_events_module_ctx = {
    ngx_string(<span class="string">"events"</span>),
    <span class="keyword">NULL</span>,
    ngx_event_init_conf
};
</code></pre><p>然后再看看<code>ngx_events_module</code>的内容，主要牵扯到的变量有<code>ngx_events_commands</code>、<code>ngx_events_module_ctx</code>，<br><code>ngx_events_commands</code>可以理解为告诉解析conf，解析到什么指令，调用什么函数，比如这里就是解析到<code>events</code>指令调用<code>ngx_events_block</code>函数。<br><code>ngx_events_module_ctx</code>则是核心模块提供给各种模块实现时提供的接口，事件模块作为核心模块，也需要实现这个接口。</p>
<p>也就是说除了配置文件解析之外，这个模块没有做任何其他事情，让我们来关注一下<code>ngx_events_block</code>。</p>
<p>之前的文章有介绍过nginx的初始化过程，在初始化的时候，会调用ngx_init_cycle函数，而该函数会调用ngx_conf_parse，其中ngx_conf_parse会完成对<code>ngx_events_block</code>的调用，具体是怎么样调用的在以后再学习配置解析的时候再分析。现在只需要知道ngx_events_block调用时机是在ngx_conf_parse的时候就勾勒，重点看下ngx_events_block的实现，ngx_events_block执行过程如图所示，</p>
<p><img src="/assets/post/2014-03-21-nginxeventinit/ngx_events_block.png" alt="nginx_channel"></p>
<p>下面将这五步详细介绍一下，</p>
<p>1.对事件模块进行标号。首先在ngx_modules[i]数组里面找到<code>NGX_EVENT_MODULE</code>的变量，之后对每一个事件模块进行标号，也就是说ctx_index表示在相同类型模块中的标号。例如此处的就表示在所有事件模块中的标号。ngx_modules则是一个全局数组，位于<code>obj/ngx_modules.c</code>目录，存储着所有的模块信息。</p>
<pre><code><span class="title">ngx_event_max_module</span> = <span class="number">0</span>;
<span class="title">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) {
    <span class="keyword">if</span> (ngx_modules[i]-&gt;<span class="typedef"><span class="keyword">type</span> != <span class="type">NGX_EVENT_MODULE</span>) <span class="container">{
        <span class="title">continue</span>;
    }</span></span>

    ngx_modules[i]-&gt;ctx_index = ngx_event_max_module++;
}
</code></pre><p>2.为事件模块的配置分配空间。其次便是给事件模块配置的指针及配置所存储的指针数组分配空间。</p>
<pre><code><span class="comment">//开辟红色部分空间</span>
ctx <span class="subst">=</span> ngx_pcalloc(cf<span class="subst">-&gt;</span>pool, sizeof(<span class="literal">void</span> <span class="subst">*</span>));
<span class="keyword">if</span> (ctx <span class="subst">==</span> <span class="built_in">NULL</span>) {
    <span class="keyword">return</span> NGX_CONF_ERROR;
}
<span class="comment">//开辟蓝色部分空间</span>
<span class="subst">*</span>ctx <span class="subst">=</span> ngx_pcalloc(cf<span class="subst">-&gt;</span>pool, ngx_event_max_module <span class="subst">*</span> sizeof(<span class="literal">void</span> <span class="subst">*</span>));
<span class="keyword">if</span> (<span class="subst">*</span>ctx <span class="subst">==</span> <span class="built_in">NULL</span>) {
    <span class="keyword">return</span> NGX_CONF_ERROR;
}
</code></pre><p>在ngx_cycle_t中有一个conf的四级指针(conf_ctx)。它指向了一个指针数组A(存储着所有核心模块配置结构体指针)，A中的指针又指向了另一个指针数组B(假设A中的这个指针是事件模块配置结构体的指针)，那么B中就存着事件模块的配置。如图所示</p>
<p><img src="/assets/post/2014-03-21-nginxeventinit/nginx_module_conf.png" alt="nginx_channel"></p>
<p>3.对每个事件模块create_conf, 调用每个事件模块中的create_conf方法，m现在指向的就是每个模块的配置内容(即ctx, context，上下文)</p>
<pre><code><span class="keyword">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) {
    <span class="keyword">if</span> (ngx_modules[i]-&gt;type != NGX_EVENT_MODULE) {
        <span class="keyword">continue</span>;
    }

    m = ngx_modules[i]-&gt;ctx;

    <span class="keyword">if</span> (m-&gt;create_conf) {
        (*ctx)[ngx_modules[i]-&gt;ctx_index] = m-&gt;create_conf(cf-&gt;cycle);
        <span class="keyword">if</span> ((*ctx)[ngx_modules[i]-&gt;ctx_index] == <span class="keyword">NULL</span>) {
            <span class="keyword">return</span> NGX_CONF_ERROR;
        }
    }
}
</code></pre><p>4.解析events中的指令。调用ngx_conf_parse解析events块中的指令。</p>
<p>5.对每个事件模块init_conf。调用每个事件模块中的init方法</p>
<pre><code><span class="title">for</span> (i = <span class="number">0</span>; ngx_modules[i]; i++) {
    <span class="keyword">if</span> (ngx_modules[i]-&gt;<span class="typedef"><span class="keyword">type</span> != <span class="type">NGX_EVENT_MODULE</span>) <span class="container">{
        <span class="title">continue</span>;
    }</span></span>

    m = ngx_modules[i]-&gt;ctx;

    <span class="keyword">if</span> (m-&gt;init_conf) {
        rv = m-&gt;init_conf(cf-&gt;cycle, (*ctx)[ngx_modules[i]-&gt;ctx_index]);
        <span class="keyword">if</span> (rv != <span class="type">NGX_CONF_OK</span>) {
            return rv;
        }
    }
}
</code></pre><p>完成每个conf的配置。至此，<code>ngx_events_block</code>的工作就完了，总结一下就是负责配置文件中events block的解析。</p>
<h3 id="3-_ngx_event_core_module">3. ngx_event_core_module</h3><p>其次，是ngx_event_core_module这个模块是一个事件类型(NGX_EVENT_MODULE)的模块</p>
<pre><code>ngx_module_t  ngx_event_core_module = {
    NGX_MODULE_V1,
    &amp;ngx_event_core_module_ctx,            /<span class="keyword">*</span> module context <span class="keyword">*</span>/
    ngx_event_core_commands,               /<span class="keyword">*</span> module directives <span class="keyword">*</span>/
    NGX_EVENT_MODULE,                      /<span class="keyword">*</span> module type <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init master <span class="keyword">*</span>/
    ngx_event_module_init,                 /<span class="keyword">*</span> init module <span class="keyword">*</span>/
    ngx_event_process_init,                /<span class="keyword">*</span> init process <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> init thread <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit thread <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit process <span class="keyword">*</span>/
    NULL,                                  /<span class="keyword">*</span> exit master <span class="keyword">*</span>/
    NGX_MODULE_V1_PADDING
};
</code></pre><p>先开始，把<code>ngx_events_module</code>和<code>ngx_event_core_module</code>搞混了，因为之前没有接触过nginx的模块，现在清楚了，当看到一个模块的时候，先看module type，<code>ngx_event_core_module</code>的type是NGX_EVENT_MODULE。而比较特殊，他是NGX_EVENT_MODULE最核心的module，同样的，我们看看ngx_event_core_module的内容<br><code>ngx_event_core_commands</code> 存储着解析到”某些指令”回调”某些函数”。<br><code>ngx_event_core_module_ctx</code> 则存储着模块配置的创建与初始化函数。</p>
<pre><code><span class="keyword">static</span> ngx_command_t  ngx_event_core_commands[] = {

    { ngx_string(<span class="string">"worker_connections"</span>),
      NGX_EVENT_CONF|NGX_CONF_TAKE1,
      ngx_event_connections,
      <span class="number">0</span>,
      <span class="number">0</span>,
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"connections"</span>),
      NGX_EVENT_CONF|NGX_CONF_TAKE1,
      ngx_event_connections,
      <span class="number">0</span>,
      <span class="number">0</span>,
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"use"</span>),
      NGX_EVENT_CONF|NGX_CONF_TAKE1,
      ngx_event_use,
      <span class="number">0</span>,
      <span class="number">0</span>,
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"multi_accept"</span>),
      NGX_EVENT_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      <span class="number">0</span>,
      offsetof(ngx_event_conf_t, multi_accept),
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"accept_mutex"</span>),
      NGX_EVENT_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      <span class="number">0</span>,
      offsetof(ngx_event_conf_t, accept_mutex),
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"accept_mutex_delay"</span>),
      NGX_EVENT_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_msec_slot,
      <span class="number">0</span>,
      offsetof(ngx_event_conf_t, accept_mutex_delay),
      <span class="keyword">NULL</span> },

    { ngx_string(<span class="string">"debug_connection"</span>),
      NGX_EVENT_CONF|NGX_CONF_TAKE1,
      ngx_event_debug_connection,
      <span class="number">0</span>,
      <span class="number">0</span>,
      <span class="keyword">NULL</span> },

      ngx_null_command
};

ngx_event_module_t  ngx_event_core_module_ctx = {
    &amp;event_core_name,
    ngx_event_core_create_conf,            <span class="comment">/* create configuration */</span>
    ngx_event_core_init_conf,              <span class="comment">/* init configuration */</span>

    { <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span> }
};
</code></pre><p>另外，ngx_event_core_module还定义了2个函数。我们来看看这两个函数的调用情况</p>
<pre><code>ngx_event_module_init,                 /<span class="keyword">*</span> init module <span class="keyword">*</span>/
ngx_event_process_init,                /<span class="keyword">*</span> init process <span class="keyword">*</span>/
</code></pre><p>这两个函数的调用的时机，如下图所示：</p>
<p><img src="/assets/post/2014-03-21-nginxeventinit/module_process_init.png" alt="nginx_channel"></p>
<p>ngx_event_module_init是在ngx_init_cycle被调用的，主要就是初始化模块的一些变量。</p>
<p>ngx_event_process_init则是在worker进程开始时被调用，之后便进入事件循环中，主要包括了负载均衡锁的初始化、定时器的初始化、连接池的初始化，以及在最后遍历所有modules来调用modules数组中的ngx_add_event函数，将事件添加到监听队列中。可以看到</p>
<pre><code><span class="hexcolor">#def</span>ine ngx_process_changes  ngx_event_actions<span class="class">.process_changes</span>
<span class="hexcolor">#def</span>ine ngx_process_events   ngx_event_actions<span class="class">.process_events</span>
<span class="hexcolor">#def</span>ine ngx_done_events      ngx_event_actions<span class="class">.done</span>

<span class="hexcolor">#def</span>ine ngx_add_event        ngx_event_actions<span class="class">.add</span>
<span class="hexcolor">#def</span>ine ngx_del_event        ngx_event_actions<span class="class">.del</span>
<span class="hexcolor">#def</span>ine ngx_add_conn         ngx_event_actions<span class="class">.add_conn</span>
<span class="hexcolor">#def</span>ine ngx_del_conn         ngx_event_actions.del_conn
</code></pre><p>这就是nginx事件模块的精华所在，通过这样的方式，就可以使得ngx_event_actions不同，采用不同的复用机制。可以参照下图，来理解ngx_event_core_module。</p>
<p><img src="/assets/post/2014-03-21-nginxeventinit/nginx_core_module.png" alt="nginx_channel"></p>
<p>上面可以看到红色的部分是ngx_event_core_module有用的部分，需要强调的是这个事件模型只是用来初始化类似epoll的模块的，而自己是不做一些类似epoll事件循环的具体事件的。</p>
<p>至此，事件初始化就结束了，可以看到上面都是nginx通用的，不牵扯到具体的复用机制，后面会根据epoll来具体学习一下nginx事件循环。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>因为开始对nginx的模块机制不是很了解，所以开始看事件模块的这部分还是云里来，雾里去的，最后，算是理清了，我觉得应该抓几个核心的数据结构，无论是初始化，还是在事件循环中，都和这些数据结构息息相关。我们需要抓住这两个结构体，搞清楚他们在什么时候初始化，什么时候起作用，这样就可以理清大概的<br>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的vim配置]]></title>
    <link href="http://yikun.github.io/2014/03/19/vim/"/>
    <id>http://yikun.github.io/2014/03/19/vim/</id>
    <published>2014-03-18T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>最近把vim的配置整理的一下，然后更新到github上了。<br><a id="more"></a><br>之前一直在用vim，不过一直把他作为编辑器而已，就是写，然后:wq。最近在看nginx的代码，然后稍微归整了下vim的配置，也总结了一些有用的插件，让我阅读代码爽一些。放到github的主要目的还是为了备份，虽然插件不多，但是对我来说基本够用了。大致插件是实现的功能集中在高亮、函数列表、文件夹列表、函数跳转、代码补全、头源文件跳转、文件打开、状态栏美化。下面具体的介绍下我的配置。</p>
<p><img src="/assets/post/2014-03-19-vim/vim_all.png" alt="vim概览"></p>
<h3 id="我的vim插件概览">我的vim插件概览</h3><p><code>pathogen.vim</code> 用于插件管理，把插件放到bundle目录就可以了。</p>
<p><code>Trinity.vim</code> 用于集中管理taglist、nerdtree、srcexpl三个插件，按 <code>F8</code> 就可以快速打开这三个插件了。</p>
<p><code>taglist.vim</code> 用于生成、展示函数列表</p>
<p><code>nerdtree.vim</code> 用于生成、展示目录和文件</p>
<p><code>srcexpl.vim</code> 用于函数的展示，当移动到函数上的之后，就会在srcexpl的窗口里面显示函数定义的。</p>
<p><code>CSApprox.vim</code> 这是一个vim配色的插件，我比较喜欢desert这个配色。</p>
<p><code>OmniCppComplete.vim</code> 用于代码补全工作，能够加快<a href="/assets/post/2014-03-19-vim/vim_omni.png">效果</a></p>
<p><code>a.vim</code> 用于快速切换<em>.c和</em>.h</p>
<p><code>ctrlp.vim</code> 用于文件的模糊搜索，能够加快打开文件的速度<a href="/assets/post/2014-03-19-vim/vim_ctrlp.png">效果</a></p>
<p><code>powerline.vim</code> 一个优雅的状态栏插件</p>
<p><code>vimgrep</code> 自带插件，用于搜索tags中匹配字符，可以查看函数调用情况<a href="/assets/post/2014-03-19-vim/vim_grep.png">效果</a></p>
<h3 id="如何使用的我的配置">如何使用的我的配置</h3><p>最简单的方法就是clone所有的配置到你的<code>.vim</code>目录之中，首先交代下我的vim配置方法，与vim相关的配置主要是<code>.vim</code>里的插件，一般目录位于<code>~/.vim</code>，还有vim的配置文件<code>~/.vimrc</code>，为了让配置vim更简单些，利用了<code>ln -s  ~/.vim/.vimrc ~/.vimrc</code>命令，这样，就相当于<code>～/.vimrc</code>是一个指向<code>~/.vim/.vimrc</code>的快捷方式。因此使用我的配置，也很简单。</p>
<p>第一步，备份。</p>
<pre><code><span class="preprocessor"># mv ~/.vim backup</span>
<span class="preprocessor"># mv ~/.vimrc backup</span>
</code></pre><p>第二部，复制配置。</p>
<pre><code># git clone git<span class="annotation">@github</span>.<span class="string">com:</span>Yikun<span class="regexp">/vim-config.git ~/</span>.vim
</code></pre><p>第三部，创建.vimrc链接</p>
<pre><code><span class="preprocessor"># ln -s ~/.vim/.vimrc ~/.vimrc</span>
</code></pre><p>这样就ok了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近把vim的配置整理的一下，然后更新到github上了。<br>]]>
    
    </summary>
    
      <category term="vim" scheme="http://yikun.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx中channel机制]]></title>
    <link href="http://yikun.github.io/2014/03/16/nginxchannel/"/>
    <id>http://yikun.github.io/2014/03/16/nginxchannel/</id>
    <published>2014-03-15T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_概述">1. 概述</h3><p>由于nginx使用的是多进程的模型，因此，进程间的通信或者同步很重要，为什么要进行进程同步呢？我们知道，nginx有master和worker进程，在上篇文章已经分析过了master具体是怎样创建worker进程的。不过，在创建worker进程的时候，是需要对进程同步的。举个具体的例子，我们假设服务器共有4个worker进程，我们知道nginx有一个全局变量，是ngx_processes数组，他存储着所有进程的信息，在worker1创建的时候，worker2，worker3，worker4进程是没有创建的，因此，这个时候就牵扯到同步，最合理的方式是，在master创建一个进程的时候，就应该通知所有子进程有新的进程被fork了，以及这个进程的基本信息。<br><a id="more"></a><br>这个好比一个集体(由很多processes组成)，当有新的成员加入这个集体的时候，老大应该告诉大伙，有新成员进来了，他的基本信息是balabala。因此，也就引出了本文所要总结的内容，即nginx的进程通信机制。</p>
<h3 id="2-_worker进程的创建">2. worker进程的创建</h3><p>我们先回顾一下worker进程的创建过程，ngx_master_process_cycle -&gt; ngx_start_worker_processes，在 <code>ngx_start_worker_processes</code> 函数中，有下面的代码</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span>
ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n, ngx_int_t <span class="class"><span class="keyword">type</span>)</span>
{
    ngx_int_t      i;
    ngx_channel_t  ch;

    ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;log, <span class="number">0</span>, <span class="string">"start worker processes"</span>);

    ch.command = NGX_CMD_OPEN_CHANNEL;

    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) {

        ngx_spawn_process(cycle, ngx_worker_process_cycle,
                          (<span class="keyword">void</span> *) (intptr_t) i, <span class="string">"worker process"</span>, <span class="class"><span class="keyword">type</span>);</span>

        ch.pid = ngx_processes[ngx_process_slot].pid;
        ch.slot = ngx_process_slot;
        ch.fd = ngx_processes[ngx_process_slot].channel[<span class="number">0</span>];

        ngx_pass_open_channel(cycle, &amp;ch);
    }
}
</code></pre><p>注意观察下， <code>ngx_channel_t</code> 结构体的定义如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span>
     ngx_uint_t  command;
     ngx_pid_t   pid;
     ngx_int_t   slot;
     ngx_fd_t    fd;
} ngx_channel_t;
</code></pre><p>没错，这个就是master与worker进程通信的最重要的结构，短小精汗。</p>
<p>该结构封装了四个变量，分别是指令(master要worker干啥)，pid(worker的进程id)，slot(worker进程在ngx_processes的索引)，文件描述符。我们思考一下概述中的那个问题，怎么将master后创建的进程通知前面已创建的进程。 <code>ngx_pass_open_channel(cycle, &amp;ch);</code> 注意一下这个函数，没错就是它了，通过它对每个进程进行通知。</p>
<h3 id="3-_nginx频道">3. nginx频道</h3><p>那么具体又是怎么实现通知的呢？我们看到在 <code>ngx_channel_t</code> 中有一个 <code>ngx_fd_t    fd;</code> 这个文件描述便存储着通信的“接口”，从之前的代码我们看出来， <code>ch.fd = ngx_processes[ngx_process_slot].channel[0];</code> 这个channel[0]是真正传输的接口。那么他是什么呢？简单的说，就是master写给每个process的channel[0]一些信息(ngx_channel_t的实际内容)，worker就能在自己的channel[1]中，读取到这些信息。</p>
<p>nginx使用的是 <code>socketpair</code> 方法关联套接字，我们看看socketpair的原型：</p>
<pre><code><span class="typename">int</span> socketpair(<span class="typename">int</span> d, <span class="typename">int</span> <span class="built_in">type</span>, <span class="typename">int</span> protocol, <span class="typename">int</span> <span class="built_in">sv</span>[<span class="number">2</span>]);
</code></pre><p>我们关注一下第四个参数，当这个socketpair函数执行成功后，就会生成一个socket对在数组中，sv[2]中的socket是关联起来的，什么意思呢？就是说向sv[0]写数据，在sv[1]就能读到相应的数据；相反的，在sv[1]写数据，在sv[0]也可以读到相应的数据。在master进程fork worker进程的时候，也把这个套接字传给了worker，也就是说在master向worker的sv[0]写数据，那么worker便可以在自己的sv[1]中读到数据。</p>
<p><img src="/assets/post/2014-03-16-nginxchannel/nginx_channel.png" alt="nginx_channel"></p>
<p>nginx的具体的实现方式如上图所示：<br>channel[0]和channel[0]为一对socketpair。</p>
<pre><code>1. 向<span class="tag">channel</span><span class="attr_selector">[0]</span>写数据时，可从<span class="tag">channel</span><span class="attr_selector">[1]</span>读数据；
2. 向<span class="tag">channel</span><span class="attr_selector">[1]</span>写数据时，可从<span class="tag">channel</span><span class="attr_selector">[0]</span>读数据。
</code></pre><p>而nginx，只利用了第一条，即master向channel[0]写数据时，worker可从channel[1]读数据<br>socketpair也用来进行父子进程的通信，子进程会继承父进程的资源。</p>
<h3 id="3-_master写入与worker读取数据">3. master写入与worker读取数据</h3><p>我们具体的来看下nginx写入数据的过程，</p>
<pre><code>ngx_write_channel<span class="list">(<span class="keyword">ngx_processes</span>[i].channel[<span class="number">0</span>],
                          ch, sizeof<span class="list">(<span class="keyword">ngx_channel_t</span>)</span>, cycle-&gt;log)</span><span class="comment">;</span>
</code></pre><p>和上节介绍的一样，我们看到master对每一个ngx_processes[i].channel[0]写入数据。并且写入的数据就是 <code>ngx_channel_t</code> 变量。<br>好了，既然master向worker写数据的接口有了，那么woker又怎么对master写入的数据进行读取和处理呢？</p>
<p>我们目光移到worker进程上面，ngx_worker_process_cycle函数，在初始化时，调用了 <code>ngx_worker_process_init</code> 函数，这个初始化函数又调用了</p>
<pre><code><span class="function"><span class="title">ngx_add_channel_event</span><span class="params">(cycle, ngx_channel, NGX_READ_EVENT,ngx_channel_handler)</span></span>
</code></pre><p>这个就利用了nginx强大的事件机制，这个函数大概的功能就是，如果worker channel[1]有可读的数据，便会调用  <code>ngx_channel_handler</code>  进行处理。</p>
<pre><code><span class="keyword">switch</span> (ch.command) {

<span class="keyword">case</span> <span class="string">NGX_CMD_QUIT:</span>
    ngx_quit = <span class="number">1</span>;
    <span class="keyword">break</span>;

<span class="keyword">case</span> <span class="string">NGX_CMD_TERMINATE:</span>
    ngx_terminate = <span class="number">1</span>;
    <span class="keyword">break</span>;

<span class="keyword">case</span> <span class="string">NGX_CMD_REOPEN:</span>
    ngx_reopen = <span class="number">1</span>;
    <span class="keyword">break</span>;

<span class="keyword">case</span> <span class="string">NGX_CMD_OPEN_CHANNEL:</span>
    ...
    ngx_processes[ch.slot].pid = ch.pid;
    ngx_processes[ch.slot].channel[<span class="number">0</span>] = ch.fd;
    <span class="keyword">break</span>;

<span class="keyword">case</span> <span class="string">NGX_CMD_CLOSE_CHANNEL:</span>
    ...
    <span class="keyword">if</span> (close(ngx_processes[ch.slot].channel[<span class="number">0</span>]) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_ALERT, ev-&gt;log, ngx_errno,
                      <span class="string">"close() channel failed"</span>);
    }

    ngx_processes[ch.slot].channel[<span class="number">0</span>] = -<span class="number">1</span>;
    <span class="keyword">break</span>;

<span class="keyword">case</span> <span class="string">NGX_CMD_PIPE_BROKEN:</span>
    ngx_pipe_broken_action(ev-&gt;log, ch.pid, <span class="number">0</span>);
    <span class="keyword">break</span>;
}
</code></pre><p>由于nginx目前的读写数据只是单向的即mater—&gt;worker，因此，这些指令的解析，都是需要让worker做一些事儿。我们可以关注一下 <code>NGX_CMD_OPEN_CHANNEL</code> 这个分支。在ngx_start_worker_processes函数中，master就向worker写入了 <code>NGX_CMD_OPEN_CHANNEL</code> 指令。</p>
<p>那么worker进程，便根据这个 <code>ngx_channel_t ch</code> 信息，更新processes数组。这样便完成了进程的同步。</p>
<h3 id="4-_nginx中channel指令">4. nginx中channel指令</h3><p>我们发现，ngx_channel_handler中共有6个指令类型，分别是NGX_CMD_QUIT、NGX_CMD_TERMINATE、NGX_CMD_REOPEN、NGX_CMD_OPEN_CHANNEL、NGX_CMD_CLOSE_CHANNEL、NGX_CMD_PIPE_BROKEN。下面我们分析下，和channel相关的命令。</p>
<p><code>NGX_CMD_OPEN_CHANNEL</code><br>之前，我们已经分析了NGX_CMD_OPEN_CHANNEL信号的解析大致过程，现在仔细观察一下，我先搜索了一下使用<code>NGX_CMD_OPEN_CHANNEL</code>命令的地方，对<code>ch.command</code>赋值的地方有四处。第一处是用于worker进程的，第二、三处是和cache manager进程有关的，暂不关注，第四处，是<code>ngx_reap_children</code>主要是用于nginx重启后，重新开启channel的。</p>
<p>我们只分析第一处，master进程的函数<code>ngx_start_worker_processes</code> 在开启worker进程的时候，把命令设置为<code>NGX_CMD_OPEN_CHANNEL</code>，并且通过<code>ngx_write_channel</code>把指令给相应的进程，这样当worker进程解析这个消息时，便根据新进程的slot把新进程的信息(新进程的pid、新进程的channel[0])保存起来。<br><img src="/assets/post/2014-03-16-nginxchannel/nginx_open_channel.png" alt="nginx_open_channel"></p>
<p>上图已经表明了<code>NGX_CMD_OPEN_CHANNEL</code>的传递与生效过程。<br>分为2个部分</p>
<ol>
<li>Master部分。<br> 第一步，由Master进程创建socket pair，即创建channel，利用socketpair函数，master进程processes数组中存储了master与新的work的channel信息。<br> 第二步，2. Fork的子进程会继承父进程，Fork子进程，利用fork函数，子进程会继承父进程的资源。<br> 第三步，3. 利用ngx_pass_open_channel向各进程发送NGX_CMD_OPEN_CHANNEL，通知其他进程信息更新。<br>2.Worker部分。<br> 第一步，关闭除自己以外的channel[1]。<br> 第二步，关闭自己的channel[0]。</li>
</ol>
<p>总结一下，这个命令就是告诉worker，有新的进程来，他OPEN_CHANNEL了，你得存起来，然后worker就存这个新进程的信息了，当然这个信息是存在processes数组里了。</p>
<p><code>NGX_CMD_CLOSE_CHANNEL</code><br>当然，与打开对应的就是关闭channel指令了，与这个命令相关的赋值只有一处，就是<code>ngx_reap_children</code>，当然就是master向每个进程更新信息，如果发现某个进程exited了，就告诉大家，可以把它的channel关闭了，即把这个channel的flag置为-1。而关闭的时候，<code>close(ngx_processes[ch.slot].channel[0])</code>关闭了channel[0]，先开始有疑问了，为什么只关0呢？1怎么办？原来1其实在work刚开始的时候就关闭了，即最开始就已经“关闭了除了自己外的channel[1]，然后再关闭自己的channel[0]。</p>
<p>总结一下，这个命令就是告诉work，你要关闭这个CHANNEL了，原因从目前的nginx代码来看，只有一个，就是需要重启。关闭已经exited的进程的channel。</p>
<p>不过，有些疑问，</p>
<p>1.目前来看只有master向worker的消息，不存在worker向master，或者worker向worker写了，那么为什么不关闭其他worker的channel[0]呢？我觉得可能是不是和cache load进程有关，后面再思考一下。</p>
<p>2.为什么master中要保留所有子进程channel[1]？可以在fork完子进程，就关闭，为什么不关闭呢？</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-_概述">1. 概述</h3><p>由于nginx使用的是多进程的模型，因此，进程间的通信或者同步很重要，为什么要进行进程同步呢？我们知道，nginx有master和worker进程，在上篇文章已经分析过了master具体是怎样创建worker进程的。不过，在创建worker进程的时候，是需要对进程同步的。举个具体的例子，我们假设服务器共有4个worker进程，我们知道nginx有一个全局变量，是ngx_processes数组，他存储着所有进程的信息，在worker1创建的时候，worker2，worker3，worker4进程是没有创建的，因此，这个时候就牵扯到同步，最合理的方式是，在master创建一个进程的时候，就应该通知所有子进程有新的进程被fork了，以及这个进程的基本信息。<br>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx启动流程分析]]></title>
    <link href="http://yikun.github.io/2014/03/13/nginxstart/"/>
    <id>http://yikun.github.io/2014/03/13/nginxstart/</id>
    <published>2014-03-12T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>最近，开始学习nginx的代码，大致根据<a href="http://www.alidata.org/archives/category/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="external">阿里数据平台</a>的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框架和主要工作流程。<br><a id="more"></a><br>如下图所示，为总的启动流程分析，后面是我对每个部分的总结和分析<br><img src="/assets/post/2014-03-13-nginxstart/nginx_start.png" alt="启动流程分析"></p>
<h3 id="1-_解析命令参数">1. 解析命令参数</h3><p>nginx是由C语言写成的，因此，从main函数开始开启我们的“旅程”，传入参数为argc，还有argv，最开始的任务当然就是解析它们了，以获得用户启动的参数，调用ngx_get_options解析参数，一般情况，Linux的解析命令参数都会调用getopt之类的系统函数，而nginx却没有，应该是考虑到了跨平台性。解析命令参数的代码比较简单，大致的工作就是标记flag，类似ngx_show_version，ngx_show_modules的全局参数可以记录命令参数。<br>而后，根据这些flag来做一些事情，例如使用nginx -h，会将ngx_show_version，ngx_show_help置为有效(1)，然后后面回到main后，就是做一些对应的输出。</p>
<h3 id="2-_初始化工作">2. 初始化工作</h3><p>包括了time、regex、log、ssl等初始化，而后进行一个很重要的结构的初始化ngx_cycle。</p>
<pre><code><span class="class"><span class="keyword">struct</span> <span class="title">ngx_cycle_s</span> </span>{
    <span class="keyword">void</span>                  ****conf_ctx;                        <span class="comment">//配置上下文数组(含所有模块)</span>
    ngx_pool_t               *pool;                        <span class="comment">//内存池</span>

    ngx_log_t                *log;                        <span class="comment">//日志</span>
    ngx_log_t                 new_log;

    ngx_connection_t        **files;                        <span class="comment">//连接文件</span>
    ngx_connection_t         *free_connections;                    <span class="comment">//空闲连接</span>
    ngx_uint_t                free_connection_n;                <span class="comment">//空闲连接个数</span>

    ngx_queue_t               reusable_connections_queue;            <span class="comment">//再利用连接队列</span>

    ngx_array_t               listening;                    <span class="comment">//监听数组</span>
    ngx_array_t               paths;                        <span class="comment">//路径数组</span>
    ngx_list_t                open_files;                    <span class="comment">//打开文件链表</span>
    ngx_list_t                shared_memory;                    <span class="comment">//共享内存链表</span>

    ngx_uint_t                connection_n;                    <span class="comment">//连接个数</span>
    ngx_uint_t                files_n;                        <span class="comment">//打开文件个数</span>

    ngx_connection_t         *connections;                    <span class="comment">//连接</span>
    ngx_event_t              *read_events;                    <span class="comment">//读事件</span>
    ngx_event_t              *write_events;                    <span class="comment">//写事件</span>

    ngx_cycle_t              *old_cycle;                    <span class="comment">//old cycle指针</span>

    ngx_str_t                 conf_file;                    <span class="comment">//配置文件</span>
    ngx_str_t                 conf_param;                    <span class="comment">//配置参数</span>
    ngx_str_t                 conf_prefix;                    <span class="comment">//配置前缀</span>
    ngx_str_t                 prefix;                        <span class="comment">//前缀</span>
    ngx_str_t                 lock_file;                    <span class="comment">//锁文件</span>
    ngx_str_t                 hostname;                        <span class="comment">//主机名</span>
};
</code></pre><p>ngx_init_cycle的过程的详细情况可以参考<a href="http://www.alidata.org/archives/1148" target="_blank" rel="external">Nginx启动初始化过程(二)</a>。因为现在功力不是很深，等以后对nginx有透彻了解后，再仔细分析。这里第一次出现了内存池的操作，后面重点分析一下内存池的实现。</p>
<hr>
<h3 id="3-_信号处理的初始化">3. 信号处理的初始化</h3><p>ngx_init_signals会进行信号处理的初始化，signals是一个结构体数组，存储着各种信号的结构体，在初始化的过程中，会利用sigaction函数对每个信号进行设置，如下所示，主要是对signo和handler回调函数进行设置。初始化成功以后，当信号产生以后，便可以调用信号处理函数了，因此可以利用ngx_signal_handler进行信号处理了。</p>
<pre><code>ngx_int_t
ngx_init_signals<span class="list">(<span class="keyword">ngx_log_t</span> <span class="variable">*log)
{
    ngx_signal_t      *</span>sig<span class="comment">;</span>
    struct sigaction   sa<span class="comment">;</span>

    for <span class="list">(<span class="keyword">sig</span> = signals<span class="comment">; sig-&gt;signo != 0; sig++) {</span>
        ngx_memzero<span class="list">(<span class="keyword">&amp;sa</span>, sizeof<span class="list">(<span class="keyword">struct</span> sigaction)</span>)</span><span class="comment">;</span>
        sa.sa_handler = sig-&gt;handler<span class="comment">;</span>
        sigemptyset<span class="list">(<span class="keyword">&amp;sa</span>.sa_mask)</span><span class="comment">;</span>
        if <span class="list">(<span class="keyword">sigaction</span><span class="list">(<span class="keyword">sig-&gt;signo</span>, <span class="keyword">&amp;sa</span>, NULL)</span> == <span class="number">-1</span>)</span> {
            ngx_log_error<span class="list">(<span class="keyword">NGX_LOG_EMERG</span>, log, ngx_errno,
                          <span class="string">"sigaction(%s) failed"</span>, sig-&gt;signame)</span><span class="comment">;</span>
            return NGX_ERROR<span class="comment">;</span>
        }
    }

    return NGX_OK<span class="comment">;</span>
}</span></span>
</code></pre><h3 id="4-_守护进程">4. 守护进程</h3><p>在启动过程中，会调用ngx_daemon(cycle-&gt;log)，这个函数实现的很经典。</p>
<pre><code><span class="function">ngx_int_t
<span class="title">ngx_daemon</span><span class="params">(ngx_log_t *<span class="built_in">log</span>)</span>
</span>{
    <span class="keyword">int</span>  fd;
    <span class="comment">//父进程fork</span>
    <span class="keyword">switch</span> (fork()) {
    <span class="comment">//fork执行完后，master的</span>
    <span class="keyword">case</span> -<span class="number">1</span>:
        <span class="comment">//fork出错了</span>
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"fork() failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    <span class="keyword">case</span> <span class="number">0</span>:
        <span class="comment">//master daemon(子进程)什么也不做</span>
        <span class="keyword">break</span>;

    <span class="keyword">default</span>:
        <span class="comment">//master前台进程(父进程)退出，以给控制终端一个“假象”，这个程序执行完了</span>
        <span class="built_in">exit</span>(<span class="number">0</span>);
    }
    <span class="comment">/*
    执行到这，说明最开始的“前台”进程已经退出了，这时得刷新下ngx_pid，以便后面ngx_create_pidfile用(用来优雅的重启)
    当然，有人问为什么main最开始就记录了，ngx_pid呢？那是因为nginx不一定会daemon形式启动，这样开始的进程就是master
    然而在这里，nginx将原来的前台master exit掉，然后master fork出来的，所以这里的ngx_pid就是就是daemon master的了。
    */</span>
    ngx_pid = ngx_getpid();
    <span class="comment">/*
    作为daemon只fork还是不够的，需要第二步，setsid，他的作用是让daemon成为真正的daemon
    1.会话组的老大; 2.进程组的老大; 3.不受任何控制终端控制
    */</span>
    <span class="keyword">if</span> (setsid() == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"setsid() failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }
    <span class="comment">//umask(0)是为了让读写权限保持原来的状态</span>
    umask(<span class="number">0</span>);

    <span class="comment">//后面几句就是把STD的输入/输出/错误都输出到/dev/null，也就是什么也不输出</span>
    fd = open(<span class="string">"/dev/null"</span>, O_RDWR);
    <span class="keyword">if</span> (fd == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno,
                      <span class="string">"open(\"/dev/null\") failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

    <span class="keyword">if</span> (dup2(fd, STDIN_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDIN) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

    <span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDOUT) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }

<span class="preprocessor">#<span class="keyword">if</span> 0</span>
    <span class="keyword">if</span> (dup2(fd, STDERR_FILENO) == -<span class="number">1</span>) {
        ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"dup2(STDERR) failed"</span>);
        <span class="keyword">return</span> NGX_ERROR;
    }
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">if</span> (fd &gt; STDERR_FILENO) {
        <span class="keyword">if</span> (close(fd) == -<span class="number">1</span>) {
            ngx_log_error(NGX_LOG_EMERG, <span class="built_in">log</span>, ngx_errno, <span class="string">"close() failed"</span>);
            <span class="keyword">return</span> NGX_ERROR;
        }
    }

    <span class="keyword">return</span> NGX_OK;
}
</code></pre><p>守护进程指的是后台运行不与任何控制终端相联的进程，许多网络服务器都作为守护进程运行。那么，什么样的进程才是守护进程呢？2种方法:</p>
<pre><code><span class="bullet">1. </span>这个进程是“富二代“，由内核无终端启动;
<span class="bullet">2. </span>是靠自己后天努力，这个后天努力需要借助setid的帮助，新建一个会话，这样这个进程就成老大了，而且不受任何终端控制。
</code></pre><p>注释已经写的很详细了，总结一下就是以下几步。</p>
<pre><code><span class="bullet">1. </span>fork一个daemon进程，退出前台进程。
<span class="bullet">2. </span>setsid 让daemon彻底脱离控制终端（如果没用这步的话，就会造成终端一退出，进程也就退了）
<span class="bullet">3. </span>umask(0)
<span class="bullet">4. </span>不让他输入输出
<span class="bullet">5. </span>改变目录，避免父进程工作目录的影响（nginx没做）
<span class="bullet">6. </span>关闭没用的fd
</code></pre><p>这个是APUE中提到的6步。当然，也有人建议进行第二次fork，二次fork的原因是不让进程重新被终端控制。是这样的，如果一个进程是一个不属于任何一个终端的会话组的首进程，当这个进程打开终端的时候，系统就会为他分配一个终端，这样就惨了，它又要受终端控制了(一个会话组的首进程如果不属于任何终端，则该进程打开终端时会被分配终端，一个会话如果属于某个终端，就会有一个前台进程组)，也就做不成守护进程了。不过要是二次fork的话，daemon A fork 出来 daemon B，这个daemon B不是会话首进程，就不会被分配到终端控制了。但是nginx没做，我觉得可能是因为nginx不会作类似操作吧。<br>注：不过2次fork，要记得Sighnal(SIG_HUP, SIG_IGN)，否则daemon A作为首进程退出的时候，会告诉所有的小弟(包括B了)。</p>
<p>具体的守护进程参考UNP和APUE中的资料。</p>
<h3 id="5-_ngx_master_process_cycle，mater干的活">5. ngx_master_process_cycle，mater干的活</h3><p>在完成main中的初始化后，我们的“初始化”旅程到了结尾，热身结束，开始重点。到调用这个函数的时候，nginx还是只有master进程的，作为master进程的开始工作，最终要的就是启动“work”进程。其实，很多软件都有master，work的概念，诸如Hadoop的jobtracker、tasktracker。master处理和用户的交互，然后work专心的去做业务，这样的话，master可以想象为一个管理者，work则是真正的工人。</p>
<p>屏蔽一下干扰</p>
<pre><code>sigemptyset(&amp;<span class="operator"><span class="keyword">set</span>);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGCHLD);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGALRM);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGIO);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, SIGINT);</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_RECONFIGURE_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_REOPEN_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_NOACCEPT_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_TERMINATE_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_SHUTDOWN_SIGNAL));</span>
sigaddset(&amp;<span class="operator"><span class="keyword">set</span>, ngx_signal_value(NGX_CHANGEBIN_SIGNAL));</span>

if (sigprocmask(SIG_BLOCK, &amp;<span class="operator"><span class="keyword">set</span>, <span class="literal">NULL</span>) == -<span class="number">1</span>) {
    ngx_log_error(NGX_LOG_ALERT, cycle-&gt;<span class="keyword">log</span>, ngx_errno,
                  <span class="string">"sigprocmask() failed"</span>);</span>
}

sigemptyset(&amp;<span class="operator"><span class="keyword">set</span>);</span>
</code></pre><p>最开始的工作就是做一些信号处理的工作，首先将系统信号，nginx自定义的信号加入’sigset_t set;’信号集中，然后调用sigprocmask进行信号的屏蔽，函数为 ‘sigprocmask(SIG_BLOCK, &amp;set, NULL)’ ，第一个参数为SIG_BLOCK意思就是按照set屏蔽信号，也就是说把之前通过 ‘sigaddset’ 的10个信号都屏蔽掉了，以防止在fork Work的过程中发生的意外。</p>
<h3 id="6-_master开始工作">6. master开始工作</h3><p>master进程在屏蔽完信号干扰后，便调用了ngx_start_worker_processes来启动worker进程，这个函数的核心就是一个for循环，调用ccf-&gt;worker_processes次ngx_spawn_process函数，fork了ccf-&gt;worker_processes个worker。</p>
<p>ngx_spawn_process则是真正fork worker的函数。</p>
<pre><code>pid = fork();

switch (pid) {

<span class="keyword">case</span> -<span class="number">1</span>:
    ngx_log_error(<span class="type">NGX_LOG_ALERT</span>, cycle-&gt;log, ngx_errno,
                  <span class="string">"fork() failed while spawning \"%s\""</span>, name);
    ngx_close_channel(ngx_processes[s].channel, cycle-&gt;log);
    <span class="keyword">return</span> <span class="type">NGX_INVALID_PID</span>;

<span class="keyword">case</span> <span class="number">0</span>:
    ngx_pid = ngx_getpid();
    <span class="keyword">proc</span>(cycle, data);
    <span class="keyword">break</span>;

default:
    <span class="keyword">break</span>;
}
</code></pre><p>又是熟悉的fork了，能进入case 0的就是worker进程。而master进程则继续ngx_master_process_cycle，在worker都被master fork出来之后，master就要正常开始他的工作了</p>
<pre><code><span class="keyword">for</span> ( ;; ) {
<span class="comment">// ... </span>
    sigsuspend(&amp;<span class="keyword">set</span>);
<span class="comment">// ...</span>
}
</code></pre><p>这个就是master的工作框架，简单吧？就是休眠，等信号，做事儿，再休眠，等信号，做事儿。sigsuspend(&amp;set);就是让进程休眠，直到有信号的时候，去处理。</p>
<p>在main开始初始化的时候，就通过’ngx_init_signals’对每个信号的回调函数进行<a href="./#siginit">初始化</a>，也就是说，每次信号来了都会调用 ‘ngx_signal_handler’ 去设全局的flag，如果有信号了，master的 ‘ngx_master_process_cycle’ 就会对这些全局flag进行对应的处理。</p>
<p>最后，总结一下master的工作，就是先把信号都屏蔽了，然后去fork worker进程，fork完work以后，master就进入信号处理的循环了，利用sigsuspend等信号，等到信号就处理，处理完了再sigsusoend，如此循环，完成伟大的幕后工作。</p>
<h3 id="7-_ngx_worker_process_cycle，worker开始工作">7. ngx_worker_process_cycle，worker开始工作</h3><p>worker开始工作的真正时候，应该是在master调用ngx_spawn_process之后的，master传入的proc参数就是ngx_worker_process_cycle函数指针，再回到刚才master中那个fork的过程，case 0的时候调用了proc(cycle, data);也就是相当与调用了ngx_worker_process_cycle，这样worker的工作也马不停蹄的开始了。</p>
<p>首先，惯例，进行初始化，ngx_worker_process_init，这里面就包括了自身的初始化，还有去除一下从master过来的没用的东西，比如sigprocmask一下，把之前master的屏蔽掉信号都开启了。这样，才能对master的信号进行处理，以便完成master和work的进程间的通信。</p>
<p>然后就开始真正的工作了，也是一个大循环。</p>
<pre><code><span class="keyword">for</span> ( ;; ) {
<span class="comment">// ... </span>
    ngx_process_events_and_timers(cycle)
<span class="comment">// ...</span>
}
</code></pre><p>到此worker的框架也就这样了，然后for循环的底部会有一些对master发来的信号的处理。</p>
<p>至此，master和worker的初始化工作以及基本的框架算是完了，经过上面的学习以后，发现对nginx的整个流程有了一个大概的认识。学习初始化的过程中，我学到了daemon，多进程，信号处理等基本知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>最近，开始学习nginx的代码，大致根据<a href="http://www.alidata.org/archives/category/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8">阿里数据平台</a>的一些文章，加上Tengine 2.0的代码来看的。这次看代码主要是了解一下nginx的基本框架和主要工作流程。<br>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://yikun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JNI调试方法]]></title>
    <link href="http://yikun.github.io/2013/02/27/gdb-record/"/>
    <id>http://yikun.github.io/2013/02/27/gdb-record/</id>
    <published>2013-02-26T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Remote_Debug_jni_Code">Remote Debug jni Code</h2><a id="more"></a>
<p>1.Start your java application, set the breakpoint in java before call jni function</p>
<pre><code>java -Xdebug -Xrunjdwp:<span class="variable">transport=</span>dt_socket,<span class="variable">address=</span><span class="number">6666</span>,<span class="variable">server=</span>y,<span class="variable">suspend=</span>y com.kero.test.HelloJNI
</code></pre><p>2.Look up the pid using top, ps, …</p>
<pre><code><span class="keyword">ps</span> -ef |<span class="keyword">grep</span> <span class="keyword">com</span>.kero.test.HelloJNI
</code></pre><p>3.Start gdb with this pid</p>
<pre><code>gdb -<span class="tag">p</span> pidnum
</code></pre><p>or<br>    gdb -p $(ps -ef |grep com.kero.test.HelloJNI |grep -v ‘grep’|awk ‘{print $2}’)</p>
<p>4.Attach your program code</p>
<pre><code>dir XXX<span class="regexp">/HelloJNI/</span>
</code></pre><p>5.Debug as usual using gdb</p>
<pre><code><span class="tag">b</span> function_name_XXX
</code></pre><p>6.Continue in java</p>
<p>Now, you will it will stop in c code where you set breakpoint.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Remote_Debug_jni_Code">Remote Debug jni Code</h2>]]>
    
    </summary>
    
      <category term="Java" scheme="http://yikun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[岁月如梭, 我的2012]]></title>
    <link href="http://yikun.github.io/2012/12/27/2012Conclusion/"/>
    <id>http://yikun.github.io/2012/12/27/2012Conclusion/</id>
    <published>2012-12-26T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>又是一年岁末时，2012对我来说，确实算是比较“丰满”的一年。从年初的嵌入式培训，到上半年的比赛准备，中间还夹杂着高密度的期末考试，国创的结题答辩，之后，去上海的正式比赛，回来之后保研的事情，一直到最后的实习。这一年，算是成长最快以及收获最多的一年，就按照顺序一一道来吧。<br><a id="more"></a></p>
<h3 id="年初的嵌入式培训"><strong>年初的嵌入式培训</strong></h3><p>说实话，嵌入式比赛应该是我准备的最充分的也是最重视的比赛，首先这个比赛也算是大学阶段的最后一次了，其次比赛的结果也会是间接影响我未来的走向：工作还是上研。年初，记得很清楚，初十，校队的12人就已经全部到老校区开始了培训。我们住在留学生的宿舍，那宿舍旧的我们无语凝咽了，除了暖气，没有一样符合这个时代的特征，就是那种五六十年代的楼层。实验室的条件还算好，本来在主楼，最后到新科技楼付老师的实验室去了。每天的内容就是：想题目。想完题目，PPT答辩，老师点评，1-2天一个循环。那时候真是感觉自己的创意都被挖干净了，而且我们大家总是进入了怪圈，3D投影，虚拟现实，感觉还是限制在往届的思路中。时间过的很快，马上就开学了，题目基本还是没怎么完全定下。</p>
<h3 id="嵌入式比赛进行时"><strong>嵌入式比赛进行时</strong></h3><p>到了开学，3月份去了一次上海，把平台拿回来的之后，基本上大家都住在新校区的实验室了，F520，估计一辈子也不会忘记这个实验室吧。每天的生活就是实验室和餐厅的两点一线，为什么没有宿舍？因为我们已经都扎根实验室了，在实验室买了气垫床，因为有空调的原因还是在实验室过的比较惬意，至少在夏天酷暑之时，免去了大汗淋漓的痛苦。晚上2点多睡，早上不到8点就起，其实我们也不想起那么早，因为实验室有女生啊，女生都是不熬夜的但是早起的生活规律的学霸呀，记得有次比较夸张，看到太阳从工训中心快升起來了，赶紧睡觉了，可过了一会，刚升起来了，女生来了，我们就都起来了。</p>
<p>那时候特别好玩，我和君朋，雨舟起床的时候都是不会互相叫的，我是觉得晚上睡得挺晚的，大家都听辛苦的，自己起来就多干点活吧。另外，因为夏天大家也就光穿一件就睡了，往往早上起来女生进来的时候，那就是个春光乍泄的景色。有时候也互相拍个照片留个“纪念”。所以，这样一来，大家都把闹铃弄得早于女生进实验室。可是君朋大神的闹钟总是叫不起他，一般情况下就是，他的闹钟把我们都叫起来了，然后我们把他闹钟关了。然后君朋起来的时候，总是睡意朦胧的问我，几点起的？我说，女生来之前……然后君朋看看我，不说话了。哈哈哈哈。</p>
<p>晚上睡的最晚的是子兼大神，他是信安那边的，比我们低一级，基本上就是不睡，然后在我们睡觉的时候，总能听见他在骂着什么，基本上也就一个字“艹”，估摸着是bug卡住了吧。我和君朋就叫他“艹艹哥”了。嵌入式的几组里面，进展最快的应该是谢老师的那一组，谢老师给他们安排的比较紧，一步一步，到最后也就比较规律了，不像我们，像没头苍蝇一样撞来去，云阳不停地调飞控，我们背后就是四轴飞行器螺旋桨不停地旋转，只有我们一组算是基本上纯软件的项目，所以，当时是真心比较心虚，毕竟别的组的实物都摆出来了，我们还是干巴巴的代码，图形都没有做好最后渲染，确实有点急了，君朋的FPGA的弄的也特别紊乱，还好有之前君朋做过FPGA的东西，也算是慢慢地有些进展了。</p>
<p>比赛中夹杂着高密度的期末考试，合起来大概有快10门课，那时候也顾不上那么多了，毕竟还是把比赛放在第一位了，基本上就是上午考的复习一晚上，下午考的复习一上午。不过还算是比较理想，至少还都在80左右。对于我这种在成绩上没什么打要求的来说，已经不错了。这时候就大概5月份了，5月的时候又有一件比较重要的事情就是国家大学生创新性实验计划的结题。</p>
<h3 id="国创项目结题答辩"><strong>国创项目结题答辩</strong></h3><p>因为之前就想到过会遇到这个情况，所以，在年初的时候，就和DC说好，把服务器做好，然后，我这边Android端也基本上没什么问题了，大概3月多就基本全部搞定了。之前，中期答辩的时候得的是优，所以也没什么大的压力，所以感觉我作为负责人还是安排的比较合理的，嘿嘿。到后面就是写写结题报告，然后就答辩了。答辩的时候很幸运的进了复赛，最后的成绩还不错，第六名，如果提前一名，就可以有一个保研资格，谢胖也就不用现在苦逼的去考研了。话说回来，也快到考研了， 倒计时也是个位数，希望付出都有收获吧。</p>
<h3 id="The_Trip_of_Shanghai"><strong>The Trip of Shanghai</strong></h3><p>7月中旬的时候，就去上海了，票不好买，学校坑爹的定的硬座，付老师和任老师和我们一起，累死了快到宾馆，到了宾馆也没怎么休息，中午吃了饭，就赶紧收拾收拾调试平台了，然后雨舟去抽签了，付老师带队去的，付老师走前说了一句话：要是抽到明天，也就别睡了，直接通宵准备答辩吧。突然，我心中就有种不详的预感，雨舟大神总是一个充满着惊喜的人物。</p>
<p>果不起然，雨舟大神没让我们失望，第二天早上第三队！跪了。然后就开始准备，到晚上11点多的时候，在付老师的房间，来了一次四个队伍的整体模拟答辩，然后就1点多了，我们回到自己的房间，按着老师的意思修改了下，就准备睡了，实在困的不行了，一个电话想起，老师说凌晨2点半的时候再过去答辩一次。我们回到自己的房间，我检查了下，软件和驱动部分没问题，然后君朋就开始调手势的指环了，我就在改ppt。<br>突然，君朋告诉我FPGA坏了，我靠，我当时那是一身冷汗啊，跪的心都有了，脑海里呈现的就是3、4个月的辛苦白费了，不过我还是比较镇定的说，再检查一下，看看有啥问题，其实心中早已经是翻江倒海了。君朋把所有线都拔了，我说你重新插一下，看看是不是短路了。之后，把程序重新烧了一遍就好了。我那个心呀，终于放下了，也基本不困了，真心是吓清醒了。</p>
<p>然后最后一次答辩老师就比较细致了，包括应该怎么修改怎么注意细节。最后主要是一些鼓励我们的话，然后就四点快五点了，我们的ppt还算比较好没什么大的修改，付老师那组的ppt听说是谢老师跟他们改的通宵。我回去，君朋先睡半小时，说我改好ppt就叫他，我改好ppt大概就5点多了，看着君朋睡的香，我都不忍心叫他了，哈哈。没办法，因为还有几个小时就要去答辩了，所以还是叫他起来了。</p>
<p>我就睡觉了，睡了一个小时，就起来了，君朋还在调试程序，收拾了下东西，洗了个澡，就准备出发了。出发的时候君朋告诉我，2对指环（有一对备份），其中有一个短路了。我突然就想到了不知道哪位前辈对与程序说的一句名言，“只要你觉得会出bug的地方，就一定会出bug”。还别说陕西地方邪，我觉得上海也挺邪的。到了交大的电信大楼，真心出错了，失效了，复位也没用。眼看着就要开始答辩了，君朋居然把430的程序又重新下了一遍，就快开始的时候，君朋说，ok了，我和雨舟算是放心了，雨舟在填功能测试表，我去弄ppt了。之后的答辩还算比较不错，演示效果也算是正常发挥了。</p>
<p>回到宾馆，繁忙了半年的身心，终于放松了。在宾馆，我跟君朋说，希望回到西安，就能开始骄奢淫逸的生活了。最后的结果还算不错了，1个国一，3个国二，我们是国二。这样，我靠着竞赛的成绩，也就被保研了。</p>
<p>之后，我们在上海转了转，后面，还去杭州转了一圈，主要就去了西湖，时间安排的太紧，加上天气比较热，所以，也没觉得有什么特别美好的地方。惬意的是在西湖旁的回廊中的微风，西湖游行的客船，还有三潭映月的水畔。</p>
<p>别了上海，又回到西安，大学的最后一年，就开始了。</p>
<h3 id="Intern_in_IBM"><strong>Intern in IBM</strong></h3><p>比较幸运吧，10月初的时候，在大街网上，收到了一个面试邀请，然后经过邮件面试，电话面试，两轮现场面试，终于拿到了实习的offer。这算是我第一份offer吧，上学期自己也确实准备过一些实习的面试，不过因为准备的不充分，深受打击，这次抱着试一试的态度，狠下心来，好好准备，意外的收获。在IBM 2个月了收获还算比较多，主要方面就是修改一些bug，还有一些性能测试。主要用shell和java比较多。</p>
<p>之前，一直在学校，确实没有工作方面的经验，不过和自己的想象还比较相似。不过，工作比我想象的稍微忙碌一些，我常常说的是，上班竞赛节奏，下班保研节奏。实习会持续到明年的6月左右，时间还长。后面再认真总结。</p>
<h3 id="Conclusion"><strong>Conclusion</strong></h3>]]></content>
    <summary type="html">
    <![CDATA[<p>又是一年岁末时，2012对我来说，确实算是比较“丰满”的一年。从年初的嵌入式培训，到上半年的比赛准备，中间还夹杂着高密度的期末考试，国创的结题答辩，之后，去上海的正式比赛，回来之后保研的事情，一直到最后的实习。这一年，算是成长最快以及收获最多的一年，就按照顺序一一道来吧。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MarkDown格式备注]]></title>
    <link href="http://yikun.github.io/2012/12/26/MarkDown-geshibeizhu/"/>
    <id>http://yikun.github.io/2012/12/26/MarkDown-geshibeizhu/</id>
    <published>2012-12-25T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md" target="_blank" rel="external">查看这里</a>」—By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a><br><a id="more"></a><br><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown:_Basics_（快速入门）">Markdown: Basics （快速入门）</h1><p>此页提供了 Markdown 的简单概念， <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" title="Markdown Syntax" target="_blank" rel="external">语法说明</a> 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。</p>
<p>其实直接试试看也是一个很不错的方法， <a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown Dingus" target="_blank" rel="external">Dingus</a> 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。</p>
<h2 id="段落、标题、区块代码">段落、标题、区块代码</h2><p>一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。</p>
<p>Markdown 支持两种标题的语法，<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），Atx 形式在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶。</p>
<p>区块引用则使用 email 形式的 ‘<code>&gt;</code>‘ 角括号。</p>
<p>Markdown 语法:</p>
<pre><code>A First Level Header
====================
A Second Level Header
<span class="comment">---------------------</span>

Now <span class="keyword">is</span> <span class="keyword">the</span> <span class="property">time</span> <span class="keyword">for</span> all good men <span class="keyword">to</span> come <span class="keyword">to</span>
<span class="keyword">the</span> aid <span class="keyword">of</span> their country. This <span class="keyword">is</span> just a
regular <span class="property">paragraph</span>.

The quick brown fox jumped <span class="keyword">over</span> <span class="keyword">the</span> lazy
dog's <span class="keyword">back</span>.
<span class="comment">### Header 3</span>

&gt; This <span class="keyword">is</span> a blockquote.
&gt; 
&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="property">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> blockquote.
&gt;
&gt; <span class="comment">## This is an H2 in a blockquote</span>
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="variable">&lt;h1&gt;</span>A First Level Header<span class="variable">&lt;/h1&gt;</span>
<span class="variable">&lt;h2&gt;</span>A Second Level Header<span class="variable">&lt;/h2&gt;</span>
<span class="variable">&lt;p&gt;</span>Now is the time <span class="keyword">for</span> <span class="literal">all</span> good men <span class="keyword">to</span> come <span class="keyword">to</span>
the aid of their country. This is just a
regular paragraph.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;p&gt;</span>The <span class="keyword">quick</span> brown fox jumped over the lazy
dog's back.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;h3&gt;</span>Header <span class="number">3</span><span class="variable">&lt;/h3&gt;</span>
<span class="variable">&lt;blockquote&gt;</span>
<span class="variable">&lt;p&gt;</span>This is a blockquote.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;p&gt;</span>This is the second paragraph <span class="keyword">in</span> the blockquote.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;h2&gt;</span>This is an H2 <span class="keyword">in</span> a blockquote<span class="variable">&lt;/h2&gt;</span>
<span class="variable">&lt;/blockquote&gt;</span>
</code></pre><h3 id="修辞和强调">修辞和强调</h3><p>Markdown 使用星号和底线来标记需要强调的区段。</p>
<p>Markdown 语法:</p>
<pre><code>Some <span class="operator">of</span> these <span class="keyword">words</span> *are emphasized*.
Some <span class="operator">of</span> these <span class="keyword">words</span> <span class="title">_are</span> emphasized also_.
Use <span class="constant">two</span> asterisks <span class="keyword">for</span> **strong emphasis**.
Or, <span class="keyword">if</span> you prefer, __use <span class="constant">two</span> underscores instead__.
</code></pre><p>输出 HTML 为:</p>
<pre><code><span class="variable">&lt;p&gt;</span>Some of these words <span class="variable">&lt;em&gt;</span>are emphasized<span class="variable">&lt;/em&gt;</span>.
Some of these words <span class="variable">&lt;em&gt;</span>are emphasized also<span class="variable">&lt;/em&gt;</span>.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;p&gt;</span>Use two asterisks <span class="keyword">for</span> <span class="variable">&lt;strong&gt;</span>strong emphasis<span class="variable">&lt;/strong&gt;</span>.
Or, if you prefer, <span class="variable">&lt;strong&gt;</span>use two underscores instead<span class="variable">&lt;/strong&gt;</span>.<span class="variable">&lt;/p&gt;</span>
</code></pre><h2 id="列表">列表</h2><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：</p>
<pre><code><span class="bullet">* </span>Candy.
<span class="bullet">* </span>Gum.
<span class="bullet">* </span>Booze.
</code></pre><p>加号：</p>
<pre><code><span class="bullet">+ </span>Candy.
<span class="bullet">+ </span>Gum.
<span class="bullet">+ </span>Booze.
</code></pre><p>和减号</p>
<pre><code>-<span class="ruby"> <span class="constant">Candy</span>.
</span>-<span class="ruby"> <span class="constant">Gum</span>.
</span>-<span class="ruby"> <span class="constant">Booze</span>.</span>
</code></pre><p>都会输出 HTML 为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Candy.<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Gum.<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Booze.<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记：</p>
<pre><code><span class="bullet">1. </span>Red
<span class="bullet">2. </span>Green
<span class="bullet">3. </span>Blue
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="tag">&lt;<span class="title">ol</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Red<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Green<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Blue<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><p>如果你在项目之间插入空行，那项目的内容会用 <code>&lt;p&gt;</code> 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。</p>
<pre><code>* A <span class="type">list</span> <span class="property">item</span>.
With multiple <span class="property">paragraphs</span>.

* Another <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span>.
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="variable">&lt;ul&gt;</span>
<span class="variable">&lt;li&gt;</span><span class="variable">&lt;p&gt;</span>A list item.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;p&gt;</span>With multiple paragraphs.<span class="variable">&lt;/p&gt;</span><span class="variable">&lt;/li&gt;</span>
<span class="variable">&lt;li&gt;</span><span class="variable">&lt;p&gt;</span>Another item <span class="keyword">in</span> the list.<span class="variable">&lt;/p&gt;</span><span class="variable">&lt;/li&gt;</span>
<span class="variable">&lt;/ul&gt;</span>
</code></pre><h3 id="链接">链接</h3><p>Markdown 支援两种形式的链接语法： <em>行内</em> 和 <em>参考</em> 两种形式，两种都是使用角括号来把文字转成连结。</p>
<p>行内形式是直接在后面用括号直接接上链接：</p>
<pre><code>This is an [<span class="link_label">example link</span>](<span class="link_url">http://example.com/</span>).
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is an <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span>&gt;</span>
example link<span class="tag">&lt;/<span class="title">a</span>&gt;</span>.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>你也可以选择性的加上 title 属性：</p>
<pre><code>This is an [<span class="link_label">example link</span>](<span class="link_url">http://example.com/ "With a Title"</span>).
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is an <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span> <span class="attribute">title</span>=<span class="value">"With a Title"</span>&gt;</span>
example link<span class="tag">&lt;/<span class="title">a</span>&gt;</span>.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>][<span class="link_reference">1</span>] than from
[<span class="link_label">Yahoo</span>][<span class="link_reference">2</span>] or [<span class="link_label">MSN</span>][<span class="link_reference">3</span>].

[<span class="link_reference">1</span>]:<span class="link_url"> http://google.com/ "Google"</span>
[<span class="link_reference">2</span>]:<span class="link_url"> http://search.yahoo.com/ "Yahoo Search"</span>
[<span class="link_reference">3</span>]:<span class="link_url"> http://search.msn.com/ "MSN Search"</span>
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;I <span class="built_in">get</span> <span class="number">10</span> times more traffic <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://google.com/"</span>
title=<span class="string">"Google"</span>&gt;Google&lt;/<span class="operator">a</span>&gt; than <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.yahoo.com/"</span>
title=<span class="string">"Yahoo Search"</span>&gt;Yahoo&lt;/<span class="operator">a</span>&gt; <span class="operator">or</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.msn.com/"</span>
title=<span class="string">"MSN Search"</span>&gt;MSN&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><p>title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：</p>
<pre><code>I start my morning with a cup of coffee and
[<span class="link_label">The New York Times</span>][<span class="link_reference">NY Times</span>].

[<span class="link_reference">ny times</span>]:<span class="link_url"> http://www.nytimes.com/</span>
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;I <span class="built_in">start</span> my morning <span class="operator">with</span> <span class="operator">a</span> cup <span class="operator">of</span> coffee <span class="operator">and</span>
&lt;<span class="operator">a</span> href=<span class="string">"http://www.nytimes.com/"</span>&gt;The New York Times&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><h3 id="图片">图片</h3><p>图片的语法和链接很像。</p>
<p>行内形式（title 是选择性的）：</p>
<pre><code>![<span class="link_label">alt text</span>](<span class="link_url">/path/to/img.jpg "Title"</span>)
</code></pre><p>参考形式：</p>
<pre><code>![<span class="link_label">alt text</span>][<span class="link_reference">id</span>]

[<span class="link_reference">id</span>]:<span class="link_url"> /path/to/img.jpg "Title"</span>
</code></pre><p>上面两种方法都会输出 HTML 为：</p>
<pre><code>&lt;img <span class="variable">src=</span><span class="string">"/path/to/img.jpg"</span> <span class="variable">alt=</span><span class="string">"alt text"</span> <span class="variable">title=</span><span class="string">"Title"</span> /&gt;
</code></pre><h3 id="代码">代码</h3><p>在一般的段落文字中，你可以使用反引号 <code>` </code> 来标记代码区段，区段内的 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>
<pre><code>I strongly recommend against <span class="keyword">using</span> any `&lt;blink&gt;` tags.

I wish SmartyPants used named entities <span class="keyword">like</span> `&amp;mdash;`
instead <span class="keyword">of</span> <span class="built_in">decimal</span>-encoded entites <span class="keyword">like</span> `&amp;<span class="preprocessor">#8212;`.</span>
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>I strongly recommend against using any
<span class="tag">&lt;<span class="title">code</span>&gt;</span>&amp;lt;blink&amp;gt;<span class="tag">&lt;/<span class="title">code</span>&gt;</span> tags.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
<span class="tag">&lt;<span class="title">p</span>&gt;</span>I wish SmartyPants used named entities like
<span class="tag">&lt;<span class="title">code</span>&gt;</span>&amp;amp;mdash;<span class="tag">&lt;/<span class="title">code</span>&gt;</span> instead of decimal-encoded
entites like <span class="tag">&lt;<span class="title">code</span>&gt;</span>&amp;amp;#8212;<span class="tag">&lt;/<span class="title">code</span>&gt;</span>.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 也一样会自动转成 HTML 实体。</p>
<p>Markdown 语法:</p>
<pre><code>If you want your page <span class="keyword">to</span> validate under XHTML <span class="number">1.0</span> Strict,
you've got <span class="keyword">to</span> put paragraph tags <span class="keyword">in</span> your blockquotes:

<span class="variable">&lt;blockquote&gt;</span>
<span class="variable">&lt;p&gt;</span>For example.<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;/blockquote&gt;</span>
</code></pre><p>输出 HTML 为：</p>
<pre><code><span class="variable">&lt;p&gt;</span>If you want your page <span class="keyword">to</span> validate under XHTML <span class="number">1.0</span> Strict,
you've got <span class="keyword">to</span> put paragraph tags <span class="keyword">in</span> your blockquotes:<span class="variable">&lt;/p&gt;</span>
<span class="variable">&lt;pre&gt;</span><span class="variable">&lt;code&gt;</span>&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
<span class="variable">&lt;/code&gt;</span><span class="variable">&lt;/pre&gt;</span>
</code></pre><h3 id="公式">公式</h3><p>质能方程：</p>
<pre><code><span class="xml"></span><span class="variable">$E</span><span class="xml">=mc</span><span class="keyword">^2</span><span class="xml">$</span>
</code></pre><p>$E=mc^2$</p>
<p>余弦定理：</p>
<pre><code>$<span class="string">\cos</span> <span class="number">2</span><span class="string">\theta</span> = <span class="string">\cos^2</span> <span class="string">\theta</span> - <span class="string">\sin^2</span> <span class="string">\theta</span> =  <span class="number">2</span> <span class="string">\cos^2</span> <span class="string">\theta</span> - <span class="number">1</span>$
</code></pre><p>$\cos 2\theta = \cos^2 \theta - \sin^2 \theta =  2 \cos^2 \theta - 1$</p>
<p>插入方程组（注意多行公式结尾\\需要打成\\，可能是因为markdown会自动转义第一个\）：</p>
<pre><code><span class="command">\begin</span><span class="special">{</span>aligned<span class="special">}</span>
<span class="command">\dot</span><span class="special">{</span>x<span class="special">}</span> <span class="special">&amp;</span> = <span class="command">\sigma</span>(y-x) <span class="command">\\</span><span class="command">\
</span><span class="command">\dot</span><span class="special">{</span>y<span class="special">}</span> <span class="special">&amp;</span> = <span class="command">\rho</span> x - y - xz <span class="command">\\</span><span class="command">\
</span><span class="command">\dot</span><span class="special">{</span>z<span class="special">}</span> <span class="special">&amp;</span> = -<span class="command">\beta</span> z + xy
<span class="command">\end</span><span class="special">{</span>aligned<span class="special">}</span>
</code></pre><p>\begin{aligned}<br>\dot{x} &amp; = \sigma(y-x) \\<br>\dot{y} &amp; = \rho x - y - xz \\<br>\dot{z} &amp; = -\beta z + xy<br>\end{aligned}</p>
<p>插入矩阵：</p>
<pre><code><span class="command">\begin</span><span class="special">{</span>bmatrix<span class="special">}</span>
1 <span class="special">&amp;</span> 2<span class="command">\\</span><span class="command">\
</span>3 <span class="special">&amp;</span> 4
<span class="command">\end</span><span class="special">{</span>bmatrix<span class="special">}</span>
</code></pre><p>\begin{bmatrix}<br>1 &amp; 2\\<br>3 &amp; 4<br>\end{bmatrix}</p>
<p>对于Markdown有转换冲突的，可以使用<code>rawblock</code>将公式扩起来(百分号为<code>%</code>)：</p>
<pre><code>{百分号 raw 百分号}
$$
<span class="string">\left(</span> <span class="string">\sum_{k=1}^n</span> a_k b_k <span class="string">\right)^2</span> <span class="string">\leq</span> <span class="string">\left(</span> <span class="string">\sum_{k=1}^n</span> a_k^<span class="number">2</span> <span class="string">\right)</span> <span class="string">\left(</span> <span class="string">\sum_{k=1}^n</span> b_k^<span class="number">2</span> <span class="string">\right)</span>
$$
{百分号 endraw 百分号}
</code></pre>
$$
\left( \sum_{k=1}^n a_k b_k \right)^2 \leq \left( \sum_{k=1}^n a_k^2 \right) \left( \sum_{k=1}^n b_k^2 \right)
$$
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/basics.md">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/basics.md">查看这里</a>」—By @<a href="http://twitter.com/riku">riku</a><br>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://yikun.github.io/2012/12/21/Hello-World/"/>
    <id>http://yikun.github.io/2012/12/21/Hello-World/</id>
    <published>2012-12-20T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>今天，是世界末日。同时，末日也是新生。<br><a id="more"></a><br>用Github建立了一个博客，希望可以坚持下来。</p>
<p>专心做好一件事，慢慢来，比较快。</p>
<p>See also, My old blog in csdn.<a href="http://blog.csdn.net/kerenigma" target="_blank" rel="external">here</a></p>
<p><strong><em>Hello World</em></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天，是世界末日。同时，末日也是新生。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux Record]]></title>
    <link href="http://yikun.github.io/2012/12/06/linux-record/"/>
    <id>http://yikun.github.io/2012/12/06/linux-record/</id>
    <published>2012-12-05T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="User_Group_Password_Set">User Group Password Set</h2><pre><code>useradd –d <span class="regexp">/home/</span>youtpath yourname
passwd  yourname
groupadd yourgroup
chown <span class="string">yourname:</span>yourgroup <span class="regexp">/home/</span>yourname
</code></pre><p>if accuont is exist, try to using <code>usermod -d /home/yourpath -U yourname</code></p>
<h2 id="IP_set">IP set</h2><h3 id="In_Ubuntu">In Ubuntu</h3><p>(/etc/network/interfaces)</p>
<pre><code><span class="comment"># Dynamic IP</span>
<span class="title">auto</span> eth0
iface eth0 inet dhcp

<span class="comment"># Static IP </span>
auto eth0
iface eth0 inet static
address <span class="number">192.168.33.201</span>
netmask <span class="number">255.255.255.0</span>
gateway <span class="number">192.168.33.1</span>
</code></pre><p>then, in shell(also, need sudo):</p>
<pre><code>ifconfig eth0 <span class="preprocessor">down</span>
ifconfig eth0 <span class="preprocessor">up</span>
</code></pre><p>last, try to <code>ifconfig</code> to check result, perhaps you need using <code>/etc/init.d/networking restart</code> to restart all network services</p>
<h3 id="In_RedHat">In RedHat</h3><p>you need modify 3 files:</p>
<pre><code><span class="regexp">/etc/</span>sysconfig/network
<span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/</span>ifcfg-eth0
<span class="regexp">/etc/</span>resolv.conf
</code></pre><p>1./etc/sysconfig/network</p>
<pre><code><span class="setting">NETWORKING=<span class="value"><span class="keyword">yes</span></span></span>
<span class="setting">NETWORKING_IPV6=<span class="value"><span class="keyword">no</span></span></span>
<span class="setting">HOSTNAME=<span class="value">kero</span></span>
<span class="setting">GATEWAY=<span class="value"><span class="number">192.168</span>.<span class="number">1.1</span></span></span>
</code></pre><p>2./etc/sysconfig/network-scripts/ifcfg-eth0</p>
<pre><code><span class="setting">DEVICE=<span class="value">eth0                                </span></span>
<span class="setting">NETMASK=<span class="value"><span class="number">255.255</span>.<span class="number">255.0</span>             </span></span>
<span class="setting">IPADDR=<span class="value"><span class="number">192.168</span>.<span class="number">1.88</span>             </span></span>
<span class="setting">BOOTPROTO=<span class="value">static                      #【none | static | bootp | dhcp】</span></span>
<span class="setting">ONBOOT=<span class="value"><span class="keyword">yes</span>                            #【<span class="keyword">yes</span> | <span class="keyword">no</span>】引导时是否激活设备</span></span>
<span class="setting">DNS1=<span class="value"><span class="number">211.99</span>.<span class="number">25.1</span>                      #域名解析服务器</span></span>
<span class="setting">PEERDNS=<span class="value"><span class="keyword">yes</span></span></span>
</code></pre><p>3./etc/resolv.conf</p>
<pre><code><span class="title">nameserver</span> <span class="number">211.99.25.1</span>          <span class="comment">#DNS配置 同2中的 【DNS1=211.99.25.1 】</span>
</code></pre><p>4.Resart</p>
<p>   /sbin/ifdown eth0<br>   /sbin/ifup eth0<br>   /etc/init.d/network restart</p>
<h2 id="SSH">SSH</h2><pre><code>sudo apt-get <span class="operator"><span class="keyword">install</span> openssh-<span class="keyword">server</span></span>
</code></pre><h2 id="find">find</h2><pre><code>find ./ -name '<span class="keyword">*</span>.<span class="keyword">*</span>' 
</code></pre><h2 id="du">du</h2><pre><code>du -h --<span class="built_in">max</span>-<span class="built_in">depth</span>=<span class="number">1</span>
</code></pre><h2 id="Virtual_IP">Virtual IP</h2><ol>
<li><p>Using <code>ifconfig</code> check your IP and eth</p>
<p> eth1      Link encap:Ethernet  HWaddr 08:00:27:71:DA:8C</p>
<pre><code>inet <span class="string">addr:</span>XXX.XXX.XXX.250  <span class="string">Bcast:</span>XXX.XXX.XXX.255  <span class="string">Mask:</span><span class="number">255.255</span>.255.0
inet6 <span class="string">addr:</span> <span class="string">fe80:</span>:<span class="string">a00:</span><span class="number">27</span><span class="string">ff:</span><span class="string">fe71:</span>da8c/<span class="number">64</span> <span class="string">Scope:</span>Link
UP BROADCAST RUNNING MULTICAST  <span class="string">MTU:</span><span class="number">1500</span>  <span class="string">Metric:</span><span class="number">1</span>
RX <span class="string">packets:</span><span class="number">782</span> <span class="string">errors:</span><span class="number">0</span> <span class="string">dropped:</span><span class="number">0</span> <span class="string">overruns:</span><span class="number">0</span> <span class="string">frame:</span><span class="number">0</span>
TX <span class="string">packets:</span><span class="number">91</span> <span class="string">errors:</span><span class="number">0</span> <span class="string">dropped:</span><span class="number">0</span> <span class="string">overruns:</span><span class="number">0</span> <span class="string">carrier:</span><span class="number">0</span>
<span class="string">collisions:</span><span class="number">0</span> <span class="string">txqueuelen:</span><span class="number">1000</span>
RX <span class="string">bytes:</span><span class="number">77624</span> (<span class="number">75.8</span> KiB)  TX <span class="string">bytes:</span><span class="number">14476</span> (<span class="number">14.1</span> KiB)
Base <span class="string">address:</span><span class="number">0xd240</span> <span class="string">Memory:</span>f0820000-f0840000
</code></pre></li>
<li><p>Set the Virtual IP, </p>
<p> ifconfig eth1:ha1 XXX.XXX.XXX.252 broadcast XXX.XXX.XXX.255 netmask 255.255.255.0 up</p>
</li>
</ol>
<p><code>eth1:ha1</code>, eth1:XXXX, XXXX is your virtual name, modifiy name what you want.</p>
<p><code>XXX.XXX.XXX.252</code>,  Virtual IP</p>
<p><code>XXX.XXX.XXX.255</code>, broadcast (Same as eth1 Bcast)</p>
<p><code>255.255.255.0</code>, netmask (Same as eth1 Mask)</p>
<p>Also, you can using <code>ifconfig eth1:ha1 XXX.XXX.XXX.252 broadcast XXX.XXX.XXX.255 netmask 255.255.255.0 down</code> shutdown Virtual IP</p>
<p>After it, you can using <code>ifconfig</code>, check result</p>
<pre><code><span class="string">eth1:</span>ha1  Link <span class="string">encap:</span>Ethernet  HWaddr <span class="number">08</span>:<span class="number">00</span>:<span class="number">27</span>:<span class="number">71</span>:<span class="string">DA:</span><span class="number">8</span>C
          inet <span class="string">addr:</span>XXX.XXX.XXX.252  <span class="string">Bcast:</span>XXX.XXX.XXX.255  <span class="string">Mask:</span><span class="number">255.255</span>.255.0
          UP BROADCAST RUNNING MULTICAST  <span class="string">MTU:</span><span class="number">1500</span>  <span class="string">Metric:</span><span class="number">1</span>
          Base <span class="string">address:</span><span class="number">0xd240</span> <span class="string">Memory:</span>f0820000-f0840000
</code></pre><ol>
<li>To ensure, Ip is unique, you could using arping to check</li>
</ol>
<p><code>arping -c 3 -I eth1 -s XXX.XXX.XXX.250 XXX.XXX.XXX.252</code></p>
<p><code>-c</code> is count, </p>
<p><code>-I</code> is your eth interface name, </p>
<p><code>-s XXX.XXX.XXX.250</code> is your now ip(source ip)</p>
<p><code>XXX.XXX.XXX.252</code> is the virtual ip you want to check</p>
<ol>
<li>If not active, you could using </li>
</ol>
<p><code>route add -host XXX.XXX.XXX.252 dev eth1:ha1</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>
<h2 id="User_Group_Password_Set">User Group Password Set</h2><pre><code>useradd –d <span class="regexp">/home/</span>youtp]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[从实践中一路走来]]></title>
    <link href="http://yikun.github.io/2012/11/17/congshijianzhongyiluzoulai/"/>
    <id>http://yikun.github.io/2012/11/17/congshijianzhongyiluzoulai/</id>
    <published>2012-11-16T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>又是一样的开学，又是一样的军训，仿佛我们入学的那天刚刚逝去，仿佛礼仪广场上的标语——“你们是中国电子信息科技未来的栋梁” 是为我们写的一样。可是，标语前面的称呼早已变成“ 2012级新同学”。<br><a id="more"></a><br>虽说自己学的不行，长的也不行，当真正成为学校里最大的一级时，也要负责地做一回学长。大学这四年，自己参加过一些比赛和实践活动，从星火杯到挑战杯，到国家大学生创新性实验计划，再到最后的全国大学生电子设计竞赛赛嵌入式系统邀请赛，也算是在竞赛路上磕磕碰碰的前行过。在这里，主要从竞赛的经历方面分享一下自己的路途与对大学认识的一些拙见。</p>
<p>大一，刚开学那阵子，大家好像延续了军训时期的斗志，都是充满斗志地打满了鸡血。希望加入各种各样的学生组织、社团、班委锻炼自己的能力，希望白天在图书馆、自习室争当学霸，希望晚上在篮球场上、操场上增强体质。当时的心态就是，要做一个德智体美劳全面发展的大学生！（好吧，好假，囧）</p>
<p>在刚入学的时候，就听说了通院科协是一个很锻炼人的组织，于是，招新的时候自信满满的去面试，很不幸，悲剧了，当时真心是感觉人生一下子灰暗了，真没言重，当时就是那么想的。还好通院科协的一些活动、讲座是面对全院的，我十分积极的参加各种各样的讲座、培训，就这样，学习了单片机和编程方面的基础知识 。</p>
<p>想想当时大一真是个鸡血少年，早上 6点多起床，去教室看看书，中午也不睡觉，就去图书馆。大一上学期什么也不懂，大学之前接触过一些编程但是都是很简单的，可以说基本不会；硬件方面也什么也不会，连烙铁都没有用过，开学没几个月就参加了大学的第一个比赛，星火杯。星火杯是学校内的比赛，很有西电的特色，主要就是软件、硬件、软硬结合、论文几个方面。</p>
<p>当时我们什么也不会，就按照电路图，买元件，焊电路，完成了我们的作品——电子百灵鸟。当时，特别特别兴奋，最终得了一个安慰奖。<br>大一下学期，科协让我们自己动手焊的单片机实验板。这个开发板也变成了我的“启蒙老师”，抱着电脑认真的学习郭天祥《十天学会单片机》，然后自己烧些程序在自己的开发板上。</p>
<p>刚开始的时候大家都有些像没头苍蝇，这时，可以适当地去听听讲座，参考一下长者的意见，只是参考，你应该有自己思想，追随自己的内心，走自己的路。另外，推荐大家读下开复老师的“当迷茫在大学里泛滥成灾”这篇文章。</p>
<p>大二的时候，自己算是入门了，因为特别喜欢编程，所以自己认真学习了 C和 C++，第二次星火杯可比第一次强多了，我们做了一个以公寓远程报修为功能核心功能的作品——基于 ZigBee网络的公寓自动化管理系统，最终得到了评委的肯定，获得校级一等奖。这次比赛算是大学里面第一个认真准备的比赛，开始的时候真心是什么都不会，只学过一些 C/C++，没用过MFC ，没用单片机做过系统，短短的 2个月，从 PC端的管理软件到学生端的交互终端，都是自己认真完成的，确实得到了锻炼。也许很多同学都会想“自己什么都不会，什么也没学过，自己可以吗？”其实大可不必担心，因为你会在你一点一滴的实践中逐渐成长。</p>
<p>在大二下学期恰好有个机会参加了陕西省挑战杯，由学校选拔参加的，基本上和星火杯的流程差不多，我们的作品也没有什么改变，只是完善了文档。文档其实是比赛中很重要的一个环节，好的文档确实能为你的作品添色不少。最终，拿了陕西省挑战杯的二等奖。其实大一大二的时候，就好似一个跳板，为之后打下基础。</p>
<p>大一大二的时候都比较纠结，很多人都纠结自己该怎么走完接下来的路，其实，我觉得吧，不管干什么，只要认真的一心一意的做下去，坚持下去都可以成为一个出色的人。</p>
<p>在大二的六月份左右，学校会组织申报“国家大学生创新创业实验计划项目”也就是我们平常简称的“国创”。通过“国创”的申请，学校会批给你们项目组一万元左右的资金去完成一个项目，时间期限是 1年，每个项目组三人。通过这个机会，你可以“免费”地阅读、购买到很多的书籍，这更是一个难得的机会去真正地接触一个项目从产生、管理、完成的整个过程。当时我们选择做的软件项目，主要是完成了条码扫描、社交分享、附近交易的一个Android 端的软件。很幸运的我们拿到了所有项目组的第六名 (前五能保研，恩，对，前五！杯具！ )。</p>
<p>其实，当时也真的不是很在意，因为那时候，已经在嵌入式比赛最后阶段，这个比赛全名叫做“全国大学生电子设计竞赛嵌入式邀请赛”，校队选拔相对比较严格、跨度时间比较长，基本是大三再加上大三暑假就搭进去了。这个比赛是我最投入，最用心也是得到最多锻炼的一个比赛。</p>
<p>2个多月，三轮选拔，从全校范围内 200多人中，选出了 12个来自不同学院的学生，组成 4队进行比赛。因为比赛平台的特殊性，是 Intel最新的CPU ，将FPGA芯片和 CPU集成在一起。从寒假开始，就选题，定题之后就开始完成作品了，每天真的是很充实。我们的题目是，室内交互设计游览系统，通过手上的一对指环，在家居场景中布置家具，体验游览家具设计，在 cpu中完成软件部分，在 FPGA中完成手势识别算法。因为新的东西比较多， Qt、图像引擎、物理引擎、图像识别、虚拟现实。从三月起基本每晚就睡的很晚，到最后比赛接近尾声的时候，基本上每天 3、 4点睡，早上 8点不到就起来了。每天睡的时候，都会和队友开玩笑，“大神们，赶紧睡吧，小心猝了”。比赛那几天更夸张，因为要去上海进行比赛坐火车，硬座一晚上基本没睡，第一天到上海没休息就去抽签，雨舟大神抽了个第二天早上的第三个，当时的心情就一个词儿——情何以堪。于是，第一天晚上也就没睡。那天夜里，突然 FPGA失灵了，当时吓了我们一身冷汗，当时脑海就是一片空白，心想“不是这么悲剧吧？”还好最后，把线重新插了下，又恢复了。付、谢、任三位带队老师特别负责（致敬！），晚上 3点多的时候，还在为我们把关答辩。回去的时候 4点多了，我修改 ppt完了就凌晨 5点了，老师让第二天答辩的人早点睡，因为是我答辩，于是我就可耻地睡去了，君朋大神活生生地一夜没睡，早上 6点多我起来的时候，看君朋还在调指环，鞠躬致敬！</p>
<p>第二天去比赛的时候，我们本来是第三个，第二个放弃了，我们又提前了一个，我们一去就开始准备。去上海的时候，我们准备了四个指环，两对，有一个短路了，当时我就想到一句话“所有你觉得可能出现问题的地方，就会出现问题”，当时也没想太多，比赛的时候，果不其然，悲剧了。那个没有备份的指环，程序跑飞了。君朋大神确实淡定，冷静地把程序重新烧了一遍，又恢复正常了，那就是一个心惊肉跳。最终演示的时候效果还不错，最后拿了国家二等奖，四队最终以一个一等奖，三个二等奖为比赛划上了句号。</p>
<p>我是这样一步一步走来的，当然上面的一些经历只是我个人的情况，刚入大学的你，应该有自己的道路。你需要清楚竞赛的路途上，不只有掌声和鲜花，或许也会有低靡，因为竞赛失利的人大有人在。不过，如果你真的喜欢竞赛带给你的锻炼与能力上的提高，而且在你深思熟虑过自己是否应该参加竞赛，如果确定要继续，那么坚持地做下去，不要在乎太多的功利，因为能力上的提高远远大于那些奖项。或许，你可以尝试从大一起就开始做自己的简历，每学期更新一次，看看自己是否有东西可写，是否比之前有些进步，哪怕只是简历上的一行。</p>
<p>最近看到过一段话，“在一定程度上，大一遇到什么水平的学长学姐，可以左右他大学的方向。请某些人高抬贵手，不要把你那些可笑的经验云云装的很像样的告诉他们，影响人家的认知，大学是他们自己的，走错了路，这个责任谁也担不起”。确实是这样，你需要谨慎地去面对那些“学长学姐”所谓的经验，就好像这篇文章一样，肯定会有不妥的地方，你需要保持一颗怀疑的心，大步向前。当然，如果你遇到了一些自己解决不了的问题，不妨请教一下长者，无论是学长、学姐、导员、老师，他们都会帮助你的。</p>
<p>大学是你们自己的，需要你们自己去探索，我们也只是起到抛砖引玉的作用，追随你自己的内心，走自己的路。准备好了吗？让你的大学流光溢彩吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又是一样的开学，又是一样的军训，仿佛我们入学的那天刚刚逝去，仿佛礼仪广场上的标语——“你们是中国电子信息科技未来的栋梁” 是为我们写的一样。可是，标语前面的称呼早已变成“ 2012级新同学”。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[渐变]]></title>
    <link href="http://yikun.github.io/2011/05/18/jianbian/"/>
    <id>http://yikun.github.io/2011/05/18/jianbian/</id>
    <published>2011-05-17T16:50:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>变，渐变，我在变，朋友在变，周围在变，都在变。<br><a id="more"></a><br>突然发现，就这样的大学快过去一半了，如果说真正的习惯了大学生活那也不为过。早上起床，已经练就了从物理的、生理的、心理的、合情合理的忽视闹钟。中午还是不怎么想睡觉，因为睡久了会有想吐的感觉。天气慢慢的炎热起来，可恶的太阳从早上就开始不停的晒。</p>
<p>和宿舍同学的关系也越来越和谐了，宿舍的孩子们最近也开始堕落了，天天晚上都在dota，每次看他们玩的时候总想到四个字，玩物丧志。当然，自己在他们玩的时候，也没做些什么有意义的事。甚至周六周日也和他们沦陷一番。</p>
<p>最近和娱乐有关的活动，除了对吃感兴趣外，真的什么也觉得没意思，游戏没心思玩，篮球很久没碰了，电影看一半就想睡觉了，上网看见人人上那些个无聊的状态就直接注销了，不想再上，今天又有急于联系的人，又解封了，我也真是可笑。</p>
<p>今天晚上，突发奇想到操场跑了几圈，在草坪上，休息的时候捡到一个手机，然后，高尚的还给人家，他还说要请我吃饭。囧不囧</p>
<p>最 近，各方面都还顺利，国家大学生创新性实验计划申上了，批1.2万的可用资金，这是第一次有那么多钱可以用吧，好好珍惜，项目期限，一年的时间。富士通的 初赛也通过了，也可以有个开发板可以免费用了，说不定十月的时候还有机会去次上海。世园会志愿者也选上了，暑假也可以充实起来了。</p>
<p>最近压力比较大的还是课内的东西还有六级，现在都是全裸状态。得赶紧补了</p>
<p>最近，也在关注一些实习生招聘的东西，突然觉得涉猎有些广泛了，android＆java  嵌入式  c&amp;c++，得精通一个才好。</p>
<p>有一个小小的目标就是大三暑假大四左右的时候，去创新工厂实习。可能android 和C++会成为蓝筹吧。所以，要专心技术基础了。</p>
<p>嗯。拿得起，放不下。是不是很失败啊。哈哈，不知道该怎么办。只怪时间不是优质的稀释液。</p>
<p>有2,3个月都没吃胡辣汤了，这周一定要回去吃！</p>
<p>嗯，就到这里吧。</p>
<p>Go on ! </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>变，渐变，我在变，朋友在变，周围在变，都在变。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[很久很久]]></title>
    <link href="http://yikun.github.io/2011/03/22/henjiuhenjiu/"/>
    <id>http://yikun.github.io/2011/03/22/henjiuhenjiu/</id>
    <published>2011-03-21T16:57:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>很久很久没有发过日志什么的了，生活越来越趋向于充实的平稳与平静。每天都在忙，不过有时候想想时间真是不知道怎么的就没了。 或许归根结底还是没好好的规划吧。<br><a id="more"></a><br>电装过去了，收音机响的那一刻也没有过多的惊喜，或许是种趋于成熟的平淡或者平凡吧。手也被烫伤了两处，突然让我想到一句话，被淹死的都是会游泳的。只是可惜了再也没有实践的机会了，名正言顺的逃避学术理论数十天的机会。</p>
<p>这学期的课都不是什么省油的灯，数电模电数据结构还算过得去电磁场与电磁波真是一门见不到底的学科，信号看着那些卷积积分傅立叶Z变换就头大。考试月也不 会轻松吧，更何况又是万恶的夏天。最近看些模拟技术的东西觉得好有兴趣，可是看着模电书里干巴巴的式子也顿时没了激情，这还是因为过于浮躁吧。</p>
<p>天气最近也是格外的变态，又听到了一些同学问类似于西安天气是不是一直这么怪的问题。我也是不知怎么回答的笑笑，天气也不归我管吧，是吧。</p>
<p> 大家也都在开始为着自己的事情奋斗了，拼命GRE奋斗雅思的人也不少，像我吧，这种飘摇不定的不知上研还是工作，只是一直在学着，51完了430，430中间又杀出个cortex M3，无奈又转战ARM了。就等着厚积薄发，独孤一掷了吧。</p>
<p>慢慢的，一些事情和能力也渐渐的得到了认可，自己也有了那么几分信心。 当然，还是时常被一些繁琐的事困扰着，侵略着不多的自由。还好听说明天可能就发布上线了，也没我这个打酱油的什么也不会的美工什么事了，也算了却了一桩心 事吧。不过这些时间也认识了不少强人，自己也学到了一些UI方面的东西。</p>
<p>有句话说的好，穷则独善GPA，达则兼顾GDP。有时候也翻翻墙看看世界，和同学交流一下真相什么的也挺开心的。最近地球不太安稳，一会地震一会军事冲突的，渐渐的发现自己有些锁闭了，所以开始坚持每天看看新浪，也有了个微博叫Keroenigma。</p>
<p>前几天还看见同学说，大学找到媳妇就工作，找不到就安心上研。这也不失为一个好办法，要不我也这样？其实我还是偏重于工作一些吧。 有些事情，很久，很久。还是没有忘记，或许就像一个划伤，虽然不疼了，但是疤还在那，永远也不退去，都是写死亡的细胞却永远不能消失殆尽。慢慢的真的是越 来越远了。或许这也是没什么办法的无能为力吧。每当想起了就想着，有些事情过去了就让他过去了吧，也没有什么时间和机会去留给我去后悔。</p>
<p>时间啊时间，又是时间。如果要是时间多点，哦，没有如果。</p>
<p>开始学车了，也还算顺利，倒库移库的一直在练。</p>
<p>四级也坎坷的裸过了，六级好好准备吧。</p>
<p>三月的最后几天了，很关键吧。一个人发现自己最平庸的时候便是没有灵感。有时候没有想法真的是一件苦恼的事。</p>
<p>这学期的这些个事也不会闲下来的，这样也好，慢慢来吧，一行一行的写，书一本一本的啃，路一步一步的走。。。</p>
<p>嗯。还是那句话，无悔就行了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>很久很久没有发过日志什么的了，生活越来越趋向于充实的平稳与平静。每天都在忙，不过有时候想想时间真是不知道怎么的就没了。 或许归根结底还是没好好的规划吧。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写一篇日志]]></title>
    <link href="http://yikun.github.io/2010/10/05/xieyipianrizhi/"/>
    <id>http://yikun.github.io/2010/10/05/xieyipianrizhi/</id>
    <published>2010-10-04T19:40:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>今天是十月五日，天气晴朗，星空美丽。<br><a id="more"></a><br>现在我在宿舍的床上滴滴哒哒的按着手机。交待了时间地点人物，还差起因经过结果。本 身我不是什么有文采的人，但是经过和谐美好社会的洗礼，养成了一些美好的习惯。刚才看见二姐的日志，这件事情姑且算作起因。不大灵光的头脑经过一系列乱窜 的微弱电流在头部的沟沟壑壑中形成的紊乱的思绪，这个过程算作经过。然后我下面打出的几行未经过任何处理的只言片语，这便算作是结果吧。这样，记叙文的六 大要素算是齐全了，也便没有辜负从小学一直到高一都是语文老师做班主任的这个事实。</p>
<p>正如二姐所说的，于是，大二了。经过一年的高 等教育的培育，我现在也算是一名不折不扣的大学生了。二姐文章内的很多都是藏在内心里面，不想在公开场面表露的。我自认为我还算是一个敢说敢做敢为的人。 正如他所含沙涉影的描述，我们的大学生活中出现了这种那种利益的纷争。我在考虑具体什么的用不用在这里附上一个超级链接然后转向二姐的日志，但是考虑到二 姐的广泛影响力还有手机的具体能力。我还是决定不多此一举了。关于学生会、奖学金、团委、热水供应那些和我无关的事情我便也无权描述。既然，我处在大学这 个小社会中，那么我也应该享有这么一项言论自由。所以，写不写随我，看不看随你。</p>
<p>大一一年的时间，我到底做了什么，我想也是时候描述一下了。没有什么丰功伟绩，没有什么惊天动地，和大家一样的加了几个什么组织。</p>
<p>那好，先说学生会。为了那些所谓的潜移默化的进步，然后投简历，开始兴致勃勃的进行面试，终于是头破血流般的从外联部调剂到学习实践部，在这个部酱油的一年 来，多多少少也算是有所收获有所成长，以致于我觉得进步超过了我所想象，感觉到所有的东西都领悟了之后，在学期初的时候，选择了退出。刚才看到二姐日志中 写到什么干事—部长助理—部长副部长的路线，突然给了我启发，我才知道原来事情是这样发展的。这里，我也无力去评价学生会什么的好坏，大家心里也都明白。 我是想说，什么如果留下来要给我升官，什么我可以去聚餐那些东西又能影响的到我什么，最多是简历上一行平淡的经历，然后再也没什么了，被大家妖化的学生 会，也在日益增加的光芒中不断的健壮，赢得了大一莘莘学子的青睐，最终学生会也往开一面，基本全额地收留了屈指可数的报名的精英。有些人评价说学生会要没 落了，那些事情与你们无关，你死了以后，不会在你的墓碑刻上一行字：在学生会没落之前，此人果断离开。所以，我也没有说我的离开彰显我的明智。只是个人不 喜欢那种氛围罢了。什么大二之后就可以管别人了，我自己的事情都没有管好，哪有资格倚老卖老欺骗广大新生，并且美其名曰潜移默化的进步。</p>
<p>然后是科协，当我斗志昂扬的写好简历，面试，并且被面试官无情秒杀时，便发誓与科协誓不两力。如今，我也便是充满自豪的忝列于技术部部长助理的名单中，在 此，我想我要向张静媛同学致谢，没有她的推荐，或许我还在科协外部碌碌无为。比较戏剧的我也成了面试官，当坐到这里，我才发现，或许，那些有意念想要学好 的孩子们，也被我们这些面试官以一句：技术部需要有技术基础的搪塞过去了。科协确实是个好地方，没有学生会那些无聊的纷争，做自己喜欢的事情，学学技术， 打打酱油，足以。学长们都有闪闪发光的一面，没有什么架子可言，什么嵌入式奖杯，什么国创计划，有能力的学长有着这样那样的荣誉，可是没有丝毫的高姿态， 我想这才是作为学长应有的姿态。尤其要提下黄翔学长，前几个月为了给我讲一个8255的读写，花费了他将近三个小时。最后还从他口中得知，当时他在给我们 讲单片机的时候，被不少人误以为他们从实验板里捞了不少钱。我说那些人你是脑残还是怎么了叫你大四保研了，占用自己的时间去教大一的，不求回报，你能做到 么。别以为你不能，别人就不能。在这里还是要非常感谢那些学长的，当然，到大四以后，如果我也有能力的话，也一定会传承你们的意志的。</p>
<p>下来说说星火杯，什么我们这组好强，什么冲击校特，都是吓唬人的。不管这组有怎样怎样栩栩如生，精彩动人刻骨铭心的故事，那些都不重要，重要的是在于真正的 学到东西了，这种事情过程确实很重要。和强人混，拿别人的东西ctrl c，ctrl v，然后你拿个院奖免修，或者一不小心还拿个校特，保研加个1分2分，对自己又有多大提升？什么没基础求强人带，你就那么看不起自己？那么强人永远是强 人，你自己永远只是你自己。我没有像某些人什么从小就开始学编程，家里的人随便就弄个专利给自己挥霍。我就是零基础那又怎样，我通过自己努力，团队合作完 成了作品，达到了自己预想的功能，这就足够了。对自己的队友的能力要信任，这是最起码的规则，你必须要遵守。所以，到最后，不管是没奖院奖校奖，不管合理 与否，我都接受，我也只能接受，至少我能做到问心无愧。那些纷争，利益，关系，那些都是社会层面的事情，和技术层面是没有任何牵连的。</p>
<p>下来说说班级，我通过匪夷所思的路线，从心理委员一跃成为副班长，可能大家会想，凭什么我就拿了社会工作奖学金，凭什么我就有资格参加高党课程。得到这些东 西或者荣誉，我觉得没人会认为我是绞尽脑汁用什么非法手段吧？这点我还是比较自信的。下来就是班长竞选，王琪他大一做了多少事可能我是比较清楚的，为了一 个答辩，你能做到耗尽自己自习的时间吗？虽然，你对他这样那样的看不惯，不过你想想也便明白，为什么王琪最终还是当上正班长，即使只是一票之差。</p>
<p>至于导员，大家对导员有这样那样的意见，在这里我也无意评价导员的好坏。导员本身是个比较尴尬的位置，对于班主任大家都心存一个黑暗的形象，以致于把这层阴 影覆盖到了导员的职位上，我只是希望大家在说一些话的时候，能换位思考一下。人无完人，或许有些事情处理的不得当，但是，请你不要用有色的眼睛去看待世 界。好了，夜也比较深了，想说的也说完了，打字也累了，那么，就到这吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天是十月五日，天气晴朗，星空美丽。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[静夕思]]></title>
    <link href="http://yikun.github.io/2010/07/10/jingxisi/"/>
    <id>http://yikun.github.io/2010/07/10/jingxisi/</id>
    <published>2010-07-09T16:00:00.000Z</published>
    <updated>2016-02-23T17:03:48.000Z</updated>
    <content type="html"><![CDATA[<p>一个人，静悄悄地坐在窗台，看着天空是阴霾。<br><a id="more"></a><br>几缕阳光，耐不住寂寞，钻过某处略显稀薄的云雾，真的是一缕一缕的，爬到世间，忍不住回到桌前，拿起笔记录几点几滴的文字。</p>
<p>没有犹豫的拿起钢笔，已经干涸了的钢笔，吸了几滴甘霖般的墨水，蓝色，纯蓝色。坐在马扎上，靠着阳台的墙，墙被太阳烤得有些余温，靠上去丝毫感受不到温暖， 而是几分燥热。外面是垃圾与绿色的杂草构成的废地，夏的绿很深很深，在几处凌乱的垃圾的点缀下略显几分荒颓，这样的荒颓如大一下学期的生活，没有一丝一抹 的鲜活的灵感，只剩下没有生机的暗淡；废地旁，还有一个废弃的工厂，传说之中有各种原因，它坚强的被遗弃在这荒芜的西电，工厂只剩下一圈围墙禁锢些那些荒 砖颓墙，几簇挺拔的野草顽固的扎在那儿，又增添几分紊乱，这紊乱如大一下学期的林总，无处安置的梦想碰到了迷失的现实。</p>
<p>坐在阳台最显惬意的是能吹来一阵阵的微风，触摸灵魂般的微凉。一切都很安静，很安静。安静到坐在这里什么也不用想，那些思绪便仿佛识破了这安寂一般，喷涌而出，没有人打扰我，没有人能打扰我，没有人会打扰我，略显几分得意的孤独。</p>
<p>是 孤独，不是寂寞。孤独是一种比寂寞更坚强的东西，没有寂寞那么的无助。身边，没有人说话，没有人谈心，即使有，也是肤浅的嘻哈几句带过，记着开学的时候， 总把贵重的物品，还有这些珍贵的笔迹锁在抽屉里，有戒备。现在呢？锁永远开着，没有人会动那些所谓的贵重，或许，就算是不小心看见了这些凌乱的笔迹也可能 看不懂吧？这锁确实永远开着，然而，心却上了一把锁，没有钥匙的锁。</p>
<p>我曾说过，本来人与人之间并没有隔阂，可是，门一层一层地加上了，锁也一把一 把地死死地焊在上面，于是，太累了，便懒得去打开，或者是说不想去打开。眼看着日子就这么一天一天的从眼间划过，也便慢慢地，力不从心，无力抓住，毫不知 情地被几分低迷侵占，然后守着梦想糜烂在这无处安放的青春。</p>
<p>想要破除这阴霾，却总是半途而止。再看看天，那略显稀薄的云雾也开始慢慢地合上，几缕阳光是否也望见了这世间的暗淡，无奈地退了回去？</p>
<p>客 厅又传来了咯吱的的门声，再啪的一声彻底击碎这片宁静，回头看看，不是有人回来，而是有人离开。离开？是的，就像朋友一个一个离去一样，不打招呼，还没反 应过来，这里便空得只剩下我一个人。刚才又看到了类似的话语。“朋友。一个，知己；两个，略显敷衍；三个、四个，也未免太多了吧”有到了一个我可以笑而不 语的时刻。每次，每时，每刻听到朋友二字时，心中总是有说不出来的无奈与酸楚，我人际能力太强了吧，人缘太好了吧？呵。。大家都说朋友是财富。那我未免也 有点太过富有了吧？富有到最后，我便应该成了一个最穷的富翁了吧？</p>
<p>是不是想得太多了，也罢，该收尾了。顺其自然。这些思绪或许也就停留在这些歪七 扭八的字里行间了吧？想想也可笑，高中文章结尾的时候总喜欢这样写：我拾起散落了一地的思绪，看着远方的阳，夕阳咬破云的唇，留下一抹血迹在天边。”然后 便是描写几句明早破晓的美好。可现在呢？却真是到了夕阳时，，天际却还是只有大片的阴霾，思绪也不那么能轻易的散开，而却像墨迹留在纸上一样，便深深的印 在了我这矫柔造作的文字上了。还好这不是高考作文，我不用可以去敷衍，隐藏什么。现实是怎样我便记下来。</p>
<p>远处还是阴霾，破晓是否能见朝阳，谁可得知。正如我于别人，永远是个Enigma。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个人，静悄悄地坐在窗台，看着天空是阴霾。<br>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yikun.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>