<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<TITLE>Build/check report for BioC 3.17 - CHECK results for atSNP on kunpeng1</TITLE>
<LINK rel="stylesheet" href="../report.css" type="text/css">
<SCRIPT type="text/javascript" src="../report.js"></SCRIPT>
</HEAD>
<BODY onLoad="initialize();">
<TABLE class="grid_layout" style="width: 100%; background: #EEE;"><TR><TD style="text-align: left; padding: 5px; vertical-align: middle;"><I>Back to <B>Build/check report for BioC 3.17</B>:&nbsp;&nbsp;&nbsp;<A href="../">simplified</A>&nbsp;&nbsp;&nbsp;<A href="../long-report.html">long</A></I></TD><TD><TABLE class="abc_dispatcher"><TR><TD><B>[<A href="..#A">A</A>]</B></TD><TD><A href="..#B">B</A></TD><TD><A href="..#C">C</A></TD><TD><A href="..#D">D</A></TD><TD><A href="..#E">E</A></TD><TD><A href="..#F">F</A></TD><TD><A href="..#G">G</A></TD><TD><A href="..#H">H</A></TD><TD><A href="..#I">I</A></TD><TD><A href="..#J">J</A></TD><TD><A href="..#K">K</A></TD><TD><A href="..#L">L</A></TD><TD><A href="..#M">M</A></TD><TD><A href="..#N">N</A></TD><TD><A href="..#O">O</A></TD><TD><A href="..#P">P</A></TD><TD><A href="..#Q">Q</A></TD><TD><A href="..#R">R</A></TD><TD><A href="..#S">S</A></TD><TD><A href="..#T">T</A></TD><TD><A href="..#U">U</A></TD><TD><A href="..#V">V</A></TD><TD><A href="..#W">W</A></TD><TD><A href="..#X">X</A></TD><TD><A href="..#Y">Y</A></TD><TD><A href="..#Z">Z</A></TD></TR></TABLE></TD></TR></TABLE>
<P class="time_stamp">
This page was generated on 2023-03-27 05:50:29 -0000 (Mon, 27 Mar 2023).
</P>
<TABLE class="node_specs">
<TR><TH>Hostname</TH><TH>OS</TH><TH>Arch&nbsp;(*)</TH><TH>R&nbsp;version</TH><TH style="text-align: right;">Installed&nbsp;pkgs</TH></TR>
<TR class="kunpeng1"><TD><B><A href="../kunpeng1-NodeInfo.html"><B>kunpeng1</B></A></B></TD><TD>Linux&nbsp;(Ubuntu&nbsp;22.04.1&nbsp;LTS)</TD><TD>aarch64</TD><TD>R&nbsp;Under&nbsp;development&nbsp;(unstable)&nbsp;(2023-03-12&nbsp;r83975)&nbsp;--&nbsp;"Unsuffered&nbsp;Consequences"
</TD><TD style="text-align: right;"><A href="../kunpeng1-R-instpkgs.html">6083</A></TD></TR>
<TR><TD COLSPAN="5" style="font-size: smaller;"><I>Click on any hostname to see more info about the system (e.g. compilers) &nbsp;&nbsp;&nbsp;&nbsp; (*) as reported by 'uname -p', except on Windows and Mac OS X</I></TD></TR>
</TABLE>
<BR>
<H2><SPAN class="kunpeng1">CHECK results for atSNP on kunpeng1</SPAN></H2>
<BR>
<DIV class="motd">
<TABLE><TR><TD>
To the developers/maintainers of the atSNP package:<BR>
- Please allow up to 24 hours (and sometimes 48 hours) for your latest push to git@git.bioconductor.org:packages/atSNP.git to<BR>reflect on this report. See <A href="https://bioconductor.org/developers/how-to/troubleshoot-build-report/">How and When does the builder pull? When will my changes propagate?</A> for more information.<BR>
- Make sure to <A href="../Renviron.bioc">use the following settings</A> in order to reproduce any error or warning you see on this page.<BR>
</TD></TR></TABLE>
</DIV>
<P style="text-align: center;"><A href="raw-results/">raw results</A><P>
<TABLE class="gcard_list">
<TBODY class="gcard ok">
<TR class="header"><TD class="leftmost top_left_corner"></TD><TD>Package <B>108</B>/2195</TD><TD style="width: 75px;">Hostname</TD><TD style="width: 225px;">OS&nbsp;/&nbsp;Arch</TD><TD class="STAGE install">INSTALL</TD><TD class="STAGE buildsrc">BUILD</TD><TD class="STAGE checksrc selected">CHECK</TD><TD class="STAGE buildbin">BUILD BIN</TD><TD style="width: 12px;"></TD><TD class="rightmost top_right_corner"></TD></TR>
<TR class="selected_row"><TD ROWSPAN="2" class="leftmost bottom_left_corner"></TD><TD ROWSPAN="1" style="vertical-align: top;"><B><A href="./">atSNP</A>&nbsp;1.15.0</B>&nbsp;&nbsp;<SPAN style="font-size: smaller; font-style: italic;">(<A href="/packages/3.17/atSNP">landing page</A>)</SPAN><BR>Sunyoung Shin<BR><TABLE class="svn_info">
<TR><TD class="svn_info">Snapshot&nbsp;Date:&nbsp;<SPAN class="svn_info">2023-03-24&nbsp;01:40:07&nbsp;-0000&nbsp;(Fri,&nbsp;24&nbsp;Mar&nbsp;2023)</SPAN></TD></TR>
<TR><TD class="svn_info">git_url:&nbsp;<SPAN class="svn_info">https://git.bioconductor.org/packages/atSNP</SPAN></TD></TR>
<TR><TD class="svn_info">git_branch:&nbsp;<SPAN class="svn_info">devel</SPAN></TD></TR>
<TR><TD class="svn_info">git_last_commit:&nbsp;<SPAN class="svn_info">726fb40</SPAN></TD></TR>
<TR><TD class="svn_info">git_last_commit_date:&nbsp;<SPAN class="svn_info">2022-11-01&nbsp;15:19:16&nbsp;-0000&nbsp;(Tue,&nbsp;01&nbsp;Nov&nbsp;2022)</SPAN></TD></TR>
</TABLE>
</TD><TD class="kunpeng1 selected"><B>kunpeng1</B></TD><TD class="kunpeng1"><SPAN style="font-size: smaller;">Linux&nbsp;(Ubuntu&nbsp;22.04.1&nbsp;LTS)&nbsp;/&nbsp;aarch64</SPAN></TD><TD class="status kunpeng1 install"><A href="./kunpeng1-install.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1 buildsrc"><A href="./kunpeng1-buildsrc.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1 checksrc selected"><A href="./kunpeng1-checksrc.html" onmouseover="add_class_mouseover(this);" onmouseout="remove_class_mouseover(this);"><SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></A></TD><TD class="status kunpeng1"></TD><TD class="status kunpeng1"></TD><TD ROWSPAN="2" class="rightmost bottom_right_corner"></TD></TR>
<TR class="footer"><TD COLSPAN="8"></TD></TR>
</TBODY>
</TABLE>
<HR>
<H3>Summary</H3>
<DIV class="kunpeng1 hscrollable">
<TABLE>
<TR><TD><B>Package</B>: atSNP</TD></TR>
<TR><TD><B>Version</B>: 1.15.0</TD></TR>
<TR><TD><B>Command</B>: /home/biocbuild/bbs-3.17-bioc/R/bin/R CMD check --install=check:atSNP.install-out.txt --library=/home/biocbuild/bbs-3.17-bioc/R/site-library --timings atSNP_1.15.0.tar.gz</TD></TR>
<TR><TD><B>StartedAt</B>: 2023-03-24 21:01:27 -0000 (Fri, 24 Mar 2023)</TD></TR>
<TR><TD><B>EndedAt</B>: 2023-03-24 21:09:51 -0000 (Fri, 24 Mar 2023)</TD></TR>
<TR><TD><B>EllapsedTime</B>: 503.5 seconds</TD></TR>
<TR><TD><B>RetCode</B>: 0</TD></TR>
<TR><TD><B>Status</B>: <SPAN class="glyph OK">&nbsp;&nbsp;OK&nbsp;&nbsp;</SPAN></TD></TR>
<TR><TD><B>CheckDir</B>: atSNP.Rcheck</TD></TR>
<TR><TD><B>Warnings</B>: 0</TD></TR>
</TABLE>
</DIV>
<HR>
<H3>Command output</H3>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">
##############################################################################
##############################################################################
###
### Running command:
###
###   /home/biocbuild/bbs-3.17-bioc/R/bin/R CMD check --install=check:atSNP.install-out.txt --library=/home/biocbuild/bbs-3.17-bioc/R/site-library --timings atSNP_1.15.0.tar.gz
###
##############################################################################
##############################################################################


* using log directory ‘/home/biocbuild/bbs-3.17-bioc/meat/atSNP.Rcheck’
* using R Under development (unstable) (2023-03-12 r83975)
* using platform: aarch64-unknown-linux-gnu (64-bit)
* R was compiled by
    gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
    GNU Fortran (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
* running under: Ubuntu 22.04.2 LTS
* using session charset: UTF-8
* checking for file ‘atSNP/DESCRIPTION’ ... OK
* checking extension type ... Package
* this is package ‘atSNP’ version ‘1.15.0’
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘atSNP’ can be installed ... OK
* used C++ compiler: ‘g++ (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0’
* checking installed package size ... OK
* checking package directory ... OK
* checking ‘build’ directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking dependencies in R code ... NOTE
Namespaces in Imports field not imported from:
  ‘graphics’ ‘testthat’
  All declared Imports should be used.
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... NOTE
ComputePValues: no visible binding for global variable ‘motif’
ComputePValues: no visible binding for global variable ‘snpid’
ComputePValues: no visible binding for global variable ‘snpbase’
ComputePValues: no visible binding for global variable ‘pval_ref’
ComputePValues: no visible binding for global variable ‘pval_snp’
ComputePValues: no visible binding for global variable ‘pval_cond_ref’
ComputePValues: no visible binding for global variable ‘pval_cond_snp’
ComputePValues: no visible binding for global variable ‘pval_diff’
ComputePValues: no visible binding for global variable ‘pval_rank’
LoadSNPData: no visible global function definition for ‘is’
LoadSNPData: no visible binding for global variable ‘IUPAC_CODE_MAP’
MatchSubsequence: no visible binding for global variable ‘motif’
MatchSubsequence: no visible binding for global variable ‘snpid’
MatchSubsequence: no visible binding for global variable ‘snpbase’
MatchSubsequence: no visible binding for global variable ‘len_seq’
MatchSubsequence: no visible binding for global variable ‘ref_seq’
MatchSubsequence : &lt;anonymous&gt;: no visible binding for global variable
  ‘motif’
checkMotifs: no visible global function definition for ‘is’
checkSNPids: no visible global function definition for ‘is’
dtMotifMatch: no visible binding for global variable ‘ref_seq’
dtMotifMatch: no visible binding for global variable ‘len_seq’
dtMotifMatch: no visible binding for global variable ‘snp_ref_start’
dtMotifMatch: no visible binding for global variable ‘ref_start’
dtMotifMatch: no visible binding for global variable ‘snp_start’
dtMotifMatch: no visible binding for global variable ‘snp_ref_end’
dtMotifMatch: no visible binding for global variable ‘ref_end’
dtMotifMatch: no visible binding for global variable ‘snp_end’
dtMotifMatch: no visible binding for global variable ‘snp_ref_length’
dtMotifMatch: no visible binding for global variable
  ‘ref_aug_match_seq_forward’
dtMotifMatch: no visible binding for global variable
  ‘ref_aug_match_seq_reverse’
dtMotifMatch: no visible binding for global variable
  ‘snp_aug_match_seq_forward’
dtMotifMatch: no visible binding for global variable ‘snp_seq’
dtMotifMatch: no visible binding for global variable
  ‘snp_aug_match_seq_reverse’
dtMotifMatch: no visible binding for global variable ‘ref_strand’
dtMotifMatch: no visible binding for global variable ‘ref_location’
dtMotifMatch: no visible binding for global variable ‘snp_strand’
dtMotifMatch: no visible binding for global variable ‘snp_location’
dtMotifMatch: no visible binding for global variable
  ‘ref_extra_pwm_left’
dtMotifMatch: no visible binding for global variable
  ‘ref_extra_pwm_right’
dtMotifMatch: no visible binding for global variable
  ‘snp_extra_pwm_left’
dtMotifMatch: no visible binding for global variable
  ‘snp_extra_pwm_right’
dtMotifMatch: no visible binding for global variable ‘snpid’
match_subseq_par: no visible binding for global variable ‘snpid’
match_subseq_par: no visible binding for global variable ‘motif’
match_subseq_par: no visible binding for global variable ‘snpbase’
match_subseq_par: no visible binding for global variable ‘ref_strand’
match_subseq_par: no visible binding for global variable
  ‘ref_match_seq’
match_subseq_par: no visible binding for global variable ‘ref_seq’
match_subseq_par: no visible binding for global variable ‘ref_start’
match_subseq_par: no visible binding for global variable ‘ref_end’
match_subseq_par: no visible binding for global variable ‘ref_seq_rev’
match_subseq_par: no visible binding for global variable ‘len_seq’
match_subseq_par: no visible binding for global variable ‘snp_strand’
match_subseq_par: no visible binding for global variable
  ‘snp_match_seq’
match_subseq_par: no visible binding for global variable ‘snp_seq’
match_subseq_par: no visible binding for global variable ‘snp_start’
match_subseq_par: no visible binding for global variable ‘snp_end’
match_subseq_par: no visible binding for global variable ‘snp_seq_rev’
match_subseq_par: no visible binding for global variable
  ‘snp_seq_ref_match’
match_subseq_par: no visible binding for global variable
  ‘ref_seq_snp_match’
match_subseq_par: no visible binding for global variable ‘motif_len’
match_subseq_par: no visible binding for global variable ‘log_lik_ref’
match_subseq_par: no visible binding for global variable ‘log_lik_snp’
match_subseq_par: no visible binding for global variable
  ‘log_lik_ratio’
match_subseq_par: no visible binding for global variable
  ‘log_enhance_odds’
match_subseq_par: no visible binding for global variable
  ‘log_reduce_odds’
match_subseq_par: no visible binding for global variable ‘IUPAC’
motif_score_par: no visible binding for global variable ‘motif’
motif_score_par: no visible binding for global variable ‘snpbase’
plotMotifMatch: no visible global function definition for ‘is’
results_motif_par: no visible binding for global variable ‘p.value’
Undefined global functions or variables:
  IUPAC IUPAC_CODE_MAP is len_seq log_enhance_odds log_lik_ratio
  log_lik_ref log_lik_snp log_reduce_odds motif motif_len p.value
  pval_cond_ref pval_cond_snp pval_diff pval_rank pval_ref pval_snp
  ref_aug_match_seq_forward ref_aug_match_seq_reverse ref_end
  ref_extra_pwm_left ref_extra_pwm_right ref_location ref_match_seq
  ref_seq ref_seq_rev ref_seq_snp_match ref_start ref_strand
  snp_aug_match_seq_forward snp_aug_match_seq_reverse snp_end
  snp_extra_pwm_left snp_extra_pwm_right snp_location snp_match_seq
  snp_ref_end snp_ref_length snp_ref_start snp_seq snp_seq_ref_match
  snp_seq_rev snp_start snp_strand snpbase snpid
Consider adding
  importFrom(&quot;methods&quot;, &quot;is&quot;)
to your NAMESPACE file (and ensure that your DESCRIPTION Imports field
contains &#x27;methods&#x27;).
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... OK
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking contents of ‘data’ directory ... OK
* checking data for non-ASCII characters ... OK
* checking data for ASCII and uncompressed saves ... OK
* checking line endings in C/C++/Fortran sources/headers ... OK
* checking compiled code ... NOTE
Note: information on .o files is not available
File ‘/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/site-library/atSNP/libs/atSNP.so’:
  Found ‘__printf_chk’, possibly from ‘printf’ (C)

Compiled code should not call entry points which might terminate R nor
write to stdout/stderr instead of to the console, nor use Fortran I/O
nor system RNGs nor [v]sprintf. The detected symbols are linked into
the code but might come from libraries and not actually be called.

See ‘Writing portable packages’ in the ‘Writing R Extensions’ manual.
* checking files in ‘vignettes’ ... OK
* checking examples ... OK
Examples with CPU (user + system) or elapsed time &gt; 5s
                user system elapsed
plotMotifMatch 1.277  9.844  19.427
* checking for unstated dependencies in ‘tests’ ... OK
* checking tests ...
  Running ‘test.R’
  Running ‘test_change.R’
  Running ‘test_diff.R’
  Running ‘test_is.R’
 OK
* checking for unstated dependencies in vignettes ... OK
* checking package vignettes in ‘inst/doc’ ... OK
* checking running R code from vignettes ...
  ‘atsnp-vignette.rmd’ using ‘UTF-8’... OK
 NONE
* checking re-building of vignette outputs ... OK
* checking PDF version of manual ... OK
* DONE

Status: 3 NOTEs
See
  ‘/home/biocbuild/bbs-3.17-bioc/meat/atSNP.Rcheck/00check.log’
for details.


</PRE>
</DIV><HR>
<H3>Installation output</H3>
<P><SPAN class="filename">atSNP.Rcheck/00install.out</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">
##############################################################################
##############################################################################
###
### Running command:
###
###   /home/biocbuild/bbs-3.17-bioc/R/bin/R CMD INSTALL atSNP
###
##############################################################################
##############################################################################


* installing to library ‘/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/site-library’
* installing *source* package ‘atSNP’ ...
** using staged installation
** libs
using C++ compiler: ‘g++ (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0’
g++ -std=gnu++17 -I&quot;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/include&quot; -DNDEBUG  -I&#x27;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/library/Rcpp/include&#x27; -I/usr/local/include    -fPIC  -g -O2  -c ImportanceSample.cpp -o ImportanceSample.o
g++ -std=gnu++17 -I&quot;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/include&quot; -DNDEBUG  -I&#x27;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/library/Rcpp/include&#x27; -I/usr/local/include    -fPIC  -g -O2  -c ImportanceSampleChange.cpp -o ImportanceSampleChange.o
g++ -std=gnu++17 -I&quot;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/include&quot; -DNDEBUG  -I&#x27;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/library/Rcpp/include&#x27; -I/usr/local/include    -fPIC  -g -O2  -c ImportanceSampleDiff.cpp -o ImportanceSampleDiff.o
g++ -std=gnu++17 -I&quot;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/include&quot; -DNDEBUG  -I&#x27;/home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/lib/R/library/Rcpp/include&#x27; -I/usr/local/include    -fPIC  -g -O2  -c MotifScore.cpp -o MotifScore.o
g++ -std=gnu++17 -shared -L/usr/local/lib -o atSNP.so ImportanceSample.o ImportanceSampleChange.o ImportanceSampleDiff.o MotifScore.o
installing to /home/biocbuild/bbs-3.17-bioc/R-devel_2023-03-12_r83975-bin/site-library/00LOCK-atSNP/00new/atSNP/libs
** R
** data
** inst
** byte-compile and prepare package for lazy loading
** help
*** installing help indices
** building package indices
** installing vignettes
** testing if installed package can be loaded from temporary location
** checking absolute paths in shared objects and dynamic libraries
** testing if installed package can be loaded from final location
** testing if installed package keeps a record of temporary installation path
* DONE (atSNP)
</PRE>
</DIV><HR>
<H3>Tests output</H3>
<P><SPAN class="filename">atSNP.Rcheck/tests/test.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R Under development (unstable) (2023-03-12 r83975) -- &quot;Unsuffered Consequences&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; library(atSNP)

&gt; library(BiocParallel)
&gt; library(testthat)
&gt; 
&gt; ## process the data
&gt; data(example)
&gt; 
&gt; motif_scores &lt;- ComputeMotifScore(motif_library, snpInfo, ncores = 1)
&gt; 
&gt; motif_scores &lt;- MatchSubsequence(motif_scores$snp.tbl, motif_scores$motif.scores, ncores = 1, motif.lib = motif_library)
&gt; 
&gt; motif_scores[which(motif_scores$snpid == &quot;rs7412&quot; &amp; motif_scores$motif == &quot;SIX5_disc1&quot;), ]
   snpid      motif
4 rs7412 SIX5_disc1
                                                        ref_seq
4 CTCCTCCGCGATGCCGATGACCTGCAGAAGCGCCTGGCAGTGTACCAGGCCGGGGCCCGCG
                                                        snp_seq motif_len
4 CTCCTCCGCGATGCCGATGACCTGCAGAAGTGCCTGGCAGTGTACCAGGCCGGGGCCCGCG        10
  ref_start ref_end ref_strand snp_start snp_end snp_strand log_lik_ref
4        29      38          -        22      31          +   -42.60672
  log_lik_snp log_lik_ratio log_enhance_odds log_reduce_odds      IUPAC
4    -38.4083     -4.198418           23.013       -2.917768 GARWTGTAGT
  ref_match_seq snp_match_seq ref_seq_snp_match snp_seq_ref_match snpbase
4    GCCAGGCGCT    CTGCAGAAGT        CTGCAGAAGC        GCCAGGCACT       T
&gt; 
&gt; len_seq &lt;- sapply(motif_scores$ref_seq, nchar)
&gt; snp_pos &lt;- as.integer(len_seq / 2) + 1
&gt; 
&gt; i &lt;- which(motif_scores$snpid == &quot;rs7412&quot; &amp; motif_scores$motif == &quot;SIX5_disc1&quot;)
&gt; 
&gt; test_that(&quot;Error: reference bases are not the same as the sequence matrix.&quot;, {
+   expect_equal(sum(snpInfo$sequence_matrix[31, ] != snpInfo$ref_base), 0)
+   expect_equal(sum(snpInfo$sequence_matrix[31, ] == snpInfo$snp_base), 0)
+ })
Test passed 🥇
&gt; 
&gt; test_that(&quot;Error: log_lik_ratio is not correct.&quot;, {
+   expect_equal(motif_scores$log_lik_ref - motif_scores$log_lik_snp, motif_scores$log_lik_ratio)
+ })
Test passed 😀
&gt; 
&gt; test_that(&quot;Error: log likelihoods are not correct.&quot;, {
+ 
+   log_lik &lt;- sapply(seq(nrow(motif_scores)),
+                         function(i) {
+                           motif_mat &lt;- motif_library[[motif_scores$motif[i]]]
+                           colind&lt;-which(snpInfo$snpids==motif_scores$snpid[i]) 
+                           bases &lt;- snpInfo$sequence_matrix[motif_scores$ref_start[i]:motif_scores$ref_end[i], colind]
+                           if(motif_scores$ref_strand[i] == &quot;-&quot;)
+                             bases &lt;- 5 - rev(bases)
+                           log(prod(
+                                    motif_mat[cbind(seq(nrow(motif_mat)),
+                                                    bases)]))
+                         })
+ 
+   expect_equal(log_lik, motif_scores$log_lik_ref)
+ 
+   snp_mat &lt;- snpInfo$sequence_matrix
+   snp_mat[cbind(snp_pos, seq(ncol(snp_mat)))] &lt;- snpInfo$snp_base
+   log_lik &lt;- sapply(seq(nrow(motif_scores)),
+                     function(i) {
+                       motif_mat &lt;- motif_library[[motif_scores$motif[i]]]
+                       colind&lt;-which(snpInfo$snpids==motif_scores$snpid[i])
+                       bases &lt;- snp_mat[motif_scores$snp_start[i]:motif_scores$snp_end[i], colind]
+                       if(motif_scores$snp_strand[i] == &quot;-&quot;)
+                         bases &lt;- 5 - rev(bases)
+                       log(prod(
+                                motif_mat[cbind(seq(nrow(motif_mat)),
+                                                bases)]))
+                     })
+ 
+   expect_equal(log_lik, motif_scores$log_lik_snp)
+ })
Test passed 🎊
&gt; 
&gt; test_that(&quot;Error: log_enhance_odds not correct.&quot;, {
+   
+   len_seq &lt;- sapply(motif_scores$ref_seq, nchar)
+   snp_pos &lt;- as.integer(len_seq / 2) + 1
+ 
+   ## log odds for reduction in binding affinity
+   
+   pos_in_pwm &lt;- snp_pos - motif_scores$ref_start + 1
+   neg_ids &lt;- which(motif_scores$ref_strand == &quot;-&quot;)
+   pos_in_pwm[neg_ids] &lt;- motif_scores$ref_end[neg_ids]- snp_pos[neg_ids] + 1
+   snp_base &lt;- sapply(substr(motif_scores$snp_seq, snp_pos, snp_pos), function(x) which(c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) == x))
+   ref_base &lt;- sapply(substr(motif_scores$ref_seq, snp_pos, snp_pos), function(x) which(c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) == x))
+   snp_base[neg_ids] &lt;- 5 - snp_base[neg_ids]
+   ref_base[neg_ids] &lt;- 5 - ref_base[neg_ids]
+   my_log_reduce_odds &lt;- sapply(seq(nrow(motif_scores)),
+                                function(i)
+                                log(motif_library[[motif_scores$motif[i]]][pos_in_pwm[i], ref_base[i]]) -
+                                log(motif_library[[motif_scores$motif[i]]][pos_in_pwm[i], snp_base[i]])
+                                )
+ 
+   expect_equal(my_log_reduce_odds, motif_scores$log_reduce_odds)
+ 
+   ## log odds in enhancing binding affinity
+   
+   pos_in_pwm &lt;- snp_pos - motif_scores$snp_start + 1
+   neg_ids &lt;- which(motif_scores$snp_strand == &quot;-&quot;)
+   pos_in_pwm[neg_ids] &lt;- motif_scores$snp_end[neg_ids]- snp_pos[neg_ids] + 1
+   snp_base &lt;- sapply(substr(motif_scores$snp_seq, snp_pos, snp_pos), function(x) which(c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) == x))
+   ref_base &lt;- sapply(substr(motif_scores$ref_seq, snp_pos, snp_pos), function(x) which(c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;) == x))
+   snp_base[neg_ids] &lt;- 5 - snp_base[neg_ids]
+   ref_base[neg_ids] &lt;- 5 - ref_base[neg_ids]
+   my_log_enhance_odds &lt;- sapply(seq(nrow(motif_scores)),
+                                 function(i)
+                                 log(motif_library[[motif_scores$motif[i]]][pos_in_pwm[i], snp_base[i]]) -
+                                 log(motif_library[[motif_scores$motif[i]]][pos_in_pwm[i], ref_base[i]]) 
+                                )
+ 
+   expect_equal(my_log_enhance_odds, motif_scores$log_enhance_odds)
+   
+ 
+ })
Test passed 🥳
&gt; 
&gt; test_that(&quot;Error: the maximum log likelihood computation is not correct.&quot;, {
+ 
+   snp_mat &lt;- snpInfo$sequence_matrix
+   snp_mat[cbind(snp_pos, seq(ncol(snp_mat)))] &lt;- snpInfo$snp_base
+ 
+   .findMaxLog &lt;- function(seq_vec, pwm) {
+     snp_pos &lt;- as.integer(length(seq_vec) / 2) + 1
+     start_pos &lt;- snp_pos - nrow(pwm) + 1
+     end_pos &lt;- snp_pos
+     rev_seq &lt;- 5 - rev(seq_vec)
+     
+     maxLogProb &lt;- -Inf
+     for(i in start_pos : end_pos) {
+       LogProb &lt;- log(prod(pwm[cbind(seq(nrow(pwm)),
+                                     seq_vec[i - 1 + seq(nrow(pwm))])]))
+       if(LogProb &gt; maxLogProb)
+         maxLogProb &lt;- LogProb
+     }
+     for(i in start_pos : end_pos) {
+       LogProb &lt;- log(prod(pwm[cbind(seq(nrow(pwm)),
+                                     rev_seq[i - 1 + seq(nrow(pwm))])]))
+       if(LogProb &gt; maxLogProb)
+         maxLogProb &lt;- LogProb
+     }
+     return(maxLogProb)
+   }
+   
+   ## find the maximum log likelihood on the reference sequence
+   my_log_lik_ref &lt;- sapply(seq(nrow(motif_scores)),
+                            function(x) {
+ 		                         colind&lt;-which(snpInfo$snpids==motif_scores$snpid[x])                           	
+                              seq_vec&lt;- snpInfo$sequence_matrix[, colind]
+                              pwm &lt;- motif_library[[motif_scores$motif[x]]]
+                              return(.findMaxLog(seq_vec, pwm))
+                            })
+ 
+   ## find the maximum log likelihood on the SNP sequence
+ 
+   my_log_lik_snp &lt;- sapply(seq(nrow(motif_scores)),
+                            function(x) {
+                       		  colind&lt;-which(snpInfo$snpids==motif_scores$snpid[x]) #ADDED
+                             seq_vec&lt;- snp_mat[, colind]
+                             pwm &lt;- motif_library[[motif_scores$motif[x]]]
+                             return(.findMaxLog(seq_vec, pwm))
+                            })
+   
+   expect_equal(my_log_lik_ref, motif_scores$log_lik_ref)
+   expect_equal(my_log_lik_snp, motif_scores$log_lik_snp)
+   
+ })
Test passed 🎊
&gt; 
&gt; proc.time()
   user  system elapsed 
 17.438   1.545  20.260 
</PRE>
</DIV><P><SPAN class="filename">atSNP.Rcheck/tests/test_change.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R Under development (unstable) (2023-03-12 r83975) -- &quot;Unsuffered Consequences&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; library(atSNP)

&gt; library(BiocParallel)
&gt; library(testthat)
&gt; data(example)
&gt; 
&gt; trans_mat &lt;- matrix(rep(snpInfo$prior, each = 4), nrow = 4)
&gt; test_pwm &lt;- motif_library$SIX5_disc1
&gt; scores &lt;- as.matrix(motif_scores$motif.scores[3:4, 4:5])
&gt; score_diff &lt;- abs(scores[,2]-scores[,1])
&gt; 
&gt; pval_a &lt;- .Call(&quot;test_p_value&quot;, test_pwm, snpInfo$prior, snpInfo$transition, scores, 0.15, 100)
&gt; pval_ratio &lt;- abs(log(pval_a[seq(nrow(scores)),1]) - log(pval_a[seq(nrow(scores)) + nrow(scores), 1]))
&gt; 
&gt; test_score &lt;- test_pwm
&gt; for(i in seq(nrow(test_score))) {
+   for(j in seq(ncol(test_score))) {
+     test_score[i, j] &lt;- exp(mean(log(test_pwm[i, j] / test_pwm[i, -j])))
+   }
+ }
&gt; 
&gt; adj_mat &lt;- test_pwm + 0.25
&gt; motif_len &lt;- nrow(test_pwm)
&gt; 
&gt; ## these are functions for this test only
&gt; drawonesample &lt;- function(theta) {
+     prob_start &lt;- rev(rowSums(test_score ^ theta) / rowSums(adj_mat))
+     id &lt;- sample(seq(motif_len), 1, prob = prob_start)
+     sample &lt;- sample(1:4, 2 * motif_len - 1, replace = TRUE, prob = snpInfo$prior)
+     delta &lt;- adj_mat
+     delta[motif_len - id + 1, ] &lt;- test_score[motif_len - id + 1, ] ^ theta
+     sample[id - 1 + seq(motif_len)] &lt;- apply(delta, 1, function(x) sample(seq(4), 1, prob = x))
+     ## compute weight
+     sc &lt;- 0
+     for(s in seq(motif_len)) {
+       delta &lt;- adj_mat
+       delta[motif_len + 1 - s, ] &lt;- test_score[motif_len + 1 - s, ] ^ theta
+       sc &lt;- sc + prod(delta[cbind(seq(motif_len), sample[s - 1 + seq(motif_len)])]) /
+         prod(snpInfo$prior[sample[s - 1 + seq(motif_len)]])
+     }
+     sample &lt;- c(sample, id, sc)
+     return(sample)
+ }
&gt; jointprob &lt;- function(x) prod(test_pwm[cbind(seq(motif_len), x)])
&gt; maxjointprob &lt;- function(x) {
+   maxp &lt;- -Inf
+   p &lt;- -Inf
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(x[i:(i+motif_len - 1)])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(5 - x[(i+motif_len - 1):i])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   return(maxp)
+ }
&gt; get_freq &lt;- function(sample) {
+   emp_freq &lt;- matrix(0, nrow = 2 * motif_len - 1, ncol = 4)
+   for(i in seq(2 * motif_len - 1)) {
+     for(j in seq(4)) {
+       emp_freq[i, j] &lt;- sum(sample[i, ] == j - 1)
+     }
+   }
+   emp_freq &lt;- emp_freq / rowSums(emp_freq)
+   return(emp_freq)
+ }
&gt; 
&gt; test_that(&quot;Error: quantile function computing are not equivalent.&quot;, {
+   for(p in c(0.01, 0.1, 0.5, 0.9, 0.99) ) {
+     delta &lt;- .Call(&quot;test_find_percentile_change&quot;, score_diff, p, package = &quot;atSNP&quot;)
+     delta.r &lt;- as.double(sort(abs(scores[,2]-scores[,1]))[ceiling((1 - p) * (nrow(scores)))])
+     expect_equal(delta, delta.r)
+   }
+ })
Test passed 🎊
&gt; 
&gt; test_that(&quot;Error: the scores for samples are not equivalent.&quot;, {
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile_change&quot;, score_diff, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta_change&quot;, test_score, adj_mat, delta, package = &quot;atSNP&quot;)
+   ## Use R code to generate a random sample
+   for(i in seq(10)) {
+     sample &lt;- drawonesample(theta)
+     sample_score &lt;- .Call(&quot;test_compute_sample_score_change&quot;, test_pwm, test_score, adj_mat, sample[seq(2 * motif_len - 1)] - 1, snpInfo$prior, trans_mat, sample[2 * motif_len] - 1, theta, package = &quot;atSNP&quot;)
+     expect_equal(sample[2 * motif_len + 1], sample_score[1])
+     sample1 &lt;- sample2 &lt;- sample3 &lt;- sample
+     sample1[motif_len] &lt;- seq(4)[-sample[motif_len]][1]
+     sample2[motif_len] &lt;- seq(4)[-sample[motif_len]][2]
+     sample3[motif_len] &lt;- seq(4)[-sample[motif_len]][3]
+     sample_score_r &lt;- log(maxjointprob(sample[seq(2 * motif_len - 1)])) -
+       log(c(maxjointprob(sample1[seq(2 * motif_len - 1)]),
+             maxjointprob(sample2[seq(2 * motif_len - 1)]),
+             maxjointprob(sample3[seq(2 * motif_len - 1)])))
+     expect_equal(sample_score_r, sample_score[2:4])
+   }
+   
+   ## Use C code to generate a random sample
+   for(i in seq(10)) {
+     sample &lt;- .Call(&quot;test_importance_sample_change&quot;, test_score, snpInfo$prior, trans_mat, test_pwm, theta, package = &quot;atSNP&quot;)
+     start_pos &lt;- sample[2 * motif_len] + 1
+     adj_score &lt;- 0
+     for(s in seq_len(motif_len)) {
+       adj_s &lt;- sum(log(adj_mat[cbind(seq(motif_len), sample[s - 1 + seq(motif_len)] + 1)]) -
+                    log(snpInfo$prior[sample[s - 1 + seq(motif_len)] + 1]))
+       adj_s &lt;- adj_s + theta * log(test_score[motif_len + 1 - s, sample[motif_len] + 1]) -
+           log(adj_mat[motif_len + 1 - s, sample[motif_len] + 1])
+       adj_score &lt;- adj_score + exp(adj_s)
+     }
+     sample_score &lt;- .Call(&quot;test_compute_sample_score_change&quot;, test_pwm, test_score, adj_mat, sample[seq(2 * motif_len - 1)], snpInfo$prior, trans_mat, sample[2 * motif_len], theta, package = &quot;atSNP&quot;)
+     expect_equal(adj_score, sample_score[1])
+   }
+ })
Test passed 🥳
&gt; 
&gt; test_that(&quot;Error: compute the normalizing constant.&quot;, {
+   ## parameters
+   for(p in seq(9) / 10) {
+     delta &lt;- .Call(&quot;test_find_percentile_change&quot;, score_diff, p, package = &quot;atSNP&quot;)
+     theta &lt;- .Call(&quot;test_find_theta_change&quot;, test_score, adj_mat, delta, package = &quot;atSNP&quot;)
+     const &lt;- .Call(&quot;test_func_delta_change&quot;, test_score, adj_mat, theta, package = &quot;atSNP&quot;)
+     ## in R
+     adj_sum &lt;- rowSums(adj_mat)
+     wei_sum &lt;- rowSums(test_score ^ theta)
+     const.r &lt;- prod(adj_sum) * sum(wei_sum / adj_sum)
+     expect_equal(const, const.r)
+   }
+ })
Test passed 🎉
&gt; 
&gt; test_that(&quot;Error: sample distributions are not expected.&quot;, {
+   ## parameters
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile_change&quot;, score_diff, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta_change&quot;, test_score, adj_mat, delta, package = &quot;atSNP&quot;)
+   prob_start &lt;- rev(rowSums(test_score ^ theta) / rowSums(adj_mat))
+   ## construct the delta matrix
+   delta &lt;- matrix(1, nrow = 4 * motif_len, ncol = 2 * motif_len - 1)
+   for(pos in seq(motif_len)) {
+     delta[seq(4) + 4 * (pos - 1), ] &lt;- snpInfo$prior
+     delta[seq(4) + 4 * (pos - 1), pos - 1 + seq(motif_len)] &lt;- t(test_pwm)
+     delta[seq(4) + 4 * (pos - 1), motif_len] &lt;- test_score[motif_len + 1 - pos, ] ^ theta
+     delta[seq(4) + 4 * (pos - 1), ] &lt;- delta[seq(4) + 4 * (pos - 1),] / rep(colSums(delta[seq(4) + 4 * (pos - 1), ]), each = 4)
+   }
+   target_freq &lt;- matrix(0, nrow = 4, ncol = 2 * motif_len - 1)
+   for(pos in seq(motif_len)) {
+     target_freq &lt;- target_freq + delta[seq(4) + 4 * (pos - 1), ] * prob_start[pos]
+   }
+   target_freq &lt;- t(target_freq)
+   target_freq &lt;- target_freq / rowSums(target_freq)
+ 
+   results_i &lt;- function(i) {
+     ## generate 100 samples
+     sample1 &lt;- sapply(seq(100), function(x)
+       .Call(&quot;test_importance_sample_change&quot;,
+             adj_mat, snpInfo$prior, trans_mat, test_score, theta, package = &quot;atSNP&quot;))
+     emp_freq1 &lt;- get_freq(sample1)
+     sample2 &lt;- sapply(rep(theta, 100), drawonesample)
+     emp_freq2 &lt;- get_freq(sample2 - 1)
+     ##    print(rbind(emp_freq1[10, ], emp_freq2[10, ], target_freq[10, ]))
+     max(abs(emp_freq1 - target_freq)) &gt; max(abs(emp_freq2 - target_freq))
+   }
+   
+   if(Sys.info()[[&quot;sysname&quot;]] == &quot;Windows&quot;){
+     snow &lt;- SnowParam(workers = 1, type = &quot;SOCK&quot;)
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = snow,SIMPLIFY = FALSE)
+   }else{
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = MulticoreParam(workers = 1),
+                               SIMPLIFY = FALSE)
+   }
+ 
+   print(sum(unlist(results)))
+   print(pbinom(sum(unlist(results)), size = 20, prob = 0.5))
+ })
[1] 13
[1] 0.9423409
── Skip (???): Error: sample distributions are not expected. ───────────────────
Reason: empty test

&gt; 
&gt; test_that(&quot;Error: the chosen pvalues should have the smaller variance.&quot;, {
+   .structure_diff &lt;- function(pval_mat) {
+     id &lt;- apply(pval_mat[, c(2, 4)], 1, which.min)
+     return(cbind(pval_mat[, c(1, 3)][cbind(seq_along(id), id)],
+                  pval_mat[, c(2, 4)][cbind(seq_along(id), id)]))
+   }
+   for(p in c(0.05, 0.1, 0.2, 0.5)) {
+     p_values &lt;- .Call(&quot;test_p_value_change&quot;, test_pwm, test_score, adj_mat, snpInfo$prior, snpInfo$transition, score_diff, pval_ratio, quantile(score_diff, 1 - p), 100, package = &quot;atSNP&quot;)$score
+     p_values_s &lt;- .structure_diff(p_values)
+     expect_equal(p_values_s[, 2], apply(p_values[, c(2, 4)], 1, min))
+   }
+ })
Test passed 😸
&gt; 
&gt; proc.time()
   user  system elapsed 
 20.328   0.762  21.251 
</PRE>
</DIV><P><SPAN class="filename">atSNP.Rcheck/tests/test_diff.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R Under development (unstable) (2023-03-12 r83975) -- &quot;Unsuffered Consequences&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; library(atSNP)

&gt; library(BiocParallel)
&gt; library(testthat)
&gt; data(example)
&gt; 
&gt; trans_mat &lt;- matrix(rep(snpInfo$prior, each = 4), nrow = 4)
&gt; test_pwm &lt;- motif_library$SIX5_disc1
&gt; scores &lt;- as.matrix(motif_scores$motif.scores[3:4, 4:5])
&gt; score_diff &lt;- abs(scores[,2]-scores[,1])
&gt; 
&gt; test_score &lt;- test_pwm
&gt; for(i in seq(nrow(test_score))) {
+   for(j in seq(ncol(test_score))) {
+     test_score[i, j] &lt;- exp(mean(log(test_pwm[i, j] / test_pwm[i, -j])))
+   }
+ }
&gt; 
&gt; adj_mat &lt;- test_pwm + rowMeans(test_pwm)
&gt; motif_len &lt;- nrow(test_pwm)
&gt; 
&gt; ## these are functions for this test only
&gt; drawonesample &lt;- function(theta) {
+     prob_start &lt;- sapply(seq(motif_len),
+                          function(j)
+                              sum(snpInfo$prior * test_score[motif_len + 1 - j, ] ^ theta *
+                                      adj_mat[motif_len + 1 - j, ]) /
+                                          sum(snpInfo$prior * adj_mat[motif_len + 1 - j, ])
+                          )
+     id &lt;- sample(seq(motif_len), 1, prob = prob_start)
+     sample &lt;- sample(1:4, 2 * motif_len - 1, replace = TRUE, prob = snpInfo$prior)
+     delta &lt;- adj_mat
+     delta[motif_len + 1 - id, ] &lt;- delta[motif_len + 1 - id, ] * test_score[motif_len + 1 - id, ] ^ theta
+     sample[id - 1 + seq(motif_len)] &lt;- apply(delta, 1, function(x)
+         sample(seq(4), 1, prob = x * snpInfo$prior))
+     sc &lt;- 0
+     for(s in seq(motif_len)) {
+       delta &lt;- adj_mat
+       delta[motif_len + 1 - s, ] &lt;- delta[motif_len + 1 - s, ] * test_score[motif_len + 1 - s, ] ^ theta
+       sc &lt;- sc + prod(delta[cbind(seq(motif_len), sample[s - 1 + seq(motif_len)])])
+     }
+     sample &lt;- c(sample, id, sc)
+     return(sample)
+ }
&gt; jointprob &lt;- function(x) prod(test_pwm[cbind(seq(motif_len), x)])
&gt; maxjointprob &lt;- function(x) {
+   maxp &lt;- -Inf
+   p &lt;- -Inf
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(x[i:(i+motif_len - 1)])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(5 - x[(i+motif_len - 1):i])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   return(maxp)
+ }
&gt; get_freq &lt;- function(sample) {
+   emp_freq &lt;- matrix(0, nrow = 2 * motif_len - 1, ncol = 4)
+   for(i in seq(2 * motif_len - 1)) {
+     for(j in seq(4)) {
+       emp_freq[i, j] &lt;- sum(sample[i, ] == j - 1)
+     }
+   }
+   emp_freq &lt;- emp_freq / rowSums(emp_freq)
+   return(emp_freq)
+ }
&gt; 
&gt; test_that(&quot;Error: quantile function computing are not equivalent.&quot;, {
+   for(p in c(0.01, 0.1, 0.5, 0.9, 0.99)) {
+     delta &lt;- .Call(&quot;test_find_percentile_diff&quot;, score_diff, p, package = &quot;atSNP&quot;)
+     delta.r &lt;- as.double(sort(abs(scores[,2]-scores[,1]))[ceiling((1 - p) * (nrow(scores)))])
+     expect_equal(delta, delta.r)
+   }
+ })
Test passed 🌈
&gt; 
&gt; test_that(&quot;Error: the scores for samples are not equivalent.&quot;, {
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile_diff&quot;, score_diff, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta_diff&quot;, test_score, adj_mat, snpInfo$prior, snpInfo$transition, delta, package = &quot;atSNP&quot;)
+   ## Use R code to generate a random sample
+   for(i in seq(10)) {
+     sample &lt;- drawonesample(theta)
+     sample_score &lt;- .Call(&quot;test_compute_sample_score_diff&quot;, test_pwm, test_score, adj_mat, sample[seq(2 * motif_len - 1)] - 1, sample[2 * motif_len] - 1, theta, package = &quot;atSNP&quot;)
+     expect_equal(sample[2 * motif_len + 1], sample_score[1])
+     sample1 &lt;- sample2 &lt;- sample3 &lt;- sample
+     sample1[motif_len] &lt;- seq(4)[-sample[motif_len]][1]
+     sample2[motif_len] &lt;- seq(4)[-sample[motif_len]][2]
+     sample3[motif_len] &lt;- seq(4)[-sample[motif_len]][3]
+     sample_score_r &lt;- log(maxjointprob(sample[seq(2 * motif_len - 1)])) -
+       log(c(maxjointprob(sample1[seq(2 * motif_len - 1)]),
+             maxjointprob(sample2[seq(2 * motif_len - 1)]),
+             maxjointprob(sample3[seq(2 * motif_len - 1)])))
+     expect_equal(sample_score_r, sample_score[-1])
+   }
+   
+   ## Use C code to generate a random sample
+   delta &lt;- matrix(1, nrow = 4 * motif_len, ncol = 2 * motif_len - 1)
+   for(pos in seq(motif_len)) {
+       for(j in (pos + motif_len - 1) : 1) {
+           if(j &lt; pos + motif_len - 1) {
+               delta[4 * (pos - 1) + seq(4), j] &lt;- sum(snpInfo$prior * delta[4 * (pos - 1) + seq(4), j + 1])
+           }
+           if(j &gt;= pos) {
+               delta[4 * (pos - 1) + seq(4), j] &lt;- delta[4 * (pos - 1) + seq(4), j] * adj_mat[j - pos + 1, ]
+           }
+           if(j == motif_len) {
+               delta[4 * (pos - 1) + seq(4), j] &lt;- delta[4 * (pos - 1) + seq(4), j] * test_score[j - pos + 1, ] ^ theta
+           }
+       }
+   }
+   for(i in seq(10)) {
+     sample &lt;- .Call(&quot;test_importance_sample_diff&quot;, delta, snpInfo$prior, trans_mat, test_pwm, theta, package = &quot;atSNP&quot;)
+     start_pos &lt;- sample[2 * motif_len] + 1
+     adj_score &lt;- 0
+     for(s in seq_len(motif_len)) {
+       adj_s &lt;- sum(log(adj_mat[cbind(seq(motif_len), sample[s - 1 + seq(motif_len)] + 1)]))
+       adj_s &lt;- adj_s + theta * log(test_score[motif_len + 1 - s, sample[motif_len] + 1])
+       adj_score &lt;- adj_score + exp(adj_s)
+     }
+     sample_score &lt;- .Call(&quot;test_compute_sample_score_diff&quot;, test_pwm, test_score, adj_mat, sample[seq(2 * motif_len - 1)], sample[2 * motif_len], theta, package = &quot;atSNP&quot;)
+     expect_equal(adj_score, sample_score[1])
+   }
+ })
Test passed 🥇
&gt; 
&gt; test_that(&quot;Error: compute the normalizing constant.&quot;, {
+ 
+   ## parameters
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile_diff&quot;, score_diff, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta_diff&quot;, test_score, adj_mat, snpInfo$prior, snpInfo$transition, delta, package = &quot;atSNP&quot;)
+   
+   ##
+   const &lt;- .Call(&quot;test_func_delta_diff&quot;, test_score, adj_mat, snpInfo$prior, trans_mat, theta, package = &quot;atSNP&quot;)
+ 
+    prob_start &lt;- sapply(seq(motif_len),
+                          function(j)
+                              sum(snpInfo$prior * test_score[motif_len + 1 - j, ] ^ theta *
+                                      adj_mat[motif_len + 1 - j, ]) /
+                                          sum(snpInfo$prior * adj_mat[motif_len + 1 - j, ])
+                          )
+   
+   const.r &lt;- prod(colSums(snpInfo$prior * t(adj_mat))) * sum(prob_start)
+   expect_equal(const, const.r)
+ })
Test passed 🥇
&gt; 
&gt; test_that(&quot;Error: sample distributions are not expected.&quot;, {
+   
+   ## parameters
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile_diff&quot;, score_diff, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta_diff&quot;, test_score, adj_mat, snpInfo$prior, snpInfo$transition, delta, package = &quot;atSNP&quot;)
+ 
+   ## construct the delta matrix
+   delta &lt;- matrix(1, nrow = 4 * motif_len, ncol = 2 * motif_len - 1)
+    for(pos in seq(motif_len)) {
+         for(j in (pos + motif_len - 1) : 1) {
+             if(j &lt; pos + motif_len - 1) {
+                 delta[4 * (pos - 1) + seq(4), j] &lt;- sum(snpInfo$prior * delta[4 * (pos - 1) + seq(4), j + 1])
+             }
+             if(j &gt;= pos) {
+                 delta[4 * (pos - 1) + seq(4), j] &lt;- delta[4 * (pos - 1) + seq(4), j] * adj_mat[j - pos + 1, ]
+             }
+             if(j == motif_len) {
+                 delta[4 * (pos - 1) + seq(4), j] &lt;- delta[4 * (pos - 1) + seq(4), j] * test_score[j - pos + 1, ] ^ theta
+             }
+         }
+     }
+ 
+   target_freq &lt;- matrix(0, nrow = 4, ncol = 2 * motif_len - 1)
+   
+   mat &lt;- snpInfo$prior * matrix(delta[, 1], nrow = 4)
+   wei &lt;- colSums(mat)
+   for(j in seq(2 * motif_len - 1)) {
+       for(pos in seq(motif_len)) {
+           tmp &lt;- delta[seq(4) + 4 * (pos - 1), j] * snpInfo$prior
+           target_freq[, j] &lt;- target_freq[, j] +  tmp / sum(tmp) * wei[pos]
+       }
+   }
+   target_freq &lt;- t(target_freq)
+   target_freq &lt;- target_freq / rowSums(target_freq)
+ 
+   results_i &lt;- function(i) {
+     ## generate 100 samples
+     sample1 &lt;- sapply(seq(100), function(x)
+       .Call(&quot;test_importance_sample_diff&quot;,
+             delta, snpInfo$prior, trans_mat, test_score, theta, package = &quot;atSNP&quot;))
+     emp_freq1 &lt;- get_freq(sample1)
+     
+     sample2 &lt;- sapply(rep(theta, 100), drawonesample)
+     emp_freq2 &lt;- get_freq(sample2 - 1)
+     
+     ##    print(rbind(emp_freq1[10, ], emp_freq2[10, ], target_freq[10, ]))
+     max(abs(emp_freq1 - target_freq)) &gt; max(abs(emp_freq2 - target_freq))
+   }
+  
+   if(Sys.info()[[&quot;sysname&quot;]] == &quot;Windows&quot;){
+     snow &lt;- SnowParam(workers = 1, type = &quot;SOCK&quot;)
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = snow,SIMPLIFY = FALSE)
+   }else{
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = MulticoreParam(workers = 1),
+                       SIMPLIFY = FALSE)
+   }
+   
+   print(sum(unlist(results)))
+ 
+   print(pbinom(sum(unlist(results)), size = 20, prob = 0.5))
+   
+ })
[1] 5
[1] 0.02069473
── Skip (???): Error: sample distributions are not expected. ───────────────────
Reason: empty test

&gt; 
&gt; test_that(&quot;Error: the chosen pvalues should have the smaller variance.&quot;, {
+ 
+   .structure_diff &lt;- function(pval_mat) {
+     id &lt;- apply(pval_mat[, c(2, 4)], 1, which.min)
+     return(cbind(pval_mat[, c(1, 3)][cbind(seq_along(id), id)],
+                  pval_mat[, c(2, 4)][cbind(seq_along(id), id)]))
+   }
+   
+   for(p in c(0.05, 0.1, 0.2, 0.5)) {
+     p_values &lt;- .Call(&quot;test_p_value_diff&quot;, test_pwm, test_score, adj_mat, snpInfo$prior, snpInfo$transition, score_diff, quantile(score_diff, 1 - p), 100, package = &quot;atSNP&quot;)
+     p_values_s &lt;- .structure_diff(p_values)
+     expect_equal(p_values_s[, 2], apply(p_values[, c(2, 4)], 1, min))
+   }
+ })
Test passed 🌈
&gt; 
&gt; proc.time()
   user  system elapsed 
 20.534   0.783  21.555 
</PRE>
</DIV><P><SPAN class="filename">atSNP.Rcheck/tests/test_is.Rout</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<PRE style="padding: 3px;">

R Under development (unstable) (2023-03-12 r83975) -- &quot;Unsuffered Consequences&quot;
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type &#x27;license()&#x27; or &#x27;licence()&#x27; for distribution details.

R is a collaborative project with many contributors.
Type &#x27;contributors()&#x27; for more information and
&#x27;citation()&#x27; on how to cite R or R packages in publications.

Type &#x27;demo()&#x27; for some demos, &#x27;help()&#x27; for on-line help, or
&#x27;help.start()&#x27; for an HTML browser interface to help.
Type &#x27;q()&#x27; to quit R.

&gt; library(atSNP)

&gt; library(BiocParallel)
&gt; library(testthat)
&gt; data(example)
&gt; 
&gt; trans_mat &lt;- matrix(rep(snpInfo$prior, each = 4), nrow = 4)
&gt; test_pwm &lt;- motif_library$SIX5_disc1
&gt; scores &lt;- as.matrix(motif_scores$motif.scores[3:4, 4:5])
&gt; 
&gt; motif_len &lt;- nrow(test_pwm)
&gt; 
&gt; ## these are functions for this test only
&gt; drawonesample &lt;- function(theta) {
+   delta &lt;- snpInfo$prior * t(test_pwm ^ theta)
+   delta &lt;- delta / rep(colSums(delta), each = 4)
+   sample &lt;- sample(1:4, 2 * motif_len - 1, replace = TRUE, prob = snpInfo$prior)
+   id &lt;- sample(seq(motif_len), 1)
+   sample[id : (id + motif_len - 1)] &lt;- apply(delta, 2, function(x) sample(1:4, 1, prob = x))
+   sc &lt;- s_cond &lt;- 0
+   for(s in seq(motif_len)) {
+     sc &lt;- sc + prod(test_pwm[cbind(seq(motif_len),
+                                   sample[s : (s + motif_len - 1)])]) ^ theta
+   }
+   s_cond &lt;- prod(test_pwm[cbind(seq(motif_len),
+                                 sample[id : (id + motif_len - 1)])]) ^ theta
+   sample &lt;- c(sample, id, sc, s_cond)
+   return(sample)
+ }
&gt; jointprob &lt;- function(x) prod(test_pwm[cbind(seq(motif_len), x)])
&gt; maxjointprob &lt;- function(x) {
+   maxp &lt;- -Inf
+   p &lt;- -Inf
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(x[i:(i+motif_len - 1)])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   for(i in 1:motif_len) {
+     p &lt;- jointprob(5 - x[(i+motif_len - 1):i])
+     if(p &gt; maxp)
+       maxp &lt;- p
+   }
+   return(maxp)
+ }
&gt; get_freq &lt;- function(sample) {
+   ids &lt;- cbind(
+                rep(sample[motif_len * 2, ], each = motif_len) + seq(motif_len),
+                rep(seq(100), each = motif_len))
+   sample_motif &lt;- matrix(sample[ids], nrow = motif_len) + 1
+   emp_freq &lt;- matrix(0, nrow = motif_len, ncol = 4)
+   for(i in seq(motif_len)) {
+     for(j in seq(4)) {
+       emp_freq[i, j] &lt;- sum(sample_motif[i, ] == j)
+     }
+   }
+   emp_freq &lt;- emp_freq / rowSums(emp_freq)
+   return(emp_freq)
+ }
&gt; 
&gt; test_that(&quot;Error: quantile function computing are not equivalent.&quot;, {
+   for(p in c(0.01, 0.1, 0.5, 0.9, 0.99)) {
+     delta &lt;- .Call(&quot;test_find_percentile&quot;, c(scores), p, package = &quot;atSNP&quot;)
+     delta.r &lt;- -sort(-c(scores))[as.integer(p * length(scores)) + 1]
+     expect_equal(delta, delta.r)
+   }
+ })
Test passed 😀
&gt; 
&gt; test_that(&quot;Error: the scores for samples are not equivalent.&quot;, {
+   p &lt;- 0.01
+   delta &lt;- .Call(&quot;test_find_percentile&quot;, scores, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta&quot;, test_pwm, snpInfo$prior, snpInfo$transition, delta, package = &quot;atSNP&quot;)
+   ## Use R code to generate a random sample
+   for(i in seq(10)) {
+     sample &lt;- drawonesample(theta)
+     sample_score &lt;- .Call(&quot;test_compute_sample_score&quot;, test_pwm, sample[seq(2 * motif_len - 1)] - 1, sample[motif_len * 2] - 1, theta, package = &quot;atSNP&quot;)
+     expect_equal(sample[2 * motif_len + 1], sample_score[2])
+     expect_equal(sample[2 * motif_len + 2], sample_score[3])
+   }
+   ## Use C code to generate a random sample
+   for(i in seq(10)) {
+     delta &lt;- t(test_pwm ^ theta)
+     delta &lt;- cbind(matrix(
+                           sum(snpInfo$prior * delta[, 1]),
+                           nrow = 4, ncol = motif_len - 1), delta)
+     sample &lt;- .Call(&quot;test_importance_sample&quot;, delta, snpInfo$prior, trans_mat, test_pwm, theta, package = &quot;atSNP&quot;)
+     start_pos &lt;- sample[motif_len * 2]
+     adj_score &lt;- 0
+     for(s in seq(motif_len) - 1) {
+       adj_score &lt;- adj_score + prod(test_pwm[cbind(seq(motif_len),
+                                                    sample[s + seq(motif_len)] + 1)]) ^ theta
+     }
+     adj_score_cond &lt;- prod(test_pwm[cbind(seq(motif_len), sample[start_pos + seq(motif_len)] + 1)]) ^ theta
+     sample_score &lt;- .Call(&quot;test_compute_sample_score&quot;, test_pwm, sample[seq(2 * motif_len - 1)], sample[motif_len * 2], theta, package = &quot;atSNP&quot;)
+     expect_equal(adj_score, sample_score[2])
+     expect_equal(adj_score_cond, sample_score[3])
+   }
+ })
Test passed 🎊
&gt; 
&gt; test_that(&quot;Error: compute the normalizing constant.&quot;, {
+   ## parameters
+   p &lt;- 0.01
+   delta &lt;- .Call(&quot;test_find_percentile&quot;, scores, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta&quot;, test_pwm, snpInfo$prior, snpInfo$transition, delta, package = &quot;atSNP&quot;)
+   ##
+   const &lt;- .Call(&quot;test_func_delta&quot;, test_pwm, snpInfo$prior, trans_mat, theta, package = &quot;atSNP&quot;)
+   const.r &lt;- prod(colSums(snpInfo$prior * t(test_pwm) ^ theta)) * motif_len
+   expect_equal(abs(const - const.r) / const &lt; 1e-5, TRUE)
+ })
Test passed 🥳
&gt; 
&gt; test_that(&quot;Error: sample distributions are not expected.&quot;, {
+   ## parameters
+   p &lt;- 0.1
+   delta &lt;- .Call(&quot;test_find_percentile&quot;, scores, p, package = &quot;atSNP&quot;)
+   theta &lt;- .Call(&quot;test_find_theta&quot;, test_pwm, snpInfo$prior, trans_mat, delta, package = &quot;atSNP&quot;)
+   delta &lt;- t(test_pwm ^ theta)
+   delta &lt;- cbind(matrix(
+                         sum(snpInfo$prior * delta[, 1]),
+                         nrow = 4, ncol = motif_len - 1), delta)
+ 
+   results_i &lt;- function(i) {
+     ## generate 100 samples
+     sample &lt;- sapply(seq(100), function(x)
+                      .Call(&quot;test_importance_sample&quot;,
+                            delta, snpInfo$prior, trans_mat, test_pwm, theta, package = &quot;atSNP&quot;))
+     emp_freq1 &lt;- get_freq(sample)
+     target_freq &lt;- test_pwm ^ theta * snpInfo$prior
+     target_freq &lt;- target_freq / rowSums(target_freq)
+     ## generate samples in R
+     sample &lt;- sapply(rep(theta, 100), drawonesample)
+     emp_freq2 &lt;- get_freq(sample[seq(2 * motif_len), ] - 1)
+     max(abs(emp_freq1 - target_freq)) &gt; max(abs(emp_freq2 - target_freq))
+   }
+ 
+   if(Sys.info()[[&quot;sysname&quot;]] == &quot;Windows&quot;){
+     snow &lt;- SnowParam(workers = 1, type = &quot;SOCK&quot;)
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = snow,SIMPLIFY = FALSE)
+   }else{
+     results&lt;-bpmapply(results_i, seq(20), BPPARAM = MulticoreParam(workers = 1),
+                       SIMPLIFY = FALSE)
+   }
+   
+   print(sum(unlist(results)))
+   print(pbinom(sum(unlist(results)), size = 20, prob = 0.5))
+ })
[1] 13
[1] 0.9423409
── Skip (???): Error: sample distributions are not expected. ───────────────────
Reason: empty test

&gt; 
&gt; test_that(&quot;Error: the chosen pvalues should have the smaller variance.&quot;, {
+   .structure &lt;- function(pval_mat) {
+     id1 &lt;- apply(pval_mat[, c(2, 4)], 1, which.min)
+     return(cbind(
+                  pval_mat[, c(1, 3)][cbind(seq_along(id1), id1)],
+                  pval_mat[, c(2, 4)][cbind(seq_along(id1), id1)])
+            )
+   }
+   for(p in c(0.01, 0.05, 0.1)) {
+     theta &lt;- .Call(&quot;test_find_theta&quot;, test_pwm, snpInfo$prior, trans_mat, quantile(c(scores), 1 - p), package = &quot;atSNP&quot;)
+     p_values &lt;- .Call(&quot;test_p_value&quot;, test_pwm, snpInfo$prior, snpInfo$transition, c(scores), theta, 100, package = &quot;atSNP&quot;)
+     p_values_s &lt;- .structure(p_values)
+     expect_equal(p_values_s[, 2], apply(p_values[, c(2, 4)], 1, min))
+   }
+ })
Test passed 😸
&gt; 
&gt; proc.time()
   user  system elapsed 
 19.966   2.872  25.062 
</PRE>
</DIV><HR>
<H3>Example timings</H3>
<P><SPAN class="filename">atSNP.Rcheck/atSNP-Ex.timings</SPAN></P>
<DIV class="kunpeng1 hscrollable">
<TABLE>
<TR><TD>name</TD><TD style="text-align: right;">user</TD><TD style="text-align: right;">system</TD><TD style="text-align: right;">elapsed
</TD><TR>
<TR><TD>ComputeMotifScore</TD><TD style="text-align: right;">1.135</TD><TD style="text-align: right;">0.312</TD><TD style="text-align: right;">1.493</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>ComputePValues</TD><TD style="text-align: right;">1.414</TD><TD style="text-align: right;">0.699</TD><TD style="text-align: right;">1.706</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>GetIUPACSequence</TD><TD style="text-align: right;">0.002</TD><TD style="text-align: right;">0.001</TD><TD style="text-align: right;">0.002</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>LoadFastaData</TD><TD style="text-align: right;">0.271</TD><TD style="text-align: right;">0.060</TD><TD style="text-align: right;">0.366</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>LoadMotifLibrary</TD><TD style="text-align: right;">0.250</TD><TD style="text-align: right;">0.068</TD><TD style="text-align: right;">0.318</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>LoadSNPData</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">0</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>MatchSubsequence</TD><TD style="text-align: right;">1.102</TD><TD style="text-align: right;">0.441</TD><TD style="text-align: right;">1.593</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>dtMotifMatch</TD><TD style="text-align: right;">1.289</TD><TD style="text-align: right;">0.662</TD><TD style="text-align: right;">1.630</TD><TD style="text-align: right;">
</TD><TR>
<TR><TD>plotMotifMatch</TD><TD style="text-align: right;"> 1.277</TD><TD style="text-align: right;"> 9.844</TD><TD style="text-align: right;">19.427</TD><TD style="text-align: right;">
</TD><TR>
</TABLE>
</DIV></BODY>
</HTML>
